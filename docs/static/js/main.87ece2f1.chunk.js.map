{"version":3,"sources":["dungeon/GenerationSteps.ts","dungeon/IRenderSettings.ts","components/menu/Generate.tsx","components/common/RangeInput.tsx","components/menu/MapSize.tsx","dungeon/model/Region.ts","lib/model/Coord.ts","lib/randomColor.ts","components/menu/AddRegions.tsx","components/menu/ResizeRegions.tsx","components/menu/RegionTypes.tsx","dungeon/generation/linkLinesToGrid.ts","components/menu/Connections.tsx","components/menu/Regions.tsx","components/menu/Menu.tsx","components/Canvas.tsx","dungeon/model/Dungeon.ts","dungeon/renderDungeon.ts","lib/SRandom.ts","dungeon/generation/createRegions.ts","lib/model/Polygon.ts","lib/model/Triangle.ts","lib/graph/delauney.ts","lib/graph/gabriel.ts","lib/graph/getUniqueLines.ts","lib/graph/minimumSpanning.ts","lib/graph/relativeNeighbourhood.ts","dungeon/model/Pathway.ts","lib/model/Line.ts","dungeon/generation/populateLinks.ts","dungeon/generation/filterLinks.ts","dungeon/generation/populateCaveRegion.ts","dungeon/generation/populateRoomRegion.ts","dungeon/generation/createRooms.ts","dungeon/generation/detectWalls.ts","lib/model/Curve.ts","dungeon/generation/generateWallCurves.ts","lib/graph/getClosest.ts","dungeon/generation/associateTilesWithNodes.ts","dungeon/model/Hatching.ts","dungeon/generation/fillBackdrop.ts","dungeon/model/Tile.ts","dungeon/generateDungeon.ts","dungeon/generation/createTiles.ts","components/App.tsx","registerServiceWorker.ts","index.tsx"],"names":["GenerationSteps","allSteps","CreateTiles","CreateNodes","AssociateTiles","LinkNodes","FilterLinks","ExpandLines","CreateRooms","DetectWalls","CurveWalls","FillBackdrop","Render","determineRenderSettings","generationStage","stageComplete","cellSize","nodeAlpha","regionAlpha","graphAlpha","drawNodeLinks","drawGrid","drawWalls","highlightWallCurves","drawOutside","drawOutsidePoints","floorColor","floorGridColor","linkColor","linkWidth","backgroundColor","hatchingColor","wallColor","wallWidth","floorGridWidth","hatchingWidth","drawWallsAsFloor","minimumSpanningWidth","relativeNeighbourhoodWidth","gabrielWidth","delauneyWidth","Generate","props","generateOrSkip","isGenerating","className","onClick","generate","animateOrFinish","animate","useEffect","setRenderSettings","showSize","showRegions","RangeInput","onChange","onChangeComplete","changeHandler","useMemo","undefined","e","target","valueAsNumber","changeCompleteHandler","label","type","inputClassName","min","max","value","onMouseUp","onTouchEnd","disabled","RegionType","MapSize","goBack","generationSettings","cellsWide","val","scale","dungeon","nodes","x","setGenerationSettings","redraw","cellsHigh","y","Coord2D","this","magnitude","other","length","magnitudeSq","dx","dy","b","c","a","d","center","Math","sqrt","Region","parent","seed","regionType","color","regionInfluence","radius","links","colorChars","AddRegions","dungeonDisplay","leftClick","cellX","offsetX","cellY","offsetY","random","floor","NUM_VALUES","push","r","g","randomColor","rightClick","preventDefault","cell","getTileAt","region","node","filter","n","addEventListener","removeEventListener","ResizeRegions","RegionTypes","FIRST_VALUE","linkLinesToGrid","settings","subStepComplete","lines","link","tiles","getTouchedTiles","isFloor","x0","from","x1","to","y0","y1","col0","tilesByCoordinates","cell0","col1","cell1","steep","abs","tmp","gradient","iY","round","closestSideStep","almostInteger","RegionMode","Connections","linesByTile","allLines","Map","delauneyLines","line","tile","tileLines","get","set","singleLineTiles","paths","getLinesByTile","index","indexOf","slice","MenuPage","Regions","subMenu","useState","AddRemove","mode","setMode","regenerate","Resize","ChangeType","Menu","Main","currentPage","setCurrentPage","switchToMain","switchToSize","Size","switchToRegions","switchToRenders","Renders","canvas","steps","skip","finish","showRenders","FixedCanvas","ctx","root","state","width","height","ref","updateCtx","prevProps","prevState","getContext","React","Dungeon","backdropPoints","gabrielLines","relativeNeighbourhoodLines","minimumSpanningLines","walls","col","renderDungeon","clearRect","lineWidth","drawTile","drawTileGrid","globalAlpha","strokeStyle","drawPath","drawGraph","fillStyle","save","clipOutside","fillRect","xScale","point","yScale","lengthScale","translate","rotate","rotation","beginPath","moveTo","topSkew","lineTo","bottomSkew","fill","stroke","restore","fillOutside","arc","PI","lineCap","drawCurve","i","drawNode","pathway","room","isWall","strokeRect","curve","draw","halfCellSize","keyPoints","points","renderPoints","cx","cy","rect","clip","SRandom","s0","s1","s2","mash","t","next","minInclusive","maxExclusive","nextInRange","nextIntInRange","data","toString","h","charCodeAt","createRegions","makeNode","influence","nextColor","nodeCount","addSpacedNode","DelaySize","Small","totWidth","totHeight","getScaledDistSq","n1","n2","dxScaled","dyScaled","node1","node2","closestDist1","Number","MAX_VALUE","closestDist2","Triangle","vertices","circumCenter","circumRadiusSq","circumCircle","computeDelauneyTriangulation","superTriangle","triangulation","badTriangles","triangle","insideCircumcircle","polygon","edgeFrom","edgeTo","sharedWithOther","splice","vertex","distanceSqTo","computeGabrielGraph","graph","graphLinks","anyBlocking","halfwayTo","radiusSq","getUniqueLines","polygons","createLine","v0","v1","some","l","computeMinimumSpanningTree","unvisitedNodes","firstNode","pop","possibleLinks","map","lengthSq","sort","visitedNodes","testLink","alreadyHasFrom","alreadyHasTo","addingNode","j","computeRelativeNeighbourhoodGraph","Pathway","populateLinks","enclosingTriangle","Artificial","delauneyTriangles","Medium","filterLinks","connectivity","selectingFrom","selectFraction","numToSelect","selectedLink","populateCaveRegion","regionTiles","nonEdgeTiles","adjacentTiles","mutableTiles","runCellularAutomataStep","removeUnconnectedFloorTiles","cells","results","wasAlive","numAdjacentLiving","shouldLive","result","rootTile","connectedTiles","Set","tilesToTest","has","add","populateRoomRegion","nodeX","nodeY","determineBounds","minX","minY","maxX","maxY","growUpLeft","growDownRight","canLeft","canUp","isRowInRegion","isColInRegion","canRight","canDown","y2","x2","createRooms","Natural","detectWalls","iCol","toTest","getAdjacent","test","Tiny","orthogonal","diagonal","Curve","curvature","isLoop","t1x","t2x","t1y","t2y","c1","c2","c3","c4","fraction","step","iPt","lastCellIndex","tension","pts","firstCell","lastCell","secondCell","unshift","stepsPerSegment","pow","generateWallCurves","generateWallCurve","updateRenderPoints","firstTile","isRootLevel","generateSingleWallCurve","mainCurve","newStartPoint","backtrackToNewStartPoint","checkForCurveLoops","branchIndex","newCurve","newBranch","oldBranch","concat","curveTile","pickBestAdjacentWallTile","firstPoint","lastPoint","splitPos","lastIndexOf","splitCurve","splitPoint","prevTile","actualFirstTile","find","pickBestAdjacentWallTileOrthogonalThenDiagonal","lastTile","Minimal","ortho","bestTile","bestNumAdjacentNonWallTiles","numAdjacentNonWallTiles","allAdjacent","getClosest","getDistance","bestDist","bestNode","dist","associateTilesWithNodes","distance","Hatching","fillBackdrop","wallTiles","backdropTiles","addAdjacentNonFloorTiles","adjacent","Tile","createTiles","Array","generateDungeon","regenerateDungeon","seedGenerator","stepFunctions","operation","stepSeed","subStepReached","animateSteps","interval","delay","Large","milliseconds","Promise","resolve","setTimeout","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","catch","error","ReactDOM","setDungeon","generating","setGenerating","renderSettings","stage","current","document","getElementById","URL","process","origin","fetch","response","status","headers","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"qOAAYA,E,2EAAAA,O,6BAAAA,I,6BAAAA,I,mCAAAA,I,yBAAAA,I,6BAAAA,I,6BAAAA,I,6BAAAA,I,6BAAAA,I,2BAAAA,I,+BAAAA,I,oBAAAA,I,4BAAAA,M,KAiBL,IAAMC,EAAW,CACpBD,EAAgBE,YAChBF,EAAgBG,YAChBH,EAAgBI,eAChBJ,EAAgBK,UAChBL,EAAgBM,YAChBN,EAAgBO,YAChBP,EAAgBQ,YAChBR,EAAgBS,YAChBT,EAAgBU,WAChBV,EAAgBW,aAChBX,EAAgBY,QCEb,SAASC,IAII,IAHhBC,EAGe,uDAHGd,EAAgBY,OAClCG,IAEe,yDADfC,EACe,uCACXC,EAAY,EACZC,EAAc,EACdC,EAAa,EACbC,GAAgB,EAChBC,GAAW,EACXC,GAAY,EACZC,GAAsB,EACtBC,GAAc,EACdC,GAAoB,EAGxB,OAAQX,GACJ,KAAKd,EAAgBE,YACjBmB,GAAW,EACX,MAEJ,KAAKrB,EAAgBG,YACjBc,EAAY,EACZI,GAAW,EACX,MAEJ,KAAKrB,EAAgBI,eACjBa,EAAY,EACZC,EAAc,IACdG,GAAW,EACX,MAEJ,KAAKrB,EAAgBK,UACjBY,EAAY,EACZC,EAAc,GACdC,EAAa,IACbE,GAAW,EACX,MAEJ,KAAKrB,EAAgBM,YACjBW,EAAY,IACZC,EAAc,IACdE,GAAgB,EAChBC,GAAW,EACX,MAEJ,KAAKrB,EAAgBO,YAKrB,KAAKP,EAAgBQ,YACjBU,EAAc,GACdG,GAAW,EACX,MAEJ,KAAKrB,EAAgBS,YACjBY,GAAW,EACX,MAEJ,KAAKrB,EAAgBU,WACjBW,GAAW,EACXC,GAAY,EAEZC,GAAuBR,EACvB,MAEJ,KAAKf,EAAgBW,aACjBU,GAAW,EACXC,GAAY,EACZG,GAAoB,EACpB,MAEJ,KAAKzB,EAAgBY,OACjBS,GAAW,EACXC,GAAY,EACZE,GAAc,EAItB,MAAO,CACHP,YACAC,cACAC,aACAC,gBACAC,WACAC,YACAC,sBACAE,oBACAD,cACAE,WAAY,OACZC,eAAgB,wBAChBC,UAAW,OACXC,UAAW,EACXC,gBAAiB,OACjBC,cAAe,OACfC,UAAW,OACXhB,WACAiB,UAAWjB,EACXkB,eAAgB,EAChBC,cAA0B,KAAXnB,EACfoB,kBAvFmB,EAwFnBC,qBAAsBrB,EACtBsB,2BAAuC,GAAXtB,EAC5BuB,aAAyB,IAAXvB,EACdwB,cAAe,G,8NCpHhB,IAAMC,EAAqC,SAAAC,GAC9C,IAAMC,EAAiBD,EAAME,aACvB,0BAAQC,UAAU,gBAAlB,aACA,0BAAQA,UAAU,eAAeC,QAASJ,EAAMK,UAAhD,gBAEAC,EAAkBN,EAAME,aACxB,0BAAQC,UAAU,gBAAlB,UACA,0BAAQA,UAAU,eAAeC,QAASJ,EAAMO,SAAhD,sBAQN,OANAC,qBAAU,WACNR,EAAMS,kB,yVAAN,IACOtC,EAAwBb,EAAgBY,QAAQ,EAAM8B,EAAM1B,cAEpE,IAEI,uBAAK6B,UAAU,2BAClB,0BAAQA,UAAU,aAAaC,QAASJ,EAAMU,UAA9C,YACA,0BAAQP,UAAU,aAAaC,QAASJ,EAAMW,aAA9C,gBAEA,uBAAKR,UAAU,iBAEdF,EACAK,IC1BIM,EAAuC,SAAAZ,GAAU,IACnDa,EAA8Bb,EAA9Ba,SAAUC,EAAoBd,EAApBc,iBAEXC,EAAgBC,mBAAQ,WAC1B,QAAiBC,IAAbJ,EAGJ,OAAO,SAACK,GAAD,OAA4CL,EAASK,EAAEC,OAAOC,kBACtE,CAACP,IAEEQ,EAAwBL,mBAAQ,WAClC,QAAyBC,IAArBH,EAGJ,OAAO,kBAAMA,OACd,CAACA,IAEJ,OACI,yBAAOX,UAAWH,EAAMG,WAAYH,EAAMsB,MACtC,yBACIC,KAAK,QACLpB,UAAWH,EAAMwB,eACjBC,IAAKzB,EAAMyB,IACXC,IAAK1B,EAAM0B,IACXC,MAAO3B,EAAM2B,MACbd,SAAUE,EACVa,UAAWP,EACXQ,WAAYR,EACZS,SAAU9B,EAAM8B,a,yjBCzBzB,ICdKC,EDcCC,EAAoC,SAAAhC,GAgC7C,OAPAQ,qBAAU,WACNR,EAAMS,kBAAN,KACOtC,EAAwBb,EAAgBS,aAAa,EAAMiC,EAAM1B,UADxE,CAEIoB,kBAAkB,OAEvB,IAEI,uBAAKS,UAAU,sBAClB,0BAAQA,UAAU,kCAAkCC,QAASJ,EAAMiC,QAAnE,WAEA,uBAAK9B,UAAU,eACX,gBAAC,EAAD,CACImB,MAAM,QACNG,IAAK,GACLC,IAAK,IACLC,MAAO3B,EAAMkC,mBAAmBC,UAChCtB,SAxCK,SAACuB,GACd,IAAMC,EAAQD,EAAMpC,EAAMkC,mBAAmBC,UADf,uBAE9B,YAAmBnC,EAAMsC,QAAQC,MAAjC,+CAAwC,SAC/BC,GAAKH,GAHgB,kFAM9BrC,EAAMyC,sBAAN,KACOzC,EAAMkC,mBADb,CAEIC,UAAWC,MAiCPtB,iBAAkBd,EAAM0C,SAG5B,gBAAC,EAAD,CACIpB,MAAM,SACNG,IAAK,GACLC,IAAK,IACLC,MAAO3B,EAAMkC,mBAAmBS,UAChC9B,SArCM,SAACuB,GACf,IAAMC,EAAQD,EAAMpC,EAAMkC,mBAAmBS,UADd,uBAE/B,YAAmB3C,EAAMsC,QAAQC,MAAjC,+CAAwC,SAC/BK,GAAKP,GAHiB,kFAM/BrC,EAAMyC,sBAAN,KACOzC,EAAMkC,mBADb,CAEIS,UAAWP,MA8BPtB,iBAAkBd,EAAM0C,Y,oCE3C3BG,EAAb,YACI,WAAmBL,EAAkBI,GAAY,IAAD,8BAC5C,+CADeJ,IAA6B,EAAXI,IAAW,EADpD,sEAMQ,OAAOE,KAAKC,UAAUD,KAAKN,EAAGM,KAAKF,KAN3C,6BASWI,GACH,OAAOF,KAAKN,IAAMQ,EAAMR,GAAKM,KAAKF,IAAMI,EAAMJ,IAVtD,0BAaQI,GACA,OAAO,IAAIH,EAAQC,KAAKN,EAAIQ,EAAMR,EAAGM,KAAKF,EAAII,EAAMJ,KAd5D,+BAiBaI,GACL,OAAO,IAAIH,EAAQC,KAAKN,EAAIQ,EAAMR,EAAGM,KAAKF,EAAII,EAAMJ,KAlB5D,qCAsBQ,IAAIK,EAASH,KAAKG,SAClB,OAAO,IAAIJ,EAAQC,KAAKN,EAAIS,EAAQH,KAAKF,EAAIK,KAvBrD,iCA0BeD,GACP,OAAOF,KAAKC,UAAUD,KAAKN,EAAIQ,EAAMR,EAAGM,KAAKF,EAAII,EAAMJ,KA3B/D,mCA8BiBI,GACT,OAAOF,KAAKI,YAAYJ,KAAKN,EAAIQ,EAAMR,EAAGM,KAAKF,EAAII,EAAMJ,KA/BjE,kCAkCgBI,GACR,IAAIG,EAAKH,EAAMR,EAAIM,KAAKN,EACpBY,EAAKJ,EAAMJ,EAAIE,KAAKF,EAEpBK,EAASH,KAAKC,UAAUI,EAAIC,GAChC,OAAO,IAAIP,EAAQM,EAAKF,EAAQG,EAAKH,KAvC7C,gCA0CcD,GACN,OAAO,IAAIH,GAASC,KAAKN,EAAIQ,EAAMR,GAAK,GAAIM,KAAKF,EAAII,EAAMJ,GAAK,KA3CxE,2IA8CUP,GACF,OAAO,IAAIQ,EAAQC,KAAKN,EAAIH,EAAOS,KAAKF,EAAIP,OA/CpD,mCAkDiBW,GACT,OAAOF,KAAKN,EAAIQ,EAAMJ,EAAIE,KAAKF,EAAII,EAAMR,IAnDjD,mCAsDiBa,EAAYC,GACrB,IAAIC,EAAIT,KACJU,GAAKD,EAAEf,EAAIc,EAAEd,IAAMa,EAAET,EAAIU,EAAEV,IAAMS,EAAEb,EAAIc,EAAEd,IAAMe,EAAEX,EAAIU,EAAEV,GAUvDa,EAAS,IAAIZ,KARNU,EAAEf,EAAIc,EAAEd,IAAMe,EAAEf,EAAIc,EAAEd,IAAMe,EAAEX,EAAIU,EAAEV,IAAMW,EAAEX,EAAIU,EAAEV,IAAM,GAAKS,EAAET,EAAIU,EAAEV,KACtES,EAAEb,EAAIc,EAAEd,IAAMa,EAAEb,EAAIc,EAAEd,IAAMa,EAAET,EAAIU,EAAEV,IAAMS,EAAET,EAAIU,EAAEV,IAAM,GAAKW,EAAEX,EAAIU,EAAEV,IAC7EY,KAESH,EAAEb,EAAIc,EAAEd,IAAMa,EAAEb,EAAIc,EAAEd,IAAMa,EAAET,EAAIU,EAAEV,IAAMS,EAAET,EAAIU,EAAEV,IAAM,GAAKW,EAAEf,EAAIc,EAAEd,KACvEe,EAAEf,EAAIc,EAAEd,IAAMe,EAAEf,EAAIc,EAAEd,IAAMe,EAAEX,EAAIU,EAAEV,IAAMW,EAAEX,EAAIU,EAAEV,IAAM,GAAKS,EAAEb,EAAIc,EAAEd,IAC5EgB,GAWF,MALgC,CAC5BC,GAHYH,EAAEd,EAAIiB,EAAOjB,IAAMc,EAAEd,EAAIiB,EAAOjB,IAAMc,EAAEV,EAAIa,EAAOb,IAAMU,EAAEV,EAAIa,EAAOb,MApE9F,gCA8EsBO,EAAYC,GAC1B,OAAOM,KAAKC,KAAKb,KAAKI,YAAYC,EAAIC,MA/E9C,kCAkFwBD,EAAYC,GAC5B,OAAOD,EAAKA,EAAKC,EAAKA,MAnF9B,IA1BA,qC,SDIYrB,O,uBAAAA,I,qBAAAA,I,2BAAAA,I,2BAAAA,I,8BAAAA,M,KASL,IAAM6B,EAAb,YAII,WACaC,EACTrB,EACAI,EACOkB,EACAC,EACSC,GAEjB,IAAD,EADSC,EACT,uDAD2B,EAC3B,4BACE,4CAAMzB,EAAGI,KARAiB,SAOX,EAJSC,OAIT,EAHSC,aAGT,EAFkBC,QAElB,EADSC,kBACT,EAXFC,OAAiB,IAWf,EAVFC,MAAmB,GAUjB,EAZN,2BAA4BtB,GEbtBuB,EAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,K,8NCgB3C,IAAMC,EAAuC,SAAArE,GAAU,IAClDsE,EAA8CtE,EAA9CsE,eAAgBhC,EAA8BtC,EAA9BsC,QAASI,EAAqB1C,EAArB0C,OAAQpE,EAAa0B,EAAb1B,SAsDzC,OApDAkC,qBAAU,WACNR,EAAMS,kB,yVAAN,IACOtC,EAAwBb,EAAgBS,aAAa,EAAMiC,EAAM1B,UADxE,CAEIE,YAAa,GACbD,UAAW,EACXmB,kBAAkB,OAEvB,IAEHc,qBAAU,WACN,QAAuBS,IAAnBqD,EAAJ,CAIA,IAAMC,EAAY,SAACrD,GACX,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAGpBwF,EAAOJ,KAAKkB,SACZb,EAAaL,KAAKmB,MAAMnB,KAAKkB,SAAW7C,EAAW+C,YACzDxC,EAAQC,MAAMwC,KAAK,IAAInB,EAAOtB,EAASkC,EAAOE,EAAOZ,EAAMC,EDtCpE,WACH,IAAMiB,EAAIZ,EAAWV,KAAKmB,MAAMnB,KAAKkB,SAAWR,EAAWnB,SACrDgC,EAAIb,EAAWV,KAAKmB,MAAMnB,KAAKkB,SAAWR,EAAWnB,SACrDI,EAAIe,EAAWV,KAAKmB,MAAMnB,KAAKkB,SAAWR,EAAWnB,SAC3D,MAAM,IAAN,OAAW+B,GAAX,OAAeC,GAAf,OAAmB5B,GCkCgE6B,KACvExC,KAGFyC,EAAa,SAACjE,GAChB,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAE1B4C,EAAEkE,iBAGF,IAAMC,EAAO/C,EAAQgD,UAAUd,EAAOE,GACtC,QAAazD,IAAToE,GAAsC,OAAhBA,EAAKE,OAA/B,CAIA,IAAMC,EAAOH,EAAKE,OAClBjD,EAAQC,MAAQD,EAAQC,MAAMkD,QAAO,SAAAC,GAAC,OAAIA,IAAMF,KAEhD9C,MAMJ,OAHA4B,EAAeqB,iBAAiB,QAASpB,GACzCD,EAAeqB,iBAAiB,cAAeR,GAExC,WACHb,EAAesB,oBAAoB,QAASrB,GAC5CD,EAAesB,oBAAoB,cAAeT,OAEvD,CAACb,EAAgBhC,EAASI,EAAQpE,IAE9B,uBAAK6B,UAAU,iBAAf,8E,8NCzDJ,IAAM0F,EAA0C,SAAA7F,GAAU,IACrDsE,EAA8CtE,EAA9CsE,eAAgBhC,EAA8BtC,EAA9BsC,QAASI,EAAqB1C,EAArB0C,OAAQpE,EAAa0B,EAAb1B,SAsDzC,OApDAkC,qBAAU,WACNR,EAAMS,kB,yVAAN,IACOtC,EAAwBb,EAAgBS,aAAa,EAAMiC,EAAM1B,UADxE,CAEIE,YAAa,GACbD,UAAW,EACXmB,kBAAkB,OAEvB,IAGHc,qBAAU,WACN,QAAuBS,IAAnBqD,EAAJ,CAIA,IAAMC,EAAY,SAACrD,GACf,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAEpB+G,EAAO/C,EAAQgD,UAAUd,EAAOE,QACzBzD,IAAToE,GAAsC,OAAhBA,EAAKE,SAI/BF,EAAKE,OAAOtB,iBAAmB,IAC/BvB,MAGEyC,EAAa,SAACjE,GAChB,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAE1B4C,EAAEkE,iBAEF,IAAMC,EAAO/C,EAAQgD,UAAUd,EAAOE,QACzBzD,IAAToE,GAAsC,OAAhBA,EAAKE,SAI/BF,EAAKE,OAAOtB,iBAAmB,IAC/BvB,MAMJ,OAHA4B,EAAeqB,iBAAiB,QAASpB,GACzCD,EAAeqB,iBAAiB,cAAeR,GAExC,WACHb,EAAesB,oBAAoB,QAASrB,GAC5CD,EAAesB,oBAAoB,cAAeT,OAEvD,CAACb,EAAgBhC,EAASI,EAAQpE,IAE9B,uBAAK6B,UAAU,iBAAf,uE,8NCtDJ,IAAM2F,EAAwC,SAAA9F,GAAU,IACnDsE,EAA8CtE,EAA9CsE,eAAgBhC,EAA8BtC,EAA9BsC,QAASI,EAAqB1C,EAArB0C,OAAQpE,EAAa0B,EAAb1B,SAwDzC,OAtDAkC,qBAAU,WACNR,EAAMS,kB,yVAAN,IACOtC,EAAwBb,EAAgBS,aAAa,EAAMiC,EAAM1B,UADxE,CAEIE,YAAa,GACbD,UAAW,EACXmB,kBAAkB,OAEvB,IAGHc,qBAAU,WACN,QAAuBS,IAAnBqD,EAAJ,CAIA,IAAMC,EAAY,SAACrD,GACf,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAEpB+G,EAAO/C,EAAQgD,UAAUd,EAAOE,QACzBzD,IAAToE,GAAsC,OAAhBA,EAAKE,WAIzBF,EAAKE,OAAOxB,YAAchC,EAAW+C,aACvCO,EAAKE,OAAOxB,WAAahC,EAAWgE,aAExCrD,MAGEyC,EAAa,SAACjE,GAChB,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAE1B4C,EAAEkE,iBAEF,IAAMC,EAAO/C,EAAQgD,UAAUd,EAAOE,QACzBzD,IAAToE,GAAsC,OAAhBA,EAAKE,SAI/BF,EAAKE,OAAOzB,KAAOJ,KAAKkB,SACxBlC,MAMJ,OAHA4B,EAAeqB,iBAAiB,QAASpB,GACzCD,EAAeqB,iBAAiB,cAAeR,GAExC,WACHb,EAAesB,oBAAoB,QAASrB,GAC5CD,EAAesB,oBAAoB,cAAeT,OAEvD,CAACb,EAAgBhC,EAASI,EAAQpE,IAE9B,uBAAK6B,UAAU,iBAAf,6FClEJ,SAAe6F,EAAtB,wC,4CAAO,WACH1D,EACA2D,EACAnC,EACAoC,GAJG,qCAAA3C,EAAA,oFAMgBjB,EAAQ6D,MANxB,kEASC,IAHOC,EANR,QAOOC,EAAQC,EAAgBF,EAAM9D,GAPrC,6BASC,EAAmB+D,EAAnB,+CAA0B,QACjBE,SAAU,EAVpB,8kB,sBAeA,SAASD,EAAgBF,EAAe9D,GAG3C,IAAIkE,EAAK9C,KAAKmB,MAAMuB,EAAKK,KAAKjE,GAC1BkE,EAAKhD,KAAKmB,MAAMuB,EAAKO,GAAGnE,GACxBoE,EAAKlD,KAAKmB,MAAMuB,EAAKK,KAAK7D,GAC1BiE,EAAKnD,KAAKmB,MAAMuB,EAAKO,GAAG/D,GACtBkE,EAAOxE,EAAQyE,mBAAmBP,GAElCH,EAAgB,GAEtB,QAAapF,IAAT6F,EAAoB,CACpB,IAAME,EAAQF,EAAKF,QACL3F,IAAV+F,GACAX,EAAMtB,KAAKiC,GAInB,IAAMC,EAAO3E,EAAQyE,mBAAmBL,GACxC,QAAazF,IAATgG,EAAoB,CACpB,IAAMC,EAAQD,EAAKJ,QACL5F,IAAViG,GACAb,EAAMtB,KAAKmC,GAInB,IAAIC,EAAQzD,KAAK0D,IAAIP,EAAKD,GAAMlD,KAAK0D,IAAIV,EAAKF,GAC9C,GAAIW,EAAO,CACP,IAAIE,EAAMT,EACVA,EAAKJ,EACLA,EAAKa,EACLA,EAAMR,EACNA,EAAKH,EACLA,EAAKW,EAET,GAAIb,EAAKE,EAAI,CACT,IAAIW,EAAMX,EACVA,EAAKF,EACLA,EAAKa,EACLA,EAAMR,EACNA,EAAKD,EACLA,EAAKS,EAKT,IAFA,IAAIC,GAAYT,EAAKD,IAAOF,EAAKF,GAC7B5D,EAAIgE,EAAgB,GAAXU,EACJ9E,EAAIgE,EAAIhE,EAAIkE,EAAIlE,IAAK,CAC1B,IAAI+E,EAAK7D,KAAK8D,MAAM5E,EAAI,IACpB6E,EAAkBF,EAAK,GAAM3E,GAAK,EAAI,EACtC8E,EAAgBhE,KAAK0D,IAAIxE,EAAI2E,GAAM,GAEnCJ,GACAd,EAAMtB,KAAKzC,EAAQyE,mBAAmBQ,EAAKE,GAAiBjF,IAC5D6D,EAAMtB,KAAKzC,EAAQyE,mBAAmBQ,GAAI/E,IACrCkF,GACDrB,EAAMtB,KAAKzC,EAAQyE,mBAAmBQ,EAAKE,GAAiBjF,MAIhE6D,EAAMtB,KAAKzC,EAAQyE,mBAAmBvE,GAAG+E,EAAKE,IAC9CpB,EAAMtB,KAAKzC,EAAQyE,mBAAmBvE,GAAG+E,IACpCG,GACDrB,EAAMtB,KAAKzC,EAAQyE,mBAAmBvE,GAAG+E,EAAKE,KAItD7E,GAAK0E,EAGT,OAAOjB,E,8NCzEJ,ICEFsB,EDFQC,EAAwC,SAAA5H,GAAU,IACnDsE,EAA8CtE,EAA9CsE,eAAgBhC,EAA8BtC,EAA9BsC,QAASI,EAAqB1C,EAArB0C,OAAQpE,EAAa0B,EAAb1B,SAEzCkC,qBAAU,WACNR,EAAMS,kB,yVAAN,IACOtC,EAAwBb,EAAgBM,aAAa,EAAMoC,EAAM1B,UADxE,CAEIE,YAAa,IACbkB,kBAAkB,EAClBP,UAAsB,GAAXb,EACXY,UAAW,OACXT,WAAY,GACZkB,qBAAiC,GAAXrB,EACtBsB,2BAAuC,IAAXtB,EAC5BuB,aAAyB,KAAXvB,EACdwB,cAAe,OAEpB,IAEH,IAAM+H,EAmDV,SAAwBvF,GACpB,IAAMwF,EAAW,IAAIC,IADiB,uBAEtC,YAAmBzF,EAAQ0F,cAA3B,+CAA0C,CAAC,IAAhCC,EAA+B,QAChC5B,EAAQC,EAAgB2B,EAAM3F,GADE,uBAEtC,YAAmB+D,EAAnB,+CAA0B,CAAC,IAAhB6B,EAAe,QAClBC,EAAYL,EAASM,IAAIF,QACXjH,IAAdkH,IACAA,EAAY,GACZL,EAASO,IAAIH,EAAMC,IAGvBA,EAAUpD,KAAKkD,IATmB,oFAFJ,kFAetC,IAAMK,EAAkB,IAAIP,IAfU,uBAgBtC,YAA4BD,EAA5B,+CAAsC,CAAC,IAAD,6BAA1BI,EAA0B,KAApBK,EAAoB,KACb,IAAjBA,EAAMtF,QACNqF,EAAgBD,IAAIH,EAAMK,EAAM,KAlBF,kFAsBtC,OAAOD,EAzEaE,CAAelG,GA8CnC,OA3CA9B,qBAAU,WACN,QAAuBS,IAAnBqD,EAAJ,CAIA,IAAMC,EAAY,SAACrD,GACf,IAAMsD,EAAQtD,EAAEuD,QAAUnG,EACpBoG,EAAQxD,EAAEyD,QAAUrG,EAEpB+G,EAAO/C,EAAQgD,UAAUd,EAAOE,GACtC,QAAazD,IAAToE,EAAJ,CAIA,IAAM4C,EAAOJ,EAAYO,IAAI/C,GAC7B,QAAapE,IAATgH,EAAJ,CAKA,IAAMQ,EAAQnG,EAAQ6D,MAAMuC,QAAQT,GAEhC3F,EAAQ6D,OADG,IAAXsC,EACA,sBACOnG,EAAQ6D,MAAMwC,MAAM,EAAGF,IAD9B,YAEOnG,EAAQ6D,MAAMwC,MAAMF,EAAQ,KAInC,sBACOnG,EAAQ6D,OADf,CAEI8B,IAGRvF,OAKJ,OAFA4B,EAAeqB,iBAAiB,QAASpB,GAElC,WACHD,EAAesB,oBAAoB,QAASrB,OAEjD,CAACD,EAAgBhC,EAASA,EAAQ6D,MAAO0B,EAAanF,EAAQpE,IAE1D,uBAAK6B,UAAU,iBAAf,sD,SC9DNwH,O,yBAAAA,I,mBAAAA,I,2BAAAA,I,8BAAAA,M,KAOE,ICDFiB,EDCQC,EAAoC,SAAA7I,GAAU,IAGnD8I,EAHkD,EAC9BC,mBAASpB,EAAWqB,WADU,mBAC/CC,EAD+C,KACzCC,EADyC,KAKtD,OAAQD,GACJ,KAAKtB,EAAWqB,UACZF,EAAU,gBAAC,EAAD,CACNxK,SAAU0B,EAAM1B,SAChBgE,QAAStC,EAAMsC,QACfgC,eAAgBtE,EAAMsE,eACtB7D,kBAAmBT,EAAMS,kBACzBiC,OAAQ,kBAAM1C,EAAMmJ,WAAN,CAAkB7L,EAAgBE,aAAlC,mBAAkDD,EAASoL,MAAM,SAEnF,MACJ,KAAKhB,EAAWyB,OACZN,EAAU,gBAAC,EAAD,CACNxK,SAAU0B,EAAM1B,SAChBgE,QAAStC,EAAMsC,QACfgC,eAAgBtE,EAAMsE,eACtB7D,kBAAmBT,EAAMS,kBACzBiC,OAAQ,kBAAM1C,EAAMmJ,WAAN,CAAkB7L,EAAgBE,aAAlC,mBAAkDD,EAASoL,MAAM,SAEnF,MACJ,KAAKhB,EAAW0B,WACZP,EAAU,gBAAC,EAAD,CACNxK,SAAU0B,EAAM1B,SAChBgE,QAAStC,EAAMsC,QACfgC,eAAgBtE,EAAMsE,eACtB7D,kBAAmBT,EAAMS,kBACzBiC,OAAQ,kBAAM1C,EAAMmJ,WAAN,CAAkB7L,EAAgBE,aAAlC,mBAAkDD,EAASoL,MAAM,SAEnF,MACJ,KAAKhB,EAAWC,YACZkB,EAAU,gBAAC,EAAD,CACNxK,SAAU0B,EAAM1B,SAChBgE,QAAStC,EAAMsC,QACfgC,eAAgBtE,EAAMsE,eACtB7D,kBAAmBT,EAAMS,kBACzBiC,OAAQ,kBAAM1C,EAAMmJ,WAAN,CAAkB7L,EAAgBE,YAAaF,EAAgBI,gBAA/D,mBAAkFH,EAASoL,MAAM,SAK3H,OAAO,uBAAKxI,UAAU,8BAClB,0BAAQA,UAAU,kCAAkCC,QAASJ,EAAMiC,QAAnE,WAEA,sBAAI9B,UAAU,gBACV,sBAAIA,UAAW8I,IAAStB,EAAWqB,UAAY,wCAA0C,iBAAkB5I,QAAS,kBAAM8I,EAAQvB,EAAWqB,aAA7I,sBACA,sBAAI7I,UAAW8I,IAAStB,EAAWyB,OAAS,wCAA0C,iBAAkBhJ,QAAS,kBAAM8I,EAAQvB,EAAWyB,UAA1I,kBACA,sBAAIjJ,UAAW8I,IAAStB,EAAW0B,WAAa,wCAA0C,iBAAkBjJ,QAAS,kBAAM8I,EAAQvB,EAAW0B,cAA9I,uBACA,sBAAIlJ,UAAW8I,IAAStB,EAAWC,YAAc,wCAA0C,iBAAkBxH,QAAS,kBAAM8I,EAAQvB,EAAWC,eAA/I,qBAGHkB,K,SCvDJF,O,eAAAA,I,eAAAA,I,qBAAAA,I,sBAAAA,M,KAOE,IAAMU,EAAiC,SAAAtJ,GAAU,IAAD,EACb+I,mBAASH,EAASW,MADL,mBAC5CC,EAD4C,KAC/BC,EAD+B,KAG7CC,EAAe1I,mBAAQ,kBAAM,kBAAMyI,EAAeb,EAASW,SAAO,IAClEI,EAAe3I,mBAAQ,kBAAM,kBAAMyI,EAAeb,EAASgB,SAAO,IAClEC,EAAkB7I,mBAAQ,kBAAM,kBAAMyI,EAAeb,EAASC,YAAU,IACxEiB,EAAkB9I,mBAAQ,kBAAM,kBAAMyI,EAAeb,EAASmB,YAAU,IAEtEZ,EAAenJ,EAAfmJ,WAEF5I,EAAUS,mBAAQ,kBAAO,kBAAMmI,GAAW,EAAD,CAAQ7L,EAAgBE,aAAxB,mBAAwCD,EAASoL,MAAM,SAAO,CAACQ,IAE9G,OAAQK,GACJ,KAAKZ,EAASgB,KACV,OACI,gBAAC,EAAD,CACI3H,OAAQyH,EACRpH,QAAStC,EAAMsC,QACfJ,mBAAoBlC,EAAMkC,mBAC1BO,sBAAuBzC,EAAMyC,sBAC7BnE,SAAU0B,EAAM1B,SAChBmC,kBAAmBT,EAAMS,kBACzBiC,OAAQ,kBAAM1C,EAAMmJ,YAAW,EAAjB,CAAyB7L,EAAgBE,aAAzC,mBAAyDD,EAASoL,MAAM,SAGlG,KAAKC,EAASC,QACV,OACI,gBAAC,EAAD,CACI5G,OAAQyH,EACRpH,QAAStC,EAAMsC,QACfgC,eAAgBtE,EAAMgK,OACtB1L,SAAU0B,EAAM1B,SAChBmC,kBAAmBT,EAAMS,kBACzB0I,WAAY,SAAAc,GAAK,OAAIjK,EAAMmJ,YAAW,EAAOc,MAMzD,QACI,OACI,gBAAC,EAAD,CACI/J,aAAcF,EAAME,aACpBO,kBAAmBT,EAAMS,kBACzBnC,SAAU0B,EAAM1B,SAChB+B,SAAUL,EAAMK,SAChBE,QAASA,EACT2J,KAAMlK,EAAMkK,KACZC,OAAQnK,EAAMmK,OAEdzJ,SAAUiJ,EACVhJ,YAAakJ,EACbO,YAAaN,MC5EpBO,EAAb,YAKI,WAAYrK,GAAoB,IAAD,8BAC3B,4CAAMA,KALHsK,SAIwB,IAHvBC,UAGuB,IAFxBP,YAEwB,EAG3B,EAAKQ,MAAQ,CACTC,WAAuBxJ,IAAhBjB,EAAMyK,MAAsB,EAAIzK,EAAMyK,MAC7CC,YAAyBzJ,IAAjBjB,EAAM0K,OAAuB,EAAI1K,EAAM0K,QALxB,EALnC,sEAcc,IAAD,OACL,OACI,uBAAKvK,UAAW2C,KAAK9C,MAAMG,UAAWwK,IAAK,SAAA3F,GAAC,OAAI,EAAKuF,KAAa,OAANvF,EAAa,EAAKuF,KAAOvF,IACjF,0BACIyF,MAAO3H,KAAK9C,MAAMyK,MAClBC,OAAQ5H,KAAK9C,MAAM0K,OACnBC,IAAK,SAAArH,GAAC,OAAI,EAAK0G,OAAe,OAAN1G,EAAa,EAAK0G,OAAS1G,QApBvE,0CA2BQR,KAAK8H,cA3Bb,yCA8BuBC,EAAuBC,GACtChI,KAAK8H,cA/Bb,kCAmCQ,QAAoB3J,IAAhB6B,KAAKkH,OAAT,CAIA,IAAMM,EAAMxH,KAAKkH,OAAOe,WAAW,MAEvB,OAART,IACAxH,KAAKwH,IAAMA,QA1CvB,GAAiCU,aCDpBC,GD0DyBD,YC1DtC,iDACIzI,MAAkB,GADtB,KAEI4D,MAAmB,GAFvB,KAGI+E,eAA6B,GAHjC,KAIIlD,cAA2B,GAJ/B,KAKImD,aAA0B,GAL9B,KAMIC,2BAAwC,GAN5C,KAOIC,qBAAkC,GAPtC,KASIZ,MAAgB,EATpB,KAUIC,OAAiB,EAVrB,KAYIrE,MAAgB,GAZpB,KAaIU,mBAA+B,GAbnC,KAcIuE,MAAiB,GAdrB,sDAgBqB9I,EAAWI,GACxB,IAAM2I,EAAMzI,KAAKiE,mBAAmBrD,KAAKmB,MAAMrC,IAE/C,QAAYvB,IAARsK,EAIJ,OAAOA,EAAI7H,KAAKmB,MAAMjC,QAvB9B,M,MCAO,SAAS4I,EACZlJ,EACAgI,EACArE,GAoBA,GAlBAqE,EAAImB,UAAU,EAAG,EAAGnJ,EAAQmI,MAAQxE,EAAS3H,SAAUgE,EAAQoI,OAASzE,EAAS3H,UAE7E2H,EAAStH,UA0CjB,SAAsB2L,EAA+BhI,EAAkB2D,GACnEqE,EAAIoB,UAAYzF,EAASzG,eADqE,2BAG9F,YAAmB8C,EAAQ+D,MAA3B,+CAAkC,CAC9BsF,EAD8B,QACfrB,EAAKrE,IAJsE,mFAzC1F2F,CAAatB,EAAKhI,EAAS2D,GAG3BA,EAASxH,WAAa,GAiF9B,SAAmB6L,EAA+BhI,EAAkB2D,GAChEqE,EAAIuB,YAAc5F,EAASxH,WAC3B6L,EAAIwB,YAAc,OAElBxB,EAAIoB,UAAYzF,EAAStG,qBAJkE,2BAK3F,YAAiB2C,EAAQ+I,qBAAzB,+CAA+C,CAC3CU,EAD2C,QAC5BzB,EAAKrE,IANmE,kFAS3FqE,EAAIoB,UAAYzF,EAASrG,2BATkE,2BAU3F,YAAiB0C,EAAQ8I,2BAAzB,+CAAqD,CACjDW,EADiD,QAClCzB,EAAKrE,IAXmE,kFAc3FqE,EAAIoB,UAAYzF,EAASpG,aAdkE,2BAe3F,YAAiByC,EAAQ6I,aAAzB,+CAAuC,CACnCY,EADmC,QACpBzB,EAAKrE,IAhBmE,kFAmB3FqE,EAAIoB,UAAYzF,EAASnG,cAnBkE,2BAoB3F,YAAiBwC,EAAQ0F,cAAzB,+CAAwC,CACpC+D,EADoC,QACrBzB,EAAKrE,IArBmE,kFAwB3FqE,EAAIuB,YAAc,EAxGdG,CAAU1B,EAAKhI,EAAS2D,GAGxBA,EAASnH,aA4JjB,SAAqBwL,EAA+BhI,EAAkB2D,GAClEqE,EAAI2B,UAAYhG,EAAS7G,gBAEzBkL,EAAI4B,OACJC,EAAY7B,EAAKhI,EAAS2D,GAE1BqE,EAAI8B,SAAS,EAAG,EAAG9J,EAAQmI,MAAQxE,EAAS3H,SAAUgE,EAAQoI,OAASzE,EAAS3H,UAEhFgM,EAAIwB,YAAc7F,EAAS5G,cAC3BiL,EAAIoB,UAAYzF,EAASxG,cAEzB,IAAM4M,EAA6B,GAApBpG,EAAS3H,SAXqE,uBAY7F,YAAoBgE,EAAQ4I,eAA5B,+CAA4C,CAAC,IAAlCoB,EAAiC,QAClCC,EAAStG,EAAS3H,SAAWgO,EAAME,YAEzClC,EAAI4B,OAEJ5B,EAAImC,UAAUH,EAAM9J,EAAIyD,EAAS3H,SAAUgO,EAAM1J,EAAIqD,EAAS3H,UAC9DgM,EAAIoC,OAAOJ,EAAMK,UAGjBrC,EAAIsC,YACJtC,EAAIuC,QAAQR,GAASE,EAASD,EAAMQ,QAAU7G,EAAS3H,UACvDgM,EAAIyC,OAAOV,GAASE,EAASD,EAAMQ,QAAU7G,EAAS3H,UACtDgM,EAAIyC,OAAOV,EAAQE,EAASD,EAAMU,WAAa/G,EAAS3H,UACxDgM,EAAIyC,QAAQV,EAAQE,EAASD,EAAMU,WAAa/G,EAAS3H,UACzDgM,EAAI2C,OAGJ3C,EAAIsC,YAEJtC,EAAIuC,QAAQR,GAASE,EAASD,EAAMQ,QAAU7G,EAAS3H,UACvDgM,EAAIyC,QAAQV,EAAQE,EAASD,EAAMU,WAAa/G,EAAS3H,UAEzDgM,EAAIuC,OAAO,GAAIN,GACfjC,EAAIyC,OAAO,EAAGR,GAEdjC,EAAIuC,OAAOR,GAASE,EAASD,EAAMQ,QAAU7G,EAAS3H,UACtDgM,EAAIyC,OAAOV,EAAQE,EAASD,EAAMU,WAAa/G,EAAS3H,UAExDgM,EAAI4C,SAEJ5C,EAAI6C,WA1CqF,kFA6C7F7C,EAAI6C,UAxMAC,CAAY9C,EAAKhI,EAAS2D,GAG1BA,EAASlH,mBAwMjB,SAA2BuL,EAA+BhI,EAAkB2D,GACxEqE,EAAI4B,OACJC,EAAY7B,EAAKhI,EAAS2D,GAE1BqE,EAAIuB,YAAc,IAClBvB,EAAI2B,UAAY,OALmF,2BAOnG,YAAoB3J,EAAQ4I,eAA5B,+CAA4C,CAAC,IAAlCoB,EAAiC,QACxChC,EAAIsC,YACJtC,EAAI+C,IAAIf,EAAM9J,EAAIyD,EAAS3H,SAAUgO,EAAM1J,EAAIqD,EAAS3H,SAA8B,IAApB2H,EAAS3H,SAAiB,EAAa,EAAVoF,KAAK4J,IACpGhD,EAAI2C,QAV2F,kFAanG3C,EAAI6C,UApNApO,CAAkBuL,EAAKhI,EAAS2D,GAGhCA,EAASrH,UAAW,CACpB0L,EAAIwB,YAAcxB,EAAI2B,UAAYhG,EAASpH,oBAAsB,OAAS,OAC1EyL,EAAIiD,QAAU,QAFM,2BAGpB,YAAoBjL,EAAQgJ,MAA5B,+CAAmC,CAC/BkC,EAD+B,QACdlD,EAAKrE,IAJN,kFAMpBqE,EAAIiD,QAAU,OAGlB,GAAItH,EAASvH,cAAe,CACxB4L,EAAIoB,UAAYzF,EAAS9G,UACzBmL,EAAIwB,YAAc7F,EAAS/G,UAFH,2BAGxB,YAAiBoD,EAAQ6D,MAAzB,+CAAgC,CAC5B4F,EAD4B,QACbzB,EAAKrE,IAJA,mFAQ5B,GAAIA,EAAS1H,UAAY,EAAG,CACxB+L,EAAIuB,YAAc5F,EAAS1H,UAC3B,IAAK,IAAIkP,EAAI,EAAGA,EAAInL,EAAQC,MAAMU,OAAQwK,IACtCC,EAASpL,EAAQC,MAAMkL,GAAInD,EAAKrE,GAEpCqE,EAAIuB,YAAc,GAY1B,SAASE,EAAS4B,EAAkBrD,EAA+BrE,GAC/DqE,EAAIsC,YACJtC,EAAIuC,OAAOc,EAAQlH,KAAKjE,EAAIyD,EAAS3H,SAAUqP,EAAQlH,KAAK7D,EAAIqD,EAAS3H,UACzEgM,EAAIyC,OAAOY,EAAQhH,GAAGnE,EAAIyD,EAAS3H,SAAUqP,EAAQhH,GAAG/D,EAAIqD,EAAS3H,UACrEgM,EAAI4C,SAGR,SAASQ,EAASE,EAActD,EAA+BrE,GAC3DqE,EAAI2B,UAAY,OAEhB3B,EAAIsC,YACJtC,EAAI+C,IAAIO,EAAKpL,EAAIyD,EAAS3H,SAAUsP,EAAKhL,EAAIqD,EAAS3H,SAAU2H,EAAS3H,SAAWsP,EAAK1J,OAAQ,EAAG,EAAIR,KAAK4J,IAC7GhD,EAAI2C,OAGR,SAAStB,EAASzD,EAAYoC,EAA+BrE,IACrDiC,EAAK3B,SAAa2B,EAAK2F,SAAU5H,EAASvG,iBAMrCwI,EAAK2F,SACVvD,EAAI2B,UAAY,OAChB3B,EAAI8B,SAASlE,EAAK1F,EAAIyD,EAAS3H,SAAU4J,EAAKtF,EAAIqD,EAAS3H,SAAU2H,EAAS3H,SAAU2H,EAAS3H,YAPjGgM,EAAI2B,UAAYhG,EAASjH,WACzBsL,EAAI8B,SAASlE,EAAK1F,EAAIyD,EAAS3H,SAAU4J,EAAKtF,EAAIqD,EAAS3H,SAAU2H,EAAS3H,SAAU2H,EAAS3H,UACjGgM,EAAIwB,YAAc7F,EAAShH,eAC3BqL,EAAIwD,WAAW5F,EAAK1F,EAAIyD,EAAS3H,SAAU4J,EAAKtF,EAAIqD,EAAS3H,SAAU2H,EAAS3H,SAAU2H,EAAS3H,WAOnG2H,EAASzH,YAAc,GAAqB,OAAhB0J,EAAK3C,SACjC+E,EAAIuB,YAAc5F,EAASzH,YAC3B8L,EAAI2B,UAAY/D,EAAK3C,OAAOvB,MAC5BsG,EAAI8B,SAASlE,EAAK1F,EAAIyD,EAAS3H,SAAU4J,EAAKtF,EAAIqD,EAAS3H,SAAU2H,EAAS3H,SAAU2H,EAAS3H,UACjGgM,EAAIuB,YAAc,GA+B1B,SAAS2B,EACLO,EACAzD,EACArE,GAED,IADC+H,IACF,yDACMC,EAAehI,EAAS3H,SAAW,EAEvC,GAA+B,IAA3ByP,EAAMG,UAAUjL,OAApB,CAcA,IAAIkL,EAASJ,EAAMK,aACf5L,EAAI2L,EAAO,GAAKlI,EAAS3H,SAAW2P,EACpCrL,EAAIuL,EAAO,GAAKlI,EAAS3H,SAAW2P,EAEpCD,GACA1D,EAAIsC,YAERtC,EAAIuC,OAAOrK,EAAGI,GAEd0H,EAAIoB,UAAYzF,EAAS1G,UACzB,IAAK,IAAIkO,EAAI,EAAGA,EAAIU,EAAOlL,OAAQwK,GAAK,EACpCjL,EAAI2L,EAAOV,GAAKxH,EAAS3H,SAAW2P,EACpCrL,EAAIuL,EAAOV,EAAI,GAAKxH,EAAS3H,SAAW2P,EACxC3D,EAAIyC,OAAOvK,EAAGI,GAGdoL,GACA1D,EAAI4C,cA9BJ,GAAIc,EAAM,CACN,IAAI3I,EAAO0I,EAAMG,UAAU,GACvBG,EAAKhJ,EAAK7C,EAAIyD,EAAS3H,SAAW2P,EAClCK,EAAKjJ,EAAKzC,EAAIqD,EAAS3H,SAAW2P,EAEtC3D,EAAIsC,YACJtC,EAAI+C,IAAIgB,EAAIC,EAAIrI,EAAS1G,UAAY,EAAG,EAAa,EAAVmE,KAAK4J,IAEhDhD,EAAI2C,QA0BhB,SAASd,EAAY7B,EAA+BhI,EAAkB2D,GAClEqE,EAAIsC,YACJtC,EAAIiE,KAAK,EAAG,EAAGjM,EAAQmI,MAAQxE,EAAS3H,SAAUgE,EAAQoI,OAASzE,EAAS3H,UAFiB,2BAG7F,YAAkBgE,EAAQgJ,MAA1B,+CAAiC,CAC7BkC,EAD6B,QACZlD,EAAKrE,GAAU,IAJyD,kFAM7FqE,EAAIkE,KAAK,WC7KN,IAAMC,EAAb,WAMI,WAA4B3K,GAAwB,yBAAxBA,OAAuB,KAL3CR,OAK2C,OAJ3CoL,QAI2C,OAH3CC,QAG2C,OAF3CC,QAE2C,EAC/C,IAAIC,EAAO/L,KAAK+L,OAEhB/L,KAAKQ,EAAI,EACTR,KAAK4L,GAAKG,EAAK,KACf/L,KAAK6L,GAAKE,EAAK,KACf/L,KAAK8L,GAAKC,EAAK,KAEf/L,KAAK4L,IAAMG,EAAK/K,GACZhB,KAAK4L,GAAK,IACV5L,KAAK4L,IAAM,GAGf5L,KAAK6L,IAAME,EAAK/K,GACZhB,KAAK6L,GAAK,IACV7L,KAAK6L,IAAM,GAGf7L,KAAK8L,IAAMC,EAAK/K,GACZhB,KAAK8L,GAAK,IACV9L,KAAK8L,IAAM,GA1BvB,mDA+BQ,IAAIE,EAAI,QAAUhM,KAAK4L,GAAc,uBAAT5L,KAAKQ,EAGjC,OAFAR,KAAK4L,GAAK5L,KAAK6L,GACf7L,KAAK6L,GAAK7L,KAAK8L,GACR9L,KAAK8L,GAAKE,GAAKhM,KAAKQ,EAAQ,EAAJwL,KAlCvC,kCAsCQ,OAAsB,WAAdhM,KAAKiM,OAAwB,IAtC7C,kCAyCgBtN,EAAaC,GACrB,OAAOD,EAAMqB,KAAKiM,QAAUrN,EAAMD,KA1C1C,qCA6CmBuN,EAAsBC,GACjC,OAAOvL,KAAKmB,MAAM/B,KAAKoM,YAAYF,EAAcC,MA9CzD,kCAkDQ,IAAM7K,EAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC5CY,EAAIZ,EAAWtB,KAAKqM,eAAe,EAAG/K,EAAWnB,SACjDgC,EAAIb,EAAWtB,KAAKqM,eAAe,EAAG/K,EAAWnB,SACjDI,EAAIe,EAAWtB,KAAKqM,eAAe,EAAG/K,EAAWnB,SACvD,MAAM,IAAN,OAAW+B,GAAX,OAAeC,GAAf,OAAmB5B,KAtD3B,6BA0DQ,IAAIqC,EAAI,WAEJmJ,EAAO,SAASO,GAChBA,EAAOA,EAAKC,WACZ,IAAK,IAAI5B,EAAI,EAAGA,EAAI2B,EAAKnM,OAAQwK,IAAK,CAElC,IAAI6B,EAAI,oBADR5J,GAAK0J,EAAKG,WAAW9B,IAGrB6B,GADA5J,EAAI4J,IAAM,EAGV5J,GADA4J,GAAK5J,KACK,EAEVA,GAAS,YADT4J,GAAK5J,GAGT,OAAmB,wBAAXA,IAAM,IAGlB,OAAOmJ,MA3Ef,KCOO,SAAeW,EAAtB,yC,8CAAO,WACHlN,EACA2D,EACAnC,EACAoC,GAJG,mBAAA3C,EAAA,sDAOGqB,EAAS,IAAI6J,EAAQ3K,GAEvB2L,EAAW,WACX,IAAMjN,EAAIoC,EAAOsK,YAAY,EAAG5M,EAAQmI,MAAQ,GAC1C7H,EAAIgC,EAAOsK,YAAY,EAAG5M,EAAQoI,OAAS,GAC3CgF,EAAY9K,EAAOsK,YAAY,GAAK,KACpCnL,EAAaa,EAAOuK,eAAe,EAAGpN,EAAW+C,YACjDhB,EAAOc,EAAOmK,OACd/K,EAAQY,EAAO+K,YACrB,OAAO,IAAI/L,EAAOtB,EAASE,EAAGI,EAAGkB,EAAMC,EAAYC,EAAO0L,IAG9DpN,EAAQC,MAAQ,GACPkL,EAAI,EApBV,YAoBaA,EAAIxH,EAAS2J,WApB1B,oBAqBCC,GAAcvN,EAASmN,EAAUnN,EAAQmI,MAAOnI,EAAQoI,SAEpDxE,EAvBL,gCAwBWA,EAAgB4J,GAAUC,OAxBrC,OAoBqCtC,IApBrC,4D,sBA6BP,SAASoC,GACLvN,EACAmN,EACAO,EACAC,GAEA,IAAMC,EAAkB,SAACC,EAAWC,EAAW3F,EAAeC,GAC1D,IAAI2F,GAAYF,EAAG3N,EAAI4N,EAAG5N,GAAKiI,EAC3B6F,GAAYH,EAAGvN,EAAIwN,EAAGxN,GAAK8H,EAC/B,OAAO2F,EAAWA,EAAWC,EAAWA,GAIxCC,EAAQd,IAAYe,EAAQf,IAC5BgB,EAAeC,OAAOC,UAAWC,EAAeF,OAAOC,UAT7D,uBAUE,YAAiBrO,EAAQC,MAAzB,+CAAgC,CAAC,IAAxBiD,EAAuB,QAE5BiL,EAAe/M,KAAKjC,IAAIgP,EAAcP,EAAgBK,EAAO/K,EAAMwK,EAAUC,IAC7EW,EAAelN,KAAKjC,IAAImP,EAAcV,EAAgBM,EAAOhL,EAAMwK,EAAUC,KAbnF,kFAgBE3N,EAAQC,MAAMwC,KAAK0L,EAAeG,EAAeJ,EAAQD,GCzDtD,ICCMM,GAAb,YAII,WAAYC,GAAkC,IAAD,uBACzC,4CAAMA,KAJVC,kBAG6C,IAF7CC,oBAE6C,EAGzC,IAAIC,EAAeH,EAAS,GAAGG,aAAaH,EAAS,GAAIA,EAAS,IAHzB,OAKzC,EAAKC,aAAeE,EAAa,GACjC,EAAKD,eAAiBC,EAAa,GANM,EAJjD,4BDAI,WAAqBH,GAAoB,yBAApBA,cEAlB,SAASI,GACZ3O,EACA4O,GAEA,GAAI5O,EAAMU,OAAS,EACf,MAAO,GAIX,IAAImO,EAAmC,GACvCA,EAAcrM,KAAK,IAAI8L,GAASM,IAPlC,2BASE,YAAiB5O,EAAjB,+CAAwB,CAAC,IAAhBiD,EAAe,QAEhB6L,EAAkC,GAFlB,uBAGpB,YAAqBD,EAArB,+CAAoC,CAAC,IAA5BE,EAA2B,QAC5BC,GAAmB/L,EAAM8L,IACzBD,EAAatM,KAAKuM,IALN,kFAapB,IADA,IAAIE,EAAmB,GACvB,MAAqBH,EAArB,eACI,IADC,IAAIC,EAAQ,KACJ7D,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAIgE,EAAWH,EAASR,SAASrD,GAC7BiE,EAASJ,EAASR,SAAe,IAANrD,EAAU,EAAIA,EAAI,GAE7CkE,GAAkB,EAJE,uBAKxB,YAAkBN,EAAlB,+CAAgC,CAAC,IAAxBrO,EAAuB,QAC5B,GAAIA,IAAUsO,KAI4B,IAAtCtO,EAAM8N,SAASpI,QAAQ+I,KAIa,IAApCzO,EAAM8N,SAASpI,QAAQgJ,IAA3B,CAIAC,GAAkB,EAClB,QAnBoB,kFAsBnBA,GACDH,EAAQzM,KAAK0M,EAAUC,GAMnC,cAAqBL,EAArB,eAAmC,CAA9B,IAAIC,EAAQ,KACbF,EAAcQ,OAAOR,EAAc1I,QAAQ4I,GAAW,GAI1D,IAAK,IAAI7D,EAAI,EAAGA,EAAI+D,EAAQvO,OAAS,EAAGwK,GAAK,EAAG,CAC5C,IAAI6D,EAAW,IAAIT,GAAgB,CAACW,EAAQ/D,GAAI+D,EAAQ/D,EAAI,GAAIjI,IAChE4L,EAAcrM,KAAKuM,KA3D7B,kFAgEE,IAAK,IAAI7D,EAAI,EAAGA,EAAI2D,EAAcnO,OAAQwK,IAAK,CAC3C,IAAI6D,EAAWF,EAAc3D,GADc,uBAE3C,YAAmB6D,EAASR,SAA5B,+CAAsC,CAAC,IAA9Be,EAA6B,QAClC,IAAuC,IAAnCV,EAAczI,QAAQmJ,GAAgB,CACtCT,EAAcQ,OAAOnE,EAAG,GACxBA,IACA,QANmC,mFAW/C,OAAO2D,EAGX,SAASG,GACLjF,EACAgF,GAGA,OADahF,EAAMwF,aAAaR,EAASP,eACxBO,EAASN,eCrFvB,SAASe,GACZC,GAED,IADC7N,EACF,uDADmB6N,EAAM7L,MAEnB8L,EAAsB,GAD5B,uBAGE,YAAiB9N,EAAjB,+CAAwB,CAAC,IAAhBiC,EAAe,QAChB8L,GAAc,EACdzO,EAAS2C,EAAKK,KAAK0L,UAAU/L,EAAKO,IAClCyL,EAAWhM,EAAKK,KAAKqL,aAAarO,GAHlB,uBAKpB,YAAiBuO,EAAMzP,MAAvB,+CAA8B,CAAC,IAAtBiD,EAAqB,QAC1B,GAAIA,IAASY,EAAKK,MAAQjB,IAASY,EAAKO,IAIpCnB,EAAKsM,aAAarO,GAAU2O,EAAU,CACtCF,GAAc,EACd,QAZY,kFAgBfA,GACDD,EAAWlN,KAAKqB,IApB1B,kFAwBE,OAAO6L,EC3BJ,SAASI,GAEZC,EACAC,GAEA,IAAMzK,EAAoB,GAD5B,uBAIE,YAAsBwK,EAAtB,+CACI,IAD6B,IAAtBd,EAAqB,mBACnB/D,GACL,IAAM+E,EAAKhB,EAAQV,SAAe,IAANrD,EAAU+D,EAAQV,SAAS7N,OAAS,EAAIwK,EAAI,GAClEgF,EAAKjB,EAAQV,SAASrD,GAER3F,EAAS4K,MAAK,SAAAC,GAAC,OAAKA,EAAElM,OAAS+L,GAAMG,EAAEhM,KAAO8L,GAAQE,EAAElM,OAASgM,GAAME,EAAEhM,KAAO6L,MAEhG1K,EAAS/C,KAAKwN,EAAWC,EAAIC,KAN5BhF,EAAI,EAAGA,EAAI+D,EAAQV,SAAS7N,OAAQwK,IAAM,EAA1CA,GALf,kFAgBE,OAAO3F,ECpBJ,SAAS8K,GACZZ,GAED,IADC7N,EACF,uDADmB6N,EAAM7L,MAEnB0M,EAAiBb,EAAMzP,MAAMoG,QAC7BmK,EAAYD,EAAeE,MAC/B,QAAkB9R,IAAd6R,EACA,MAAO,GAGX,IAAIE,EAAgB7O,EAAM8O,KAAI,SAAAN,GAAC,MAAK,CAAEvM,KAAMuM,EAAGO,SAAUP,EAAElM,KAAKqL,aAAaa,EAAEhM,QAC/EqM,EAAcG,MAAK,SAAC5P,EAAGF,GAAJ,OAAUE,EAAE2P,SAAW7P,EAAE6P,YAK5C,IAHA,IAAIE,EAAwB,CAACN,GACzBb,EAAsB,GAEnBY,EAAe5P,OAAS,GAAK+P,EAAc/P,OAAS,GAGvD,IAAK,IAAIwK,EAAI,EAAGA,EAAIuF,EAAc/P,OAAQwK,IAAK,CAC3C,IAAI4F,EAAWL,EAAcvF,GAAGrH,KAE5BkN,GAA0D,IAAzCF,EAAa1K,QAAQ2K,EAAS5M,MAC/C8M,GAAsD,IAAvCH,EAAa1K,QAAQ2K,EAAS1M,IAGjD,GAAK2M,GAAmBC,EAAxB,CAIAP,EAAcpB,OAAOnE,EAAG,GACxBwE,EAAWlN,KAAKsO,GAKhB,IAHA,IAAIG,EAAaF,EAAiBD,EAAS1M,GAAK0M,EAAS5M,KAGhDgN,EAAIhG,EAAGgG,EAAIT,EAAc/P,OAAQwQ,MACtCJ,EAAWL,EAAcS,GAAGrN,MACdK,OAAS+M,IAAqD,IAAvCJ,EAAa1K,QAAQ2K,EAAS1M,KAC/D0M,EAAS1M,KAAO6M,IAAuD,IAAzCJ,EAAa1K,QAAQ2K,EAAS5M,SAC5DuM,EAAcpB,OAAO6B,EAAG,GACxBA,KAIRL,EAAarO,KAAKyO,GAClB,OAIR,OAAOvB,EClDJ,SAASyB,GACZ1B,GAED,IADC7N,EACF,uDADmB6N,EAAM7L,MAEnB8L,EAAsB,GAD5B,uBAGE,YAAiB9N,EAAjB,+CAAwB,CAAC,IAAhBiC,EAAe,QAChB8L,GAAc,EACdgB,EAAW9M,EAAKK,KAAKqL,aAAa1L,EAAKO,IAFvB,uBAIpB,YAAiBqL,EAAMzP,MAAvB,+CAA8B,CAAC,IAAtBiD,EAAqB,QAC1B,GAAIA,IAASY,EAAKK,MAAQjB,IAASY,EAAKO,KAIpCnB,EAAKsM,aAAa1L,EAAKK,MAAQyM,GAAY1N,EAAKsM,aAAa1L,EAAKO,IAAMuM,GAAU,CAClFhB,GAAc,EACd,QAXY,kFAefA,GACDD,EAAWlN,KAAKqB,IAnB1B,kFAuBE,OAAO6L,E,aC3BE0B,GAAb,YACI,WAAYlN,EAAcE,GAAa,IAAD,6BAClC,4CAAMF,EAAME,IAEZF,EAAKtC,MAAMY,KAAX,iBACA4B,EAAGxC,MAAMY,KAAT,iBAJkC,EAD1C,4BCAI,WAAmB0B,EAAqBE,GAAa,yBAAlCF,OAAiC,KAAZE,QCUrC,SAAeiN,GAAtB,yC,8CAAO,WACHtR,EACA2D,EACAnC,EACAoC,GAJG,iBAAA3C,EAAA,yDAMHjB,EAAQ6D,MAAQ,GAChB7D,EAAQ0F,cAAgB,GACxB1F,EAAQ6I,aAAe,GACvB7I,EAAQ8I,2BAA6B,GACrC9I,EAAQ+I,qBAAuB,GAEzBwI,EAA8C,CAChD,IAAIjQ,EAAOtB,EAAS,EAAG,EAAG,EAAGP,EAAW+R,WAAY,IACpD,IAAIlQ,EAAOtB,EAAS,OAAQ,EAAG,EAAGP,EAAW+R,WAAY,IACzD,IAAIlQ,EAAOtB,EAAS,EAAG,OAAQ,EAAGP,EAAW+R,WAAY,KAGvDC,EAAoB7C,GAA6B5O,EAAQC,MAAOsR,GAEtEvR,EAAQ0F,cAAgBqK,GAAe0B,GAAmB,SAACtN,EAAME,GAAP,OAAc,IAAIgN,GAAQlN,EAAME,OAEtFT,EAtBD,kCAuBOA,EAAgB4J,GAAUkE,QAvBjC,WA0BH1R,EAAQ6I,aAAe4G,GAAoBzP,EAASA,EAAQ0F,gBAExD9B,EA5BD,kCA6BOA,EAAgB4J,GAAUkE,QA7BjC,WAgCH1R,EAAQ8I,2BAA6BsI,GAAkCpR,EAASA,EAAQ6I,eAEpFjF,EAlCD,kCAmCOA,EAAgB4J,GAAUkE,QAnCjC,QAsCH1R,EAAQ+I,qBAAuBuH,GAA2BtQ,EAASA,EAAQ8I,4BAtCxE,6C,sBCPA,SAAe6I,GAAtB,yC,8CAAO,WACH3R,EACA2D,EACAnC,EACAoC,GAJG,yBAAA3C,EAAA,sDA0BH,IAjBI0C,EAASiO,aAAe,IACxB5R,EAAQ6D,MAAQ7D,EAAQ+I,qBAAqB1C,QAE7CwL,EAAgB7R,EAAQ8I,2BAA2B3F,QAAO,SAAAkN,GAAC,OAAkC,IAA9BrQ,EAAQ6D,MAAMuC,QAAQiK,MAErFyB,EAAiBnO,EAASiO,aAAe,KAEzC5R,EAAQ6D,MAAQ7D,EAAQ8I,2BAA2BzC,QAEnDwL,EAAgB7R,EAAQ6I,aAAa1F,QAAO,SAAAkN,GAAC,OAAkC,IAA9BrQ,EAAQ6D,MAAMuC,QAAQiK,MAEvEyB,GAAkBnO,EAASiO,aAAe,IAAM,IAGhDtP,EAAS,IAAI6J,EAAQ3K,GACrBuQ,EAAc3Q,KAAK8D,MAAM2M,EAAclR,OAASmR,GAE3C3G,EAAI4G,EAAa5G,EAAI,EAAGA,IACzB6G,EAAeH,EAAcvC,OAAOhN,EAAOuK,eAAe,EAAGgF,EAAclR,QAAS,GAAG,GAC3FX,EAAQ6D,MAAMpB,KAAKuP,GA5BpB,4C,sBCAA,SAAeC,GAAtB,uC,8CAAO,WACHjS,EACAiD,EACAW,GAHG,mCAAA3C,EAAA,sDAaH,IARMqB,EAAS,IAAI6J,EAAQlJ,EAAOzB,MAE5B0Q,EAAclS,EAAQ+D,MAAMZ,QAAO,SAAAqJ,GAAC,OAAIA,EAAEvJ,SAAWA,KACrDkP,EAAeD,EAAY/O,QAAO,SAAAqJ,GAAC,OAA+B,IAA3BA,EAAE4F,cAAczR,SAAiB6L,EAAE4F,cAAchC,MAAK,SAAAnP,GAAC,OAAIA,EAAEgC,SAAWA,QAE/GoP,EAAeF,EAAahP,QAAO,SAAAqJ,GAAC,OAAKA,EAAEvI,WAV9C,4BAaH,EAAmBkO,EAAnB,+CAAWvM,EAAsB,QACzBtD,EAAOmK,OAAS,KAChB7G,EAAK3B,SAAU,GAfpB,yOAmBMkH,EAAI,EAnBV,aAmBaA,EAAI,GAnBjB,oBAoBCmH,GAAwBD,IAEpBzO,EAtBL,kCAuBWA,EAAgB4J,GAAUC,OAvBrC,QAmBoBtC,IAnBpB,wBA2BHoH,GAA4BvS,EAASiD,EAAQkP,GA3B1C,6E,sBA8BP,SAASG,GAAwBE,GAC7B,IAAMC,EAAU,IAAIhN,IADwB,uBAG5C,YAAmB+M,EAAnB,+CAA0B,CAAC,IAAhBzP,EAAe,QAIhB2P,EAAW3P,EAAKkB,QAChB0O,EAAoB5P,EAAKqP,cAAcjP,QAAO,SAAAqJ,GAAC,OAAIA,EAAEvI,WAAStD,OAE9DiS,EAAaF,EACbC,GAAqB,EACrBA,EAAoB,EAE1BF,EAAQ1M,IAAIhD,EAAM6P,IAdsB,6GAiB5C,YAA6BH,EAA7B,+CAAsC,CAAC,IAAD,6BAA1B1P,EAA0B,KAApB8P,EAAoB,KAClC9P,EAAKkB,QAAU4O,GAlByB,mFAsBhD,SAASN,GAA4BvS,EAAkBiD,EAAgBiP,GAMnE,IALA,IAAMY,EAAW9S,EAAQyE,mBAAmBrD,KAAKmB,MAAMU,EAAO/C,IAAIkB,KAAKmB,MAAMU,EAAO3C,IAE9EyS,EAAiB,IAAIC,IAAI,CAACF,IAC5BG,EAAW,YAAOH,EAASV,iBAElB,CACT,IAAMxM,EAAOqN,EAAYxC,MAEzB,QAAa9R,IAATiH,EACA,MAGCA,EAAK3B,SAAW2B,EAAK3C,SAAWA,IAAU8P,EAAeG,IAAItN,KAIlEmN,EAAeI,IAAIvN,GAEnBqN,EAAW,sBACJA,GADI,YAEJrN,EAAKwM,iBArBwE,2BAyBxF,YAAmBF,EAAnB,+CAAgC,CAAC,IAAtBtM,EAAqB,QACxBA,EAAK3B,UAAY8O,EAAeG,IAAItN,KACpCA,EAAK3B,SAAU,IA3BiE,mFCrDrF,SAAemP,GAAtB,uC,8CAAO,WACHpT,EACAiD,EACAW,GAHG,mCAAA3C,EAAA,sDAKGqB,EAAS,IAAI6J,EAAQlJ,EAAOzB,MAC5B6R,EAAQjS,KAAKmB,MAAMU,EAAO/C,GAC1BoT,EAAQlS,KAAKmB,MAAMU,EAAO3C,GAP7B,EASgCiT,GAAgBvT,EAASiD,EAAQoQ,EAAOC,EAAOhR,GAA1EkR,EATL,EASKA,KAAMC,EATX,EASWA,KAAMC,EATjB,EASiBA,KAAMC,EATvB,EASuBA,KAEjBzT,EAAIsT,EAXV,YAWgBtT,GAAKwT,GAXrB,iBAYUpT,EAAImT,EAZd,YAYoBnT,GAAKqT,GAZzB,qBAaS/N,EAAO5F,EAAQyE,mBAAmBvE,GAAGI,IAChC2C,SAAWA,EAdzB,wDAkBK2C,EAAK3B,SAAU,EACf2B,EAAK3C,OAASA,EAnBnB,QAY+B3C,IAZ/B,uBAW2BJ,IAX3B,4D,sBAwBP,SAASqT,GAAgBvT,EAAkBiD,EAAgBoQ,EAAeC,EAAehR,GAErF,IAAIkR,EAAOH,EAAOK,EAAOL,EAAOI,EAAOH,EAAOK,EAAOL,EAErD,GAAIhR,EAAOmK,OAAS,GAAK,CAAC,IAAD,EACNmH,GAAW5T,EAASiD,EAAQX,EAAQkR,EAAMC,EAAMC,EAAMC,GADhD,qBAENE,GAAc7T,EAASiD,EAAQX,EAD7CkR,EADoB,KACdC,EADc,KAE6CC,EAAMC,GAFnD,mBAEpBD,EAFoB,KAEdC,EAFc,SAIpB,CAAC,IAAD,EACcE,GAAc7T,EAASiD,EAAQX,EAAQkR,EAAMC,EAAMC,EAAMC,GADvE,qBAEcC,GAAW5T,EAASiD,EAAQX,EAAQkR,EAAMC,EADxDC,EADA,KACMC,EADN,yBAEAH,EAFA,KAEMC,EAFN,KAaL,OAPInR,EAAOmK,OAAS,MAChB+G,EAAOlR,EAAOuK,eAAe2G,EAAMH,GACnCK,EAAOpR,EAAOuK,eAAewG,EAAQ,EAAGK,EAAO,GAC/CD,EAAOnR,EAAOuK,eAAe4G,EAAMH,GACnCK,EAAOrR,EAAOuK,eAAeyG,EAAQ,EAAGK,EAAO,IAG5C,CACHH,OACAC,OACAC,OACAC,QAIR,SAASC,GAAW5T,EAAkBiD,EAAgBX,EAAiBkR,EAAcC,EAAcC,EAAcC,GAG7G,IAFA,IAAIG,GAAU,EAAMC,GAAQ,EAErBD,GAAWC,GACVA,GAASzR,EAAOmK,OAAS,GACzBsH,EAAQC,GAAchU,EAASiD,EAAQwQ,EAAO,EAAGD,EAAME,MAC9CD,EAAO,EAEXK,IACLA,EAAUG,GAAcjU,EAASiD,EAAQuQ,EAAO,EAAGC,EAAME,MAChDH,EAAO,GAIxB,MAAO,CAACA,EAAMC,GAIlB,SAASI,GAAc7T,EAAkBiD,EAAgBX,EAAiBkR,EAAcC,EAAcC,EAAcC,GAGhH,IAFA,IAAIO,GAAW,EAAMC,GAAU,EAExBD,GAAYC,GACXA,GAAW7R,EAAOmK,OAAS,GAC3B0H,EAAUH,GAAchU,EAASiD,EAAQ0Q,EAAO,EAAGH,EAAME,MAChDC,EAAO3T,EAAQoI,OAAS,EAE5B8L,IACLA,EAAWD,GAAcjU,EAASiD,EAAQyQ,EAAO,EAAGD,EAAME,MACjDD,EAAO1T,EAAQmI,MAAQ,GAIxC,MAAO,CAACuL,EAAMC,GAGlB,SAASM,GAAcjU,EAAkBiD,EAAgB/C,EAAWqE,EAAY6P,GAG5E,IAFA,IAAMnL,EAAMjJ,EAAQyE,mBAAmBvE,GAE9BI,EAAIiE,EAAIjE,GAAK8T,EAAI9T,IACtB,GAAI2I,EAAI3I,GAAG2C,SAAWA,EAClB,OAAO,EAIf,OAAO,EAGX,SAAS+Q,GAAchU,EAAkBiD,EAAgB3C,EAAW8D,EAAYiQ,GAC5E,IAAK,IAAInU,EAAIkE,EAAIlE,GAAKmU,EAAInU,IACtB,GAAIF,EAAQyE,mBAAmBvE,GAAGI,GAAG2C,SAAWA,EAC5C,OAAO,EAIf,OAAO,ECzGJ,SAAeqR,GAAtB,yC,8CAAO,WACHtU,EACA2D,EACAnC,EACAoC,GAJG,yBAAA3C,EAAA,oFAMkBjB,EAAQC,MAN1B,kEAMQgD,EANR,aAOSA,EAAOxB,WAPhB,cAQUhC,EAAW8U,QARrB,UAWU9U,EAAW+R,WAXrB,qCASeS,GAAmBjS,EAASiD,EAAQW,GATnD,6DAYewP,GAAmBpT,EAASiD,EAAQW,GAZnD,uFAkBKA,EAlBL,kCAmBWA,EAAgB4J,GAAUkE,QAnBrC,kV,sBCDA,SAAe8C,GAAtB,yC,8CAAO,WACHxU,EACA2D,EACAnC,EACAoC,GAJG,qDAAA3C,EAAA,sDAMCwT,EAAO,EANR,8BAOgBzU,EAAQ+D,MAPxB,uEAOQ6B,EAPR,SAQU3B,QARV,wDAYKyQ,EAASC,GAAY3U,EAAS4F,GAAM,GAAM,GAZ/C,+BAakB8O,EAblB,wEAaUE,EAbV,SAcc3Q,QAdd,wBAeS2B,EAAK2F,QAAS,EACd3F,EAAK3C,OAAS2R,EAAK3R,OAhB5B,mUAsBkB2C,EAAKwM,cAtBvB,wEAsBUwC,EAtBV,SAuBc3Q,SAA2B,OAAhB2Q,EAAK3R,QAAmB2R,EAAK3R,OAAOxB,aAAehC,EAAW+R,WAvBvF,wBAwBS5L,EAAK2F,QAAS,EACd3F,EAAK3C,OAAS2R,EAAK3R,OAzB5B,ySA8BKW,KAAqB6Q,GAAQzU,EAAQoI,QA9B1C,wBA+BKqM,EAAO,EA/BZ,UAgCW7Q,EAAgB4J,GAAUqH,MAhCrC,sY,sBAqCA,SAASF,GAAY3U,EAAkBmE,GAAoE,IAAxD2Q,IAAuD,yDAA3BC,EAA2B,wDACzGtC,EAAU,GAoCd,OAlCIqC,IACI3Q,EAAKjE,EAAI,GACTuS,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,IAEzD6D,EAAKjE,EAAIF,EAAQmI,MAAQ,GACzBsK,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,IAEzD6D,EAAK7D,EAAI,GACTmS,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,GAAGiE,EAAK7D,EAAI,IAEzD6D,EAAK7D,EAAIN,EAAQoI,OAAS,GAC1BqK,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,GAAGiE,EAAK7D,EAAI,KAI7DyU,IACI5Q,EAAKjE,EAAI,IACLiE,EAAK7D,EAAI,GACTmS,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,EAAI,IAE7D6D,EAAK7D,EAAIN,EAAQoI,OAAS,GAC1BqK,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,EAAI,KAGjE6D,EAAKjE,EAAIF,EAAQmI,MAAQ,IACrBhE,EAAK7D,EAAI,GACTmS,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,EAAI,IAE7D6D,EAAK7D,EAAIN,EAAQoI,OAAS,GAC1BqK,EAAQhQ,KAAKzC,EAAQyE,mBAAmBN,EAAKjE,EAAI,GAAGiE,EAAK7D,EAAI,MAKlEmS,EC9EJ,IAAMuC,GAAb,WAOI,aAA8C,IAA3BC,EAA0B,uDAAN,IAAM,yBAA1BA,YAA0B,KAJ7CrJ,eAI6C,OAH7CsJ,YAG6C,OAF7CpJ,kBAE6C,EACzCtL,KAAKoL,UAAY,GACjBpL,KAAK0U,QAAS,EACd1U,KAAKsL,aAAe,GAV5B,iEAgBQ,GAFAtL,KAAKsL,aAAe,KAEhBtL,KAAKoL,UAAUjL,OAAS,GAA5B,CAIA,IAEIT,EAAWI,EACX6U,EAAaC,EAAaC,EAAaC,EACvCC,EAAYC,EAAYC,EAAYC,EACpCC,EAAkBC,EAAcC,EAMhCC,EAXAC,EAAUvV,KAAKyU,UACfe,EAAgB,GAMhBC,EAAYzV,KAAKoL,UAAU,GAC3BsK,EAAW1V,KAAKoL,UAAUpL,KAAKoL,UAAUjL,OAAS,GAIlDsV,IAAcC,GACdJ,EAAgBtV,KAAKoL,UAAUjL,OAAS,EACxCuV,EAAW1V,KAAKoL,UAAUkK,IAE1BA,EAAgBtV,KAAKoL,UAAUjL,OAAS,EAvB3B,2BA0BjB,YAAiBH,KAAKoL,UAAtB,+CAAiC,CAAC,IAAzB7I,EAAwB,QAC7BiT,EAAIvT,KAAKM,EAAK7C,EAAG6C,EAAKzC,IA3BT,kFA8BjB,GAAIE,KAAK0U,OAAQ,CAEb,IAAIiB,EAAa3V,KAAKoL,UAAU,GAChCoK,EAAIvT,KAAKwT,EAAU/V,EAAG+V,EAAU3V,GAChC0V,EAAIvT,KAAK0T,EAAWjW,EAAGiW,EAAW7V,GAClC0V,EAAII,QAAQF,EAAShW,EAAGgW,EAAS5V,QAGjC0V,EAAII,QAAQH,EAAU/V,EAAG+V,EAAU3V,GACnC0V,EAAIvT,KAAKyT,EAAShW,EAAGgW,EAAS5V,GAIlC,IAAKuV,EAAM,EAAGA,EAAOG,EAAIrV,OAAS,EAAIkV,GAAO,EACzC,IAAKD,EAAO,EAAGA,GAAQZ,EAAMqB,gBAAiBT,IAE1CT,GAAOa,EAAIH,EAAM,GAAKG,EAAIH,EAAM,IAAME,EACtCX,GAAOY,EAAIH,EAAM,GAAKG,EAAIH,IAAQE,EAElCV,GAAOW,EAAIH,EAAM,GAAKG,EAAIH,EAAM,IAAME,EACtCT,GAAOU,EAAIH,EAAM,GAAKG,EAAIH,EAAM,IAAME,EAEtCJ,EAAWC,EAAOZ,EAAMqB,gBAGxBd,EAAO,EAAInU,KAAKkV,IAAIX,EAAU,GAAM,EAAIvU,KAAKkV,IAAIX,EAAU,GAAK,EAChEH,GAAO,EAAIpU,KAAKkV,IAAIX,EAAU,GAAM,EAAIvU,KAAKkV,IAAIX,EAAU,GAC3DF,EAAWrU,KAAKkV,IAAIX,EAAU,GAAM,EAAIvU,KAAKkV,IAAIX,EAAU,GAAKA,EAChED,EAAWtU,KAAKkV,IAAIX,EAAU,GAAUvU,KAAKkV,IAAIX,EAAU,GAG3DzV,EAAIqV,EAAKS,EAAIH,GAAUL,EAAKQ,EAAIH,EAAM,GAAKJ,EAAKN,EAAMO,EAAKN,EAC3D9U,EAAIiV,EAAKS,EAAIH,EAAM,GAAML,EAAKQ,EAAIH,EAAM,GAAKJ,EAAKJ,EAAMK,EAAKJ,EAC7D9U,KAAKsL,aAAarJ,KAAKvC,GACvBM,KAAKsL,aAAarJ,KAAKnC,QA7EvC,KCKO,SAAeiW,GAAtB,yC,8CAAO,WACHvW,EACA2D,EACAnC,EACAoC,GAJG,mCAAA3C,EAAA,sDAMHjB,EAAQgJ,MAAQ,GANb,8BAQgBhJ,EAAQ+D,MARxB,uEAQQ6B,EARR,SASU2F,QAAW3F,EAAK3B,QAT1B,kCAUWuS,GAAkBxW,EAAS4F,GAAM,EAAMhC,GAVlD,YAYSA,EAZT,kCAaeA,EAAgB4J,GAAUkE,QAbzC,6QAkBH,IAlBG,6BAkBH,EAAoB1R,EAAQgJ,MAA5B,+CAAmC,QACzByN,qBAnBP,yU,+BAuBQD,G,uFAAf,WAAiCxW,EAAkB0W,EAAiBC,EAAsB/S,GAA1F,yBAAA3C,EAAA,sEAC4B2V,GAAwB5W,EAAS0W,EAAW9S,GADxE,OACUiT,EADV,sBAM8BlY,KADhBmY,EAAgBC,GAAyB/W,EAAS6W,IALhE,uBAOgBF,GACAK,GAAmBhX,EAAS6W,QAGRlY,IAApBiF,GACAiT,EAAUJ,qBAZ1B,kBAcmBI,GAdnB,cAkBcI,EAAcJ,EAAUjL,UAAUxF,QAAQ0Q,GAlBxD,UAoB+BN,GAAkBxW,EAAS8W,GAAe,EAAOlT,GApBhF,cAoBcsT,EApBd,QAsBqBtL,UAAUjL,QAAUkW,EAAUjL,UAAUjL,OAASsW,GAAeH,IAAkBJ,GAtBvG,0DA4BYS,EAAYD,EAAStL,UAAUvF,MAAM,IACrC+Q,EAAYP,EAAUjL,UAAU0D,OAAO2H,EAAc,IAC/Cb,QAAQU,GAElBI,EAAStL,UAAYwL,EACrBP,EAAUjL,UAAYiL,EAAUjL,UAAUyL,OAAOF,GAE7CR,GACAK,GAAmBhX,EAASkX,QAGRvY,IAApBiF,EAvCZ,wBAwCYsT,EAAST,qBACTI,EAAUJ,qBAzCtB,UA0CkB7S,EAAgB4J,GAAUkE,QA1C5C,oE,sBA+CA,SAASqF,GAAyB/W,EAAkByL,GAEhD,IAAK,IAAIN,EAAIM,EAAMG,UAAUjL,OAAS,EAAGwK,GAAK,EAAGA,IAAK,CAClD,IAAImM,EAAY7L,EAAMG,UAAUT,GAGhC,QAAmBxM,IADF4Y,GAAyBvX,EAASsX,GAAW,GAAM,GAAM,SAAA9K,GAAC,OAAKA,EAAEvI,SAAWuI,EAAEjB,UAE3F,OAAO+L,GAOnB,SAASN,GAAmBhX,EAAkB6W,EAAkBjT,GAE5D,IAAM4T,EAAaX,EAAUjL,UAAU,GACjC6L,EAAYZ,EAAUjL,UAAUiL,EAAUjL,UAAUjL,OAAS,GAEnE,GAAI6W,IAAeC,EACfZ,EAAU3B,QAAS,MAChB,CACH,IAAIwC,EAAWb,EAAUjL,UAAU+L,YAAYH,GAC/C,GAAIE,EAAW,EAAG,CAEd,IAAME,EAAa,IAAI5C,GACvB4C,EAAWhM,UAAYiL,EAAUjL,UAAU0D,OAAOoI,EAAW,GAC7DE,EAAWhM,UAAUwK,QAAQS,EAAUjL,UAAU8L,IAE7C9T,GACAgU,EAAWnB,qBAEfzW,EAAQgJ,MAAMvG,KAAKmV,GAEnBf,EAAU3B,QAAS,EAKvB,IADAwC,EAAWb,EAAUjL,UAAUxF,QAAQqR,IACxBZ,EAAUjL,UAAUjL,OAAS,EAAG,CAQ3C,IAAMiX,EAAa,IAAI5C,GACjB6C,EAAahB,EAAUjL,UAAU8L,GACvCE,EAAWhM,UAAYiL,EAAUjL,UAAU0D,OAAO,EAAGoI,EAAW,GAChEE,EAAWhM,UAAUnJ,KAAKoV,GACtBjU,GACAgU,EAAWnB,qBAEfzW,EAAQgJ,MAAMvG,KAAKmV,GAEnBf,EAAU3B,QAAS,IAWxB,SAAe0B,GAAtB,uC,8CAAO,WAAuC5W,EAAkB0W,EAAiB9S,GAA1E,qBAAA3C,EAAA,sDACGwK,EAAQ,IAAIuJ,GAClBhV,EAAQgJ,MAAMvG,KAAKgJ,GAEfqM,EAA6BpB,OAKT/X,KAFlBoZ,EAAkBpD,GAAY3U,EAAS0W,GAAW,GAAM,GACzDsB,MAAK,SAAAxL,GAAC,OAAIA,EAAEjB,QAAUiB,EAAEvI,cAEzBwH,EAAMG,UAAUnJ,KAAKsV,GACrBrB,EAAYqB,GAGhBtM,EAAMG,UAAUnJ,KAAKqV,GACrBA,EAAS7T,SAAU,EAfhB,eAyBctF,KANTiH,EAAOqS,GACPjY,EACA8X,GACA,SAAAtL,GAAC,OAAKA,EAAEvI,SAAWuI,EAAEjB,WAGA,WAErB,IAAM2M,EAAWzM,EAAMG,UAAUjL,OAAS,EACpC8K,EAAMG,UAAUH,EAAMG,UAAUjL,OAAS,QACzChC,EAENiH,EAAOqS,GACHjY,EACA8X,GACA,SAAAtL,GAAC,OAAIA,EAAEjB,QAAUiB,IAAM0L,KAE3BJ,OAAWnZ,EAXU,GAcrBmZ,EAAWlS,EAGXA,IAAS8Q,EA1Cd,wBA2CKjL,EAAMyJ,QAAS,EA3CpB,qCA+CcvW,IAATiH,EA/CL,wDAmDC6F,EAAMG,UAAUnJ,KAAKmD,IAEjBA,EAAK3B,QArDV,wDAyDC2B,EAAK3B,SAAU,GAEXL,EA3DL,wBA4DK6H,EAAMgL,qBA5DX,UA6DW7S,EAAgB4J,GAAU2K,SA7DrC,gBAgEmBxZ,IAAbmZ,EAhEN,4BAkEClU,EAlED,wBAmEC6H,EAAMgL,qBAnEP,UAoEO7S,EAAgB4J,GAAUkE,QApEjC,iCAuEIjG,GAvEJ,6C,sBA0EA,SAASwM,GACZjY,EACAmE,EACAhB,GAEA,IAAMiV,EAAQb,GAAyBvX,EAASmE,GAAM,GAAM,EAAOhB,GACnE,YAAiBxE,IAAVyZ,EACDA,EACAb,GAAyBvX,EAASmE,GAAM,GAAO,EAAMhB,GAG/D,SAASoU,GACLvX,EACAmE,EACA2Q,EACAC,EACA5R,GAEA,IAAIkV,EACAC,EAA8B,EAE9B5D,EAASC,GAAY3U,EAASmE,EAAM2Q,EAAYC,GAJtD,uBAKE,YAAiBL,EAAjB,+CAAyB,CAAC,IAAjB9O,EAAgB,QACrB,GAAKzC,EAAOyC,GAAZ,CAIA,IAAI2S,EAA0B,EAC1BC,EAAc7D,GAAY3U,EAAS4F,GAAM,GAAM,GAN9B,uBAQrB,YAAqB4S,EAArB,+CAAkC,SAChBjN,QACVgN,KAVa,kFAcjBA,EAA0BD,IAC1BA,EAA8BC,EAC9BF,EAAWzS,KArBrB,kFAyBE,OAAOyS,EClQJ,SAASI,GACZzO,EACA/J,GAED,IADCyY,EACF,uDAD8D,SAACxV,EAAM8G,GAAP,OAAiBA,EAAMwF,aAAatM,IAE5FyV,EAAWvK,OAAOC,UAClBuK,EAAyB,KAF/B,uBAIE,YAAmB3Y,EAAnB,+CAA0B,CAAC,IAAhBiD,EAAe,QAChB2V,EAAOH,EAAYxV,EAAM8G,GAC3B6O,EAAOF,IACPA,EAAWE,EACXD,EAAW1V,IARrB,kFAYE,OAAO0V,ECXJ,SAAeE,GAAtB,yC,8CAAO,WACH9Y,EACA2D,EACAnC,EACAoC,GAJG,6BAAA3C,EAAA,sDAMCwT,EAAO,EAELsE,EAAW,SAACzN,EAActB,GAAf,OAAwCA,EAAMwF,aAAalE,GAAQA,EAAK3J,iBARtF,8BAUgB3B,EAAQ+D,MAVxB,sEAUQ6B,EAVR,SAWM3C,OAASwV,GAAW7S,EAAM5F,EAAQC,MAAO8Y,KAE1CnV,KAAqB6Q,GAAQzU,EAAQoI,QAb1C,wBAcKqM,EAAO,EAdZ,UAeW7Q,EAAgB4J,GAAU2K,SAfrC,kV,sBHLMnD,GACOqB,gBAAkB,GIA/B,IAAM2C,GAAb,YAMI,WAAY9Y,EAAWI,EAAWkB,GAAgB,IAAD,EAC7C,GAD6C,yBAChC7C,IAAT6C,EAMA,OALA,4CAAMtB,EAAI,GAAKI,EAAI,MAPX+J,cAMY,IALZH,iBAKY,IAJZM,aAIY,IAHZE,gBAGY,EAEpB,EAAKL,SAAW,EAChB,EAAKH,YAAc,EACnB,EAAKM,QAAU,EACf,EAAKE,WAAa,EAClB,eAGJ,IAAMpI,EAAS,IAAI6J,EAAQ3K,EAAOtB,EAAIA,EAAI,QAAc,QAAJA,EAAcI,EAAIA,EAAI,QAAc,OAAJA,GAVvC,OAY7C,4CAAMJ,EAAIoC,EAAOsK,YAAY,GAAK,IAAMtM,EAAIgC,EAAOsK,YAAY,GAAK,OAjBxDvC,cAKiC,IAJjCH,iBAIiC,IAHjCM,aAGiC,IAFjCE,gBAEiC,EAc7C,EAAKL,SAAW/H,EAAOsK,YAAY,EAAa,EAAVxL,KAAK4J,IAC3C,EAAKd,YAAc5H,EAAOsK,YAAY,GAAK,MAC3C,EAAKpC,QAAUlI,EAAOsK,YAAY,EAAG,KACrC,EAAKlC,WAAapI,EAAOsK,YAAY,EAAG,KAjBK,eANrD,2BAA8BrM,GCGvB,SAAe0Y,GAAtB,yC,8CAAO,WACHjZ,EACA2D,EACAnC,EACAoC,GAJG,iBAAA3C,EAAA,sDAMGiY,EAAYlZ,EAAQ+D,MAAMZ,QAAO,SAAAqJ,GAAC,OAAIA,EAAEjB,UAExC4N,EAAgB,IAAInG,IAC1BoG,GAAyBF,EAAWC,GACpCC,GAAyB,YAAID,GAAgBA,GAC7CC,GAAyB,YAAID,GAAgBA,GAE7CnZ,EAAQ4I,eAAiB,YAAIuQ,GACxBhW,QAAO,SAAAyC,GAAI,OAAKA,EAAK1F,EAAI0F,EAAKtF,GAAK,IAAM,KACzCqQ,KAAI,SAAA/K,GAAI,OAAI,IAAIoT,GAASpT,EAAK1F,EAAG0F,EAAKtF,EAAGkB,MAf3C,4C,sBAkBP,SAAS4X,GAAyBF,EAAmBC,GAA2B,IAAD,uBAC3E,YAAmBD,EAAnB,+CAA8B,CAAC,IAApBtT,EAAmB,+BAC1B,YAAuBA,EAAKwM,cAA5B,+CAA2C,CAAC,IAAjCiH,EAAgC,QAClCA,EAASpV,SACVkV,EAAchG,IAAIkG,IAHA,oFAD6C,mFCrBxE,ICYK7L,GDZC8L,GAAb,YAII,WAAYpZ,EAAWI,GAA6E,IAAD,EAA1D2D,EAA0D,wDAAzBsH,EAAyB,oFAC/F,4CAAMrL,EAAGI,KAD4B2D,UAA0D,EAAzBsH,SAAyB,EAH5FtI,OAAwB,KAGoE,EAFnFmP,cAAwB,GAE2D,EAJvG,2BAA0B7R,GEEnB,SAAegZ,GAAtB,yC,8CAAO,WACHvZ,EACA2D,EACAnC,EACAoC,GAJG,+BAAA3C,EAAA,sDASH,IAHAjB,EAAQ+D,MAAQ,GAChB/D,EAAQyE,mBAAqB,GAEpBvE,EAAI,EAAGA,EAAIF,EAAQmI,MAAOjI,IAI/B,IAHI+I,EAAM,IAAIuQ,MAAYxZ,EAAQoI,QAClCpI,EAAQyE,mBAAmBvE,GAAK+I,EAEvB3I,EAAI,EAAGA,EAAIN,EAAQoI,OAAQ9H,IAC1BsF,EAAO,IAAI0T,GAAKpZ,EAAGI,GACzB2I,EAAI3I,GAAKsF,EACT5F,EAAQ+D,MAAMtB,KAAKmD,GAO3B,IAHM8N,EAAO1T,EAAQmI,MAAQ,EACvBwL,EAAO3T,EAAQoI,OAAS,EAErBlI,EAAI,EAAGA,EAAIF,EAAQmI,MAAOjI,IAC/B,IAASI,EAAI,EAAGA,EAAIN,EAAQoI,OAAQ9H,IAC1BsF,EAAO5F,EAAQyE,mBAAmBvE,GAAGI,GAEvCJ,EAAI,IACAI,EAAI,GACJsF,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,EAAE,IAG9DsF,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,IAEpDA,EAAIqT,GACJ/N,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,EAAE,KAI9DA,EAAI,GACJsF,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,GAAGI,EAAE,IAGxDA,EAAIqT,GACJ/N,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,GAAGI,EAAE,IAGxDJ,EAAIwT,IACApT,EAAI,GACJsF,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,EAAE,IAG9DsF,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,IAEpDA,EAAIqT,GACJ/N,EAAKwM,cAAc3P,KAAKzC,EAAQyE,mBAAmBvE,EAAE,GAAGI,EAAE,KAvDvE,4C,sBD0BA,SAAemZ,GAAtB,mC,8CAAO,WACH9V,GADG,eAAA1C,EAAA,6DAGGjB,EAAU,IAAI2I,EAHjB,SAIG+Q,GAAkB1Z,EAAS2D,GAJ9B,gCAKI3D,GALJ,4C,sBAQA,SAAe0Z,GAAtB,qC,8CAAO,WACH1Z,EACA2D,GAFG,6BAAA1C,EAAA,sDAIHjB,EAAQmI,MAAQxE,EAAS9D,UACzBG,EAAQoI,OAASzE,EAAStD,UAEpBsZ,EAAgB,IAAIxN,EAAQxI,EAASnC,MAErCoY,EAAgB,IAAInU,IAAqC,CAC3D,CAACzK,EAAgBE,YAAaqe,IAC9B,CAACve,EAAgBG,YAAa+R,GAC9B,CAAClS,EAAgBI,eAAgB0d,IACjC,CAAC9d,EAAgBK,UAAWiW,IAC5B,CAACtW,EAAgBM,YAAaqW,IAC9B,CAAC3W,EAAgBO,YAAamI,GAC9B,CAAC1I,EAAgBQ,YAAa8Y,IAC9B,CAACtZ,EAAgBS,YAAa+Y,IAC9B,CAACxZ,EAAgBU,WAAY6a,IAC7B,CAACvb,EAAgBW,aAAcsd,MAnBhC,gCAAAhY,EAAA,wCAAAA,EAAA,yDAsBQ2U,EAtBR,aAwBmBjX,KADZkb,EAAYD,EAAc9T,IAAI8P,IAvBrC,mEA4BOkE,EAAWH,EAAclN,OAEzBsN,GAA0D,IAAzCpW,EAASqW,aAAa5T,QAAQwP,GAA9B,uCACjB,WAAOqE,GAAP,SAAAhZ,EAAA,0DAC+C,IAAzC0C,EAASqW,aAAa5T,QAAQwP,GADpC,wDAKEjS,EAASvD,OAAOJ,EAAS4V,GAAM,GALjC,SAMQsE,GAAMD,GANd,2CADiB,2DASjBtb,EAvCP,SAyCOkb,EAAU7Z,EAAS2D,EAAUmW,EAAUC,GAzC9C,WA2C8C,IAAzCpW,EAASqW,aAAa5T,QAAQwP,IAAgBA,IAAS5a,EAAgBE,YA3C5E,wBA4CKyI,EAASvD,OAAOJ,EAAS4V,GAAM,GA5CpC,UA6CWsE,GAAM1M,GAAU2M,OA7C3B,6CAsBgBxW,EAASgE,MAtBzB,ugB,sBAkDP,SAASuS,GAAME,GACX,OAAO,IAAIC,SAAc,SAAAC,GACrBC,YAAW,kBAAMD,MAAWF,M,ukBA5ExB5M,O,eAAAA,I,sBAAAA,I,gBAAAA,I,mBAAAA,I,qBAAAA,I,qBAAAA,Q,KEHL,ICDDgN,GAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DAgCN,SAASC,GAAgBC,GACvBC,UAAUC,cACPC,SAASH,GACTI,MAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WAClCD,IACFA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBpT,QACf8S,UAAUC,cAAcQ,WAK1BC,QAAQC,IAAI,6CAKZD,QAAQC,IAAI,6CAOvBC,OAAM,SAAAC,GACLH,QAAQG,MAAM,4CAA6CA,M,MCtEjEC,SACE,iBFKoC,WAClC,IAAMpU,EAASgB,SAA0B,MADD,EAGVjC,mBAAkB,IAAIkC,GAHZ,mBAGjC3I,EAHiC,KAGxB+b,EAHwB,OAIJtV,oBAAS,GAJL,mBAIjCuV,EAJiC,KAIrBC,EAJqB,OAQIxV,mBAA0B5K,EAAwBb,EAAgBY,QAAQ,EAFrG,KANuB,mBAQjCsgB,EARiC,KAQjB/d,EARiB,OAUYsI,mBAA8B,CAC9EjF,KAAM,EACNmG,MAAO1M,EACP+e,aAAc,GACdna,UAAW,IACXQ,UAAW,GACXiN,UAAW,GACXsE,aAAc,GACdxR,OAAQ,SAACJ,EAAkBmc,EAAwBpgB,GACxB,OAAnB2L,EAAO0U,SACPlT,EAAclJ,EAAS0H,EAAO0U,QAAQpU,IAAMnM,EAAwBsgB,EAAOpgB,EAdtE,QANuB,mBAUjC6D,EAViC,KAUbO,EAVa,KAyBlCpC,EAAQ,uCAAG,8BAAAkD,EAAA,6DACP0C,EADO,MAEN/D,EAFM,CAGT4B,KAAMJ,KAAKkB,SACXqF,MAAO1M,EACP+e,aAAc,KAGlB7Z,EAAsBwD,GACtBsY,GAAc,GATD,SAWSxC,GAAgB9V,GAXzB,OAWP3D,EAXO,OAab+b,EAAW/b,GACXic,GAAc,GAES,OAAnBvU,EAAO0U,SACPlT,EAAclJ,EAAS0H,EAAO0U,QAAQpU,IAAMkU,GAjBnC,2CAAH,qDAqBRrV,EAAU,uCAAG,WAAO5I,EAAkB0J,GAAzB,SAAA1G,EAAA,6DACfgb,GAAc,GADC,SAGTvC,GAAkB1Z,EAAD,MAChBJ,EADgB,CAEnB+H,QACAqS,aAAc/b,EAAU0J,EAAMtB,QAAU,MAN7B,OASf4V,GAAc,GAES,OAAnBvU,EAAO0U,SACPlT,EAAclJ,EAAS0H,EAAO0U,QAAQpU,IAAMkU,GAZjC,2CAAH,wDAmBhBhe,qBAAU,WAAQH,MAAe,IAUjC,OACI,uBAAKF,UAAU,OACX,gBAAC,EAAD,CACImC,QAASA,EACT0H,OAA2B,OAAnBA,EAAO0U,aAAmBzd,EAAY+I,EAAO0U,QAAQ1U,OAC7D1L,SA1EK,GA2EL4B,aAAcoe,EACdpc,mBAAoBA,EACpBO,sBAAuBA,EACvBhC,kBAjBuB,SAAC+d,GAChC/d,EAAkB+d,GAEK,OAAnBxU,EAAO0U,SACPlT,EAAclJ,EAAS0H,EAAO0U,QAAQpU,IAAMkU,IAcxCne,SAAUA,EACV8I,WAAYA,EACZe,KAzBC,kBAAMhI,EAAmBoa,aAAa1K,OAAO,EAAG,IA0BjDzH,OAzBG,kBAAMjI,EAAmBoa,aAAe,MA2B/C,gBAAC,EAAD,CACInc,UAAU,iBACVsK,MAtFK,GAsFavI,EAAmBC,UACrCuI,OAvFK,GAuFcxI,EAAmBS,UACtCgI,IAAKX,OEnGnB,MACA2U,SAASC,eAAe,SDaX,WACb,GAA6C,kBAAmBtB,UAAW,CAMzE,GAJkB,IAAIuB,IACpBC,GACA9B,OAAOC,SAAS5N,YAEJ0P,SAAW/B,OAAOC,SAAS8B,OAIvC,OAGF/B,OAAOrX,iBAAiB,QAAQ,WAC9B,IAAM0X,EAAK,UAAMyB,GAAN,sBAENhC,GA0CX,SAAiCO,GAE/B2B,MAAM3B,GACHI,MAAK,SAAAwB,GAGkB,MAApBA,EAASC,SACwD,IAAjED,EAASE,QAAQ/W,IAAI,gBAAiBM,QAAQ,cAG9C4U,UAAUC,cAAc6B,MAAM3B,MAAK,SAAAC,GACjCA,EAAa2B,aAAa5B,MAAK,WAC7BT,OAAOC,SAASqC,eAKpBlC,GAAgBC,MAGnBa,OAAM,WACLF,QAAQC,IACN,oEA3DAsB,CAAwBlC,GAHxBD,GAAgBC,OC9BxBmC,K","file":"static/js/main.87ece2f1.chunk.js","sourcesContent":["export enum GenerationSteps {\r\n    CreateTiles,\r\n    CreateNodes,\r\n    AssociateTiles,\r\n    LinkNodes,\r\n    FilterLinks,\r\n    ExpandLines,\r\n    CreateRooms,\r\n    DetectWalls,\r\n    CurveWalls,\r\n    FillBackdrop,\r\n    Render,\r\n\r\n\r\n    FIRST_STEP = CreateTiles,\r\n}\r\n\r\nexport const allSteps = [\r\n    GenerationSteps.CreateTiles,\r\n    GenerationSteps.CreateNodes,\r\n    GenerationSteps.AssociateTiles,\r\n    GenerationSteps.LinkNodes,\r\n    GenerationSteps.FilterLinks,\r\n    GenerationSteps.ExpandLines,\r\n    GenerationSteps.CreateRooms,\r\n    GenerationSteps.DetectWalls,\r\n    GenerationSteps.CurveWalls,\r\n    GenerationSteps.FillBackdrop,\r\n    GenerationSteps.Render,\r\n];","import { GenerationSteps } from './GenerationSteps';\r\n\r\nexport interface IRenderSettings {\r\n    nodeAlpha: number;\r\n    regionAlpha: number;\r\n    graphAlpha: number;\r\n    drawNodeLinks: boolean;\r\n    drawGrid: boolean;\r\n    drawWalls: boolean;\r\n    highlightWallCurves: boolean;\r\n    drawOutsidePoints: boolean;\r\n    drawOutside: boolean;\r\n    backgroundColor: string;\r\n    linkColor: string;\r\n    linkWidth: number;\r\n    floorColor: string;\r\n    floorGridColor: string;\r\n    floorGridWidth: number;\r\n    wallColor: string;\r\n    hatchingColor: string;\r\n    cellSize: number,\r\n    wallWidth: number,\r\n    hatchingWidth: number,\r\n    drawWallsAsFloor: boolean,\r\n    minimumSpanningWidth: number,\r\n    relativeNeighbourhoodWidth: number,\r\n    gabrielWidth: number,\r\n    delauneyWidth: number,\r\n}\r\n\r\nexport function determineRenderSettings(   \r\n    generationStage = GenerationSteps.Render,\r\n    stageComplete: boolean = true,\r\n    cellSize: number,\r\n): IRenderSettings {\r\n    let nodeAlpha = 0;\r\n    let regionAlpha = 0;\r\n    let graphAlpha = 0;\r\n    let drawNodeLinks = false;\r\n    let drawGrid = false;\r\n    let drawWalls = false;\r\n    let highlightWallCurves = false;\r\n    let drawOutside = false;\r\n    let drawOutsidePoints = false;\r\n    let drawWallsAsFloor = true;\r\n\r\n    switch (generationStage) {\r\n        case GenerationSteps.CreateTiles:\r\n            drawGrid = true;\r\n            break;\r\n            \r\n        case GenerationSteps.CreateNodes:\r\n            nodeAlpha = 1;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.AssociateTiles:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.66;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.LinkNodes:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.5;\r\n            graphAlpha = 0.25;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.FilterLinks:\r\n            nodeAlpha = 0.75;\r\n            regionAlpha = 0.55;\r\n            drawNodeLinks = true;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.ExpandLines:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CreateRooms:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.DetectWalls:\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CurveWalls:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n\r\n            highlightWallCurves = !stageComplete;\r\n            break;\r\n\r\n        case GenerationSteps.FillBackdrop:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutsidePoints = true;\r\n            break;\r\n\r\n        case GenerationSteps.Render:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutside = true;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        nodeAlpha,\r\n        regionAlpha,\r\n        graphAlpha,\r\n        drawNodeLinks,\r\n        drawGrid,\r\n        drawWalls,\r\n        highlightWallCurves,\r\n        drawOutsidePoints,\r\n        drawOutside,\r\n        floorColor: '#fff',\r\n        floorGridColor: 'rgba(192,192,192,0.5)',\r\n        linkColor: '#000',\r\n        linkWidth: 1,\r\n        backgroundColor: '#fff',\r\n        hatchingColor: '#000',\r\n        wallColor: '#000',\r\n        cellSize,\r\n        wallWidth: cellSize,\r\n        floorGridWidth: 1,\r\n        hatchingWidth: cellSize * 0.175,\r\n        drawWallsAsFloor,\r\n        minimumSpanningWidth: cellSize,\r\n        relativeNeighbourhoodWidth: cellSize * 0.5,\r\n        gabrielWidth: cellSize * 0.25,\r\n        delauneyWidth: 1,\r\n    };\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\nexport interface Props {\r\n    isGenerating: boolean;\r\n    generate: () => Promise<void>;\r\n    animate: () => Promise<void>;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    skip: () => void;\r\n    finish: () => void;\r\n\r\n    showSize: () => void;\r\n    showRegions: () => void;\r\n    showRenders: () => void;\r\n}\r\n\r\nexport const Generate: FunctionComponent<Props> = props => {\r\n    const generateOrSkip = props.isGenerating\r\n        ? <button className=\"menu__button\">Skip step</button>\r\n        : <button className=\"menu__button\" onClick={props.generate}>Generate new</button>\r\n\r\n    const animateOrFinish = props.isGenerating\r\n        ? <button className=\"menu__button\">Finish</button>\r\n        : <button className=\"menu__button\" onClick={props.animate}>Animate generation</button>\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.Render, true, props.cellSize),\r\n        });\r\n    }, []); // eslint-disable-line\r\n    \r\n    return <div className=\"menu menu--autoGenerate\">\r\n        <button className=\"menu__link\" onClick={props.showSize}>Map size</button>\r\n        <button className=\"menu__link\" onClick={props.showRegions}>Edit regions</button>\r\n\r\n        <div className=\"menu__spacer\" />\r\n\r\n        {generateOrSkip}\r\n        {animateOrFinish}\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo } from 'react';\r\n\r\ninterface Props {\r\n    className?: string;\r\n    inputClassName?: string;\r\n    label: string;\r\n    min: number;\r\n    max: number;\r\n    value: number;\r\n    onChange?: (val: number) => void;\r\n    onChangeComplete?: () => void;\r\n    disabled?: boolean;\r\n}\r\n\r\nexport const RangeInput: FunctionComponent<Props> = props => {\r\n    const {onChange, onChangeComplete} = props;\r\n\r\n    const changeHandler = useMemo(() => {\r\n        if (onChange === undefined) {\r\n            return undefined;\r\n        }\r\n        return (e: React.ChangeEvent<HTMLInputElement>) => onChange(e.target.valueAsNumber)\r\n    }, [onChange]);\r\n\r\n    const changeCompleteHandler = useMemo(() => {\r\n        if (onChangeComplete === undefined) {\r\n            return undefined;\r\n        }\r\n        return () => onChangeComplete();\r\n    }, [onChangeComplete]);\r\n\r\n    return (\r\n        <label className={props.className}>{props.label}\r\n            <input\r\n                type=\"range\"\r\n                className={props.inputClassName}\r\n                min={props.min}\r\n                max={props.max}\r\n                value={props.value}\r\n                onChange={changeHandler}\r\n                onMouseUp={changeCompleteHandler}\r\n                onTouchEnd={changeCompleteHandler}\r\n                disabled={props.disabled}\r\n            />\r\n        </label>\r\n    );\r\n}\r\n","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { RangeInput } from '../common/RangeInput';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    generationSettings: IGenerationSettings;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const MapSize: FunctionComponent<Props> = props => {\r\n    const setWidth = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsWide;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.x *= scale;\r\n        }\r\n\r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsWide: val,\r\n        });\r\n    }\r\n\r\n    const setHeight = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsHigh;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.y *= scale;\r\n        }\r\n        \r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsHigh: val,\r\n        });\r\n    }\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    return <div className=\"menu menu--mapSize\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n    \r\n        <div className=\"menu__group\">\r\n            <RangeInput\r\n                label=\"Width\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsWide}\r\n                onChange={setWidth}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n\r\n            <RangeInput\r\n                label=\"Height\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsHigh}\r\n                onChange={setHeight}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n        </div>\r\n    </div>\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { Dungeon } from './Dungeon';\r\nimport { Pathway } from './Pathway';\r\n\r\nexport enum RegionType {\r\n    Junction = 0,\r\n    Natural = 1,\r\n    Artificial = 2,\r\n\r\n    NUM_VALUES,\r\n    FIRST_VALUE = 0,\r\n}\r\n\r\nexport class Region extends Coord2D {\r\n    radius: number = 0.75;\r\n    links: Pathway[] = [];\r\n\r\n    constructor(\r\n        readonly parent: Dungeon,\r\n        x: number,\r\n        y: number,\r\n        public seed: number,\r\n        public regionType: RegionType,\r\n        public readonly color: string,\r\n        public regionInfluence = 1\r\n    ) {\r\n        super(x, y);\r\n    }\r\n}","export abstract class Coord<TCoord extends Coord<TCoord>> {\r\n    abstract length(): number;\r\n\r\n    abstract equals(other: Coord<TCoord>): boolean;\r\n    \r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract toUnitLength(): Coord<TCoord>;\r\n\r\n    abstract distanceTo(other: Coord<TCoord>): number;\r\n    \r\n    abstract distanceSqTo(other: Coord<TCoord>): number;\r\n\r\n    abstract directionTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract halfwayTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract scale(scale: number): Coord<TCoord>;\r\n    \r\n    abstract crossProduct(other: Coord<TCoord>): number;\r\n\r\n    abstract circumCircle(b: Coord<TCoord>, c: Coord<TCoord>): [Coord<TCoord>, number];\r\n}\r\n\r\nexport class Coord2D extends Coord<Coord2D> {\r\n    constructor(public x: number, public y: number) {\r\n        super();\r\n    }\r\n\r\n    length() {\r\n        return this.magnitude(this.x, this.y);\r\n    }\r\n\r\n    equals(other: Coord2D) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    add(other: Coord2D) {\r\n        return new Coord2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subtract(other: Coord2D) {\r\n        return new Coord2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    toUnitLength() {\r\n        let length = this.length();\r\n        return new Coord2D(this.x / length, this.y / length);\r\n    }\r\n    \r\n    distanceTo(other: Coord2D) {\r\n        return this.magnitude(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    distanceSqTo(other: Coord2D) {\r\n        return this.magnitudeSq(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    directionTo(other: Coord2D) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        \r\n        let length = this.magnitude(dx, dy);\r\n        return new Coord2D(dx / length, dy / length);\r\n    }\r\n\r\n    halfwayTo(other: Coord2D) {\r\n        return new Coord2D((this.x + other.x) / 2, (this.y + other.y) / 2);\r\n    }\r\n\r\n    scale(scale: number) {\r\n        return new Coord2D(this.x * scale, this.y * scale);\r\n    }\r\n\r\n    crossProduct(other: Coord2D) {\r\n        return this.x * other.y - this.y * other.x;\r\n    }\r\n\r\n    circumCircle(b: Coord2D, c: Coord2D) {\r\n        let a = this;\r\n        let d = (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n        \r\n        let x = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) \r\n             -  ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.y - c.y))\r\n        / d;\r\n\r\n        let y = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x)\r\n            -  ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x))\r\n        / d;\r\n\r\n        let center = new Coord2D(x, y);\r\n\r\n        let rSquared = (c.x - center.x) * (c.x - center.x) + (c.y - center.y) * (c.y - center.y);\r\n\r\n        let retVal: [Coord2D, number] = [\r\n            center,\r\n            rSquared\r\n        ];\r\n\r\n        return retVal;\r\n    }\r\n\r\n    private magnitude(dx: number, dy: number) {\r\n        return Math.sqrt(this.magnitudeSq(dx, dy));\r\n    }\r\n\r\n    private magnitudeSq(dx: number, dy: number) {\r\n        return dx * dx + dy * dy;\r\n    }\r\n}","const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n\r\nexport function randomColor() {\r\n    const r = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const g = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const b = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    return `#${r}${g}${b}`;\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { Region, RegionType } from '../../dungeon/model/Region';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { randomColor } from '../../lib/randomColor';\r\n\r\ninterface Props {\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const AddRegions: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        const leftClick = (e: MouseEvent) => {\r\n                const cellX = e.offsetX / cellSize;\r\n                const cellY = e.offsetY / cellSize;\r\n    \r\n                // add new node\r\n                const seed = Math.random();\r\n                const regionType = Math.floor(Math.random() * RegionType.NUM_VALUES);\r\n                dungeon.nodes.push(new Region(dungeon, cellX, cellY, seed, regionType, randomColor()));\r\n                redraw();\r\n            };\r\n\r\n        const rightClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            e.preventDefault();\r\n\r\n            // remove associated node\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined || cell.region === null) {\r\n                return;\r\n            }\r\n\r\n            const node = cell.region;\r\n            dungeon.nodes = dungeon.nodes.filter(n => n !== node);\r\n\r\n            redraw();\r\n        };\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize]);\r\n\r\n    return <div className=\"menu__section\">\r\n        Left click the map to place region nodes. Right click to remove a region.\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\n\r\ninterface Props {\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const ResizeRegions: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        const leftClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined || cell.region === null) {\r\n                return;\r\n            }\r\n\r\n            cell.region.regionInfluence *= 1.2;\r\n            redraw();\r\n        };\r\n\r\n        const rightClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            e.preventDefault();\r\n\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined || cell.region === null) {\r\n                return;\r\n            }\r\n\r\n            cell.region.regionInfluence /= 1.2;\r\n            redraw();\r\n        };\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize]);\r\n\r\n    return <div className=\"menu__section\">\r\n        Left click a region to grow it, right click a region to shrink it.\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { RegionType } from '../../dungeon/model/Region';\r\n\r\ninterface Props {\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const RegionTypes: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        const leftClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined || cell.region === null) {\r\n                return;\r\n            }\r\n\r\n            if (++cell.region.regionType >= RegionType.NUM_VALUES) {\r\n                cell.region.regionType = RegionType.FIRST_VALUE;\r\n            }\r\n            redraw();\r\n        };\r\n\r\n        const rightClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            e.preventDefault();\r\n\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined || cell.region === null) {\r\n                return;\r\n            }\r\n\r\n            cell.region.seed = Math.random();\r\n            redraw();\r\n        };\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize]);\r\n\r\n    return <div className=\"menu__section\">\r\n        Left click a region to change its type. Right click to regenerate it with the same type.\r\n    </div>\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function linkLinesToGrid(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const link of dungeon.lines) {\r\n        const tiles = getTouchedTiles(link, dungeon);\r\n\r\n        for (const tile of tiles) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getTouchedTiles(link: Pathway, dungeon: Dungeon) {\r\n    // Associate each tile that this link overlaps or touches.\r\n    // This is Xiaolin Wi's algorithm, without the antialiasing.\r\n    let x0 = Math.floor(link.from.x);\r\n    let x1 = Math.floor(link.to.x);\r\n    let y0 = Math.floor(link.from.y);\r\n    let y1 = Math.floor(link.to.y);\r\n    const col0 = dungeon.tilesByCoordinates[x0];\r\n\r\n    const tiles: Tile[] = [];\r\n\r\n    if (col0 !== undefined) {\r\n        const cell0 = col0[y0];\r\n        if (cell0 !== undefined) {\r\n            tiles.push(cell0);\r\n        }\r\n    }\r\n\r\n    const col1 = dungeon.tilesByCoordinates[x1];\r\n    if (col1 !== undefined) {\r\n        const cell1 = col1[y1];\r\n        if (cell1 !== undefined) {\r\n            tiles.push(cell1);\r\n        }\r\n    }\r\n\r\n    let steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n    if (steep) { // swap x & y, ensure not steep\r\n        let tmp = y0;\r\n        y0 = x0;\r\n        x0 = tmp;\r\n        tmp = y1;\r\n        y1 = x1;\r\n        x1 = tmp;\r\n    }\r\n    if (x0 > x1) { // swap 0 & 1, ensure moving rightwards\r\n        let tmp = x1;\r\n        x1 = x0;\r\n        x0 = tmp;\r\n        tmp = y1;\r\n        y1 = y0;\r\n        y0 = tmp;\r\n    }\r\n\r\n    let gradient = (y1 - y0) / (x1 - x0);\r\n    let y = y0 + gradient * 0.5; // move to the \"middle\" of the cell\r\n    for (let x = x0; x < x1; x++) {\r\n        let iY = Math.round(y - 0.5); // round to the nearest i+0.5, then truncate to int\r\n        let closestSideStep = iY + 0.5 > y ? -1 : 1;\r\n        let almostInteger = Math.abs(y - iY) < 0.10;\r\n\r\n        if (steep) {\r\n            tiles.push(dungeon.tilesByCoordinates[iY + closestSideStep][x]);\r\n            tiles.push(dungeon.tilesByCoordinates[iY][x]);\r\n            if (!almostInteger) {\r\n                tiles.push(dungeon.tilesByCoordinates[iY - closestSideStep][x]);\r\n            }\r\n        }\r\n        else {\r\n            tiles.push(dungeon.tilesByCoordinates[x][iY + closestSideStep]);\r\n            tiles.push(dungeon.tilesByCoordinates[x][iY]);\r\n            if (!almostInteger) {\r\n                tiles.push(dungeon.tilesByCoordinates[x][iY - closestSideStep]);\r\n            }\r\n        }\r\n\r\n        y += gradient;\r\n    }\r\n\r\n    return tiles;\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { Pathway } from '../../dungeon/model/Pathway';\r\nimport { getTouchedTiles } from '../../dungeon/generation/linkLinesToGrid';\r\nimport { Tile } from '../../dungeon/model/Tile';\r\n\r\ninterface Props {\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const Connections: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.FilterLinks, true, props.cellSize),\r\n            regionAlpha: 0.33,\r\n            drawWallsAsFloor: false,\r\n            linkWidth: cellSize * 0.5,\r\n            linkColor: '#0c0',\r\n            graphAlpha: 0.5,\r\n            minimumSpanningWidth: cellSize * 0.5,\r\n            relativeNeighbourhoodWidth: cellSize * 0.25,\r\n            gabrielWidth: cellSize * 0.125,\r\n            delauneyWidth: 1,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const linesByTile = getLinesByTile(dungeon); // I tried to memoise this, but it didn't work\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        const leftClick = (e: MouseEvent) => {\r\n            const cellX = e.offsetX / cellSize;\r\n            const cellY = e.offsetY / cellSize;\r\n\r\n            const cell = dungeon.getTileAt(cellX, cellY);\r\n            if (cell === undefined) {\r\n                return;\r\n            }\r\n\r\n            const line = linesByTile.get(cell);\r\n            if (line === undefined) {\r\n                return;\r\n            }\r\n\r\n            // add or remove this line\r\n            const index = dungeon.lines.indexOf(line);\r\n            if (index !== -1) {\r\n                dungeon.lines = [\r\n                    ...dungeon.lines.slice(0, index),\r\n                    ...dungeon.lines.slice(index + 1),\r\n                ];\r\n            }\r\n            else {\r\n                dungeon.lines = [\r\n                    ...dungeon.lines,\r\n                    line\r\n                ];\r\n            }\r\n            redraw();\r\n        };\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, dungeon.lines, linesByTile, redraw, cellSize]);\r\n\r\n    return <div className=\"menu__section\">\r\n        Left click the map to toggle a pathway on / off.\r\n    </div>\r\n}\r\n\r\nfunction getLinesByTile(dungeon: Dungeon) {\r\n    const allLines = new Map<Tile, Pathway[]>();\r\n    for (const line of dungeon.delauneyLines) {\r\n        const tiles = getTouchedTiles(line, dungeon);\r\n        for (const tile of tiles) {\r\n            let tileLines = allLines.get(tile);\r\n            if (tileLines === undefined) {\r\n                tileLines = [];\r\n                allLines.set(tile, tileLines);\r\n            }\r\n\r\n            tileLines.push(line);\r\n        }\r\n    }\r\n\r\n    const singleLineTiles = new Map<Tile, Pathway>();\r\n    for (const [tile, paths] of allLines) {\r\n        if (paths.length === 1) {\r\n            singleLineTiles.set(tile, paths[0]);\r\n        }\r\n    }\r\n\r\n    return singleLineTiles;\r\n}","import * as React from 'react';\r\nimport { FunctionComponent,  useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { AddRegions } from './AddRegions';\r\nimport { ResizeRegions } from './ResizeRegions';\r\nimport { RegionTypes } from './RegionTypes';\r\nimport { Connections } from './Connections';\r\nimport { GenerationSteps, allSteps } from '../../dungeon/GenerationSteps';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    regenerate: (steps: GenerationSteps[]) => void;\r\n}\r\n\r\nenum RegionMode {\r\n    AddRemove,\r\n    Resize,\r\n    ChangeType,\r\n    Connections,\r\n}\r\n\r\nexport const Regions: FunctionComponent<Props> = props => {\r\n    const [mode, setMode] = useState(RegionMode.AddRemove);\r\n\r\n    let subMenu: JSX.Element | undefined;\r\n\r\n    switch (mode) {\r\n        case RegionMode.AddRemove:\r\n            subMenu = <AddRegions\r\n                cellSize={props.cellSize}\r\n                dungeon={props.dungeon}\r\n                dungeonDisplay={props.dungeonDisplay}\r\n                setRenderSettings={props.setRenderSettings}\r\n                redraw={() => props.regenerate([GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n            />\r\n            break;\r\n        case RegionMode.Resize:\r\n            subMenu = <ResizeRegions\r\n                cellSize={props.cellSize}\r\n                dungeon={props.dungeon}\r\n                dungeonDisplay={props.dungeonDisplay}\r\n                setRenderSettings={props.setRenderSettings}\r\n                redraw={() => props.regenerate([GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n            />\r\n            break;\r\n        case RegionMode.ChangeType:\r\n            subMenu = <RegionTypes\r\n                cellSize={props.cellSize}\r\n                dungeon={props.dungeon}\r\n                dungeonDisplay={props.dungeonDisplay}\r\n                setRenderSettings={props.setRenderSettings}\r\n                redraw={() => props.regenerate([GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n            />\r\n            break;\r\n        case RegionMode.Connections:\r\n            subMenu = <Connections\r\n                cellSize={props.cellSize}\r\n                dungeon={props.dungeon}\r\n                dungeonDisplay={props.dungeonDisplay}\r\n                setRenderSettings={props.setRenderSettings}\r\n                redraw={() => props.regenerate([GenerationSteps.CreateTiles, GenerationSteps.AssociateTiles, ...allSteps.slice(5)])} // jump to ExpandLines\r\n            />\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === RegionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.AddRemove)}>Add/remove regions</li>\r\n            <li className={mode === RegionMode.Resize ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.Resize)}>Resize regions</li>\r\n            <li className={mode === RegionMode.ChangeType ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.ChangeType)}>Change region types</li>\r\n            <li className={mode === RegionMode.Connections ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.Connections)}>Add/remove paths</li>\r\n        </ul>\r\n\r\n        {subMenu}\r\n    </div>\r\n}","import * as React from 'react';\r\nimport './Menu.css';\r\nimport { FunctionComponent, useState, useMemo } from 'react';\r\nimport { Generate } from './Generate';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { MapSize } from './MapSize';\r\nimport { GenerationSteps, allSteps } from '../../dungeon/GenerationSteps';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { Regions } from './Regions';\r\nimport { IRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\ninterface Props {\r\n    isGenerating: boolean;\r\n    dungeon: Dungeon;\r\n    canvas?: HTMLCanvasElement;\r\n    cellSize: number;\r\n    generationSettings: Readonly<IGenerationSettings>;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    generate: () => Promise<void>;\r\n    regenerate: (animate: boolean, steps: GenerationSteps[]) => Promise<void>;\r\n    skip: () => void;\r\n    finish: () => void;\r\n}\r\n\r\nenum MenuPage {\r\n    Main,\r\n    Size,\r\n    Regions,\r\n    Renders,\r\n}\r\n\r\nexport const Menu: FunctionComponent<Props> = props => {\r\n    const [currentPage, setCurrentPage] = useState(MenuPage.Main);\r\n\r\n    const switchToMain = useMemo(() => () => setCurrentPage(MenuPage.Main), []);\r\n    const switchToSize = useMemo(() => () => setCurrentPage(MenuPage.Size), []);\r\n    const switchToRegions = useMemo(() => () => setCurrentPage(MenuPage.Regions), []);\r\n    const switchToRenders = useMemo(() => () => setCurrentPage(MenuPage.Renders), []);\r\n    \r\n    const { regenerate } = props;\r\n\r\n    const animate = useMemo(() => (() => regenerate(true, [GenerationSteps.CreateTiles, ...allSteps.slice(2)])), [regenerate]);\r\n\r\n    switch (currentPage) {\r\n        case MenuPage.Size:\r\n            return (\r\n                <MapSize\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    generationSettings={props.generationSettings}\r\n                    setGenerationSettings={props.setGenerationSettings}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, [GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n                />\r\n            );\r\n        case MenuPage.Regions:\r\n            return (\r\n                <Regions\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    regenerate={steps => props.regenerate(false, steps)}\r\n                />\r\n            );\r\n\r\n        // TODO: other pages\r\n\r\n        default:\r\n            return (\r\n                <Generate\r\n                    isGenerating={props.isGenerating}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    cellSize={props.cellSize}\r\n                    generate={props.generate}\r\n                    animate={animate}\r\n                    skip={props.skip}\r\n                    finish={props.finish}\r\n\r\n                    showSize={switchToSize}\r\n                    showRegions={switchToRegions}\r\n                    showRenders={switchToRenders}\r\n                />\r\n            );\r\n    }\r\n};","import * as React from 'react';\r\n\r\ninterface FixedProps {\r\n    width: number;\r\n    height: number;\r\n    className?: string;\r\n}\r\n\r\nexport class FixedCanvas extends React.Component<FixedProps, {}> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    public canvas?: HTMLCanvasElement;\r\n\r\n    constructor(props: FixedProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: props.width === undefined ? 0 : props.width,\r\n            height: props.height === undefined ? 0 : props.height,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.props.width}\r\n                    height={this.props.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    componentDidMount() {\r\n        this.updateCtx();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        const ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n}\r\n\r\ninterface ResponsiveProps {\r\n    className?: string;\r\n    sizeChanged?: (width: number, height: number) => void;\r\n}\r\n\r\ninterface ResponsiveState {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport class ResponsiveCanvas extends React.Component<ResponsiveProps, ResponsiveState> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    private canvas?: HTMLCanvasElement;\r\n    private resizeListener?: () => void;\r\n\r\n    constructor(props: ResponsiveProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.state.width}\r\n                    height={this.state.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateCtx();\r\n\r\n        this.resizeListener = () => this.updateSize();\r\n        window.addEventListener('resize', this.resizeListener);\r\n    \r\n        this.updateSize();\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        if (this.resizeListener !== undefined) {\r\n            window.removeEventListener('resize', this.resizeListener);\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    updateSize() {\r\n        if (this.root === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let scrollSize = this.getScrollbarSize();\r\n        let width = this.root.offsetWidth - scrollSize.width;\r\n        let height = this.root.offsetHeight - scrollSize.height;\r\n\r\n        this.setState({\r\n            width: width,\r\n            height: height,\r\n        });\r\n\r\n        if (this.props.sizeChanged !== undefined) {\r\n            this.props.sizeChanged(width, height);\r\n        }\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n\r\n    private getScrollbarSize() {\r\n        let outer = document.createElement('div');\r\n        outer.style.visibility = 'hidden';\r\n        outer.style.width = '100px';\r\n        outer.style.height = '100px';\r\n        outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\r\n\r\n        document.body.appendChild(outer);\r\n\r\n        let widthNoScroll = outer.offsetWidth;\r\n        let heightNoScroll = outer.offsetHeight;\r\n\r\n        // force scrollbars\r\n        outer.style.overflow = 'scroll';\r\n\r\n        // add innerdiv\r\n        let inner = document.createElement('div');\r\n        inner.style.width = '100%';\r\n        inner.style.height = '100%';\r\n        outer.appendChild(inner);\r\n\r\n        let widthWithScroll = inner.offsetWidth;\r\n        let heightWithScroll = inner.offsetHeight;\r\n\r\n        // remove divs\r\n        (outer.parentNode as HTMLElement).removeChild(outer);\r\n\r\n        return {\r\n            width: widthNoScroll - widthWithScroll,\r\n            height: heightNoScroll - heightWithScroll,\r\n        };\r\n    }\r\n}","import { Pathway } from './Pathway';\r\nimport { Region } from './Region';\r\nimport { Tile } from './Tile';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { Hatching } from './Hatching';\r\n\r\nexport class Dungeon implements IGraph<Region, Pathway> {\r\n    nodes: Region[] = [];\r\n    lines: Pathway[] = [];\r\n    backdropPoints: Hatching[] = [];\r\n    delauneyLines: Pathway[] = [];\r\n    gabrielLines: Pathway[] = [];\r\n    relativeNeighbourhoodLines: Pathway[] = [];\r\n    minimumSpanningLines: Pathway[] = [];\r\n\r\n    width: number = 0;\r\n    height: number = 0;\r\n\r\n    tiles: Tile[] = [];\r\n    tilesByCoordinates: Tile[][] = [];\r\n    walls: Curve[] = [];\r\n\r\n    public getTileAt(x: number, y: number) {\r\n        const col = this.tilesByCoordinates[Math.floor(x)];\r\n\r\n        if (col === undefined) {\r\n            return;\r\n        }\r\n\r\n        return col[Math.floor(y)];\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { Pathway } from './model/Pathway';\r\nimport { Region } from './model/Region';\r\nimport { Tile } from './model/Tile';\r\nimport { Curve } from '../lib/model/Curve';\r\nimport { IRenderSettings } from './IRenderSettings';\r\n\r\nexport function renderDungeon(   \r\n    dungeon: Dungeon,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n) {\r\n    ctx.clearRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n\r\n    if (settings.drawGrid) {\r\n        drawTileGrid(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.graphAlpha > 0) {\r\n        drawGraph(ctx, dungeon, settings);\r\n    }\r\n    \r\n    if (settings.drawOutside) {\r\n        fillOutside(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawOutsidePoints) {\r\n        drawOutsidePoints(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawWalls) {\r\n        ctx.strokeStyle = ctx.fillStyle = settings.highlightWallCurves ? '#f00' : '#000';\r\n        ctx.lineCap = 'round';\r\n        for (const curve of dungeon.walls) {\r\n            drawCurve(curve, ctx, settings);\r\n        }\r\n        ctx.lineCap = 'butt';\r\n    }\r\n    \r\n    if (settings.drawNodeLinks) {\r\n        ctx.lineWidth = settings.linkWidth;\r\n        ctx.strokeStyle = settings.linkColor;\r\n        for (let line of dungeon.lines) {\r\n            drawPath(line, ctx, settings);\r\n        }\r\n    }\r\n\r\n    if (settings.nodeAlpha > 0) {\r\n        ctx.globalAlpha = settings.nodeAlpha;\r\n        for (let i = 0; i < dungeon.nodes.length; i++) {\r\n            drawNode(dungeon.nodes[i], ctx, settings);\r\n        }\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawTileGrid(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.lineWidth = settings.floorGridWidth;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        drawTile(tile, ctx, settings);\r\n    }\r\n}\r\n\r\nfunction drawPath(pathway: Pathway, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(pathway.from.x * settings.cellSize, pathway.from.y * settings.cellSize);\r\n    ctx.lineTo(pathway.to.x * settings.cellSize, pathway.to.y * settings.cellSize);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction drawNode(room: Region, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.fillStyle = '#c00';\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(room.x * settings.cellSize, room.y * settings.cellSize, settings.cellSize * room.radius, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n}\r\n\r\nfunction drawTile(tile: Tile, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    if (tile.isFloor && (!tile.isWall || settings.drawWallsAsFloor)) {\r\n        ctx.fillStyle = settings.floorColor;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.strokeStyle = settings.floorGridColor;\r\n        ctx.strokeRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n    else if (tile.isWall) {\r\n        ctx.fillStyle = '#333';\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n\r\n    if (settings.regionAlpha > 0 && tile.region !== null) {\r\n        ctx.globalAlpha = settings.regionAlpha;\r\n        ctx.fillStyle = tile.region.color;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.globalAlpha = settings.graphAlpha;\r\n    ctx.strokeStyle = '#000';\r\n\r\n    ctx.lineWidth = settings.minimumSpanningWidth;\r\n    for (let line of dungeon.minimumSpanningLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.relativeNeighbourhoodWidth;\r\n    for (let line of dungeon.relativeNeighbourhoodLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.gabrielWidth;\r\n    for (let line of dungeon.gabrielLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.delauneyWidth;\r\n    for (let line of dungeon.delauneyLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.globalAlpha = 1;\r\n}\r\n\r\nfunction drawCurve(\r\n    curve: Curve,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n    draw: boolean = true\r\n) {\r\n    let halfCellSize = settings.cellSize / 2;\r\n\r\n    if (curve.keyPoints.length === 1) {\r\n        if (draw) {\r\n            let cell = curve.keyPoints[0];\r\n            let cx = cell.x * settings.cellSize + halfCellSize;\r\n            let cy = cell.y * settings.cellSize + halfCellSize;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy, settings.wallWidth / 2, 0, Math.PI * 2);\r\n        \r\n            ctx.fill();\r\n        }\r\n        return;\r\n    }\r\n    \r\n    let points = curve.renderPoints;\r\n    let x = points[0] * settings.cellSize + halfCellSize;\r\n    let y = points[1] * settings.cellSize + halfCellSize;\r\n    \r\n    if (draw) {\r\n        ctx.beginPath();\r\n    }\r\n    ctx.moveTo(x, y);\r\n    \r\n    ctx.lineWidth = settings.wallWidth;\r\n    for (let i = 0; i < points.length; i += 2) {\r\n        x = points[i] * settings.cellSize + halfCellSize;\r\n        y = points[i + 1] * settings.cellSize + halfCellSize;\r\n        ctx.lineTo(x, y);\r\n    }\r\n\r\n    if (draw) {\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nfunction clipOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    for (let curve of dungeon.walls) {\r\n        drawCurve(curve, ctx, settings, false);\r\n    }\r\n    ctx.clip('evenodd');\r\n}\r\n\r\nfunction fillOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.fillStyle = settings.backgroundColor;\r\n\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.fillRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    \r\n    ctx.strokeStyle = settings.hatchingColor;\r\n    ctx.lineWidth = settings.hatchingWidth;\r\n\r\n    const xScale = settings.cellSize * 0.6;\r\n    for (const point of dungeon.backdropPoints) {\r\n        const yScale = settings.cellSize * point.lengthScale;\r\n        \r\n        ctx.save();\r\n\r\n        ctx.translate(point.x * settings.cellSize, point.y * settings.cellSize);\r\n        ctx.rotate(point.rotation);\r\n\r\n        // first clear the background of this segment\r\n        ctx.beginPath();\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n        ctx.fill();\r\n\r\n        // then draw the lines\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.moveTo(0, -yScale);\r\n        ctx.lineTo(0, yScale);\r\n\r\n        ctx.moveTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction drawOutsidePoints(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.globalAlpha = 0.75;\r\n    ctx.fillStyle = '#009';\r\n\r\n    for (const point of dungeon.backdropPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(point.x * settings.cellSize, point.y * settings.cellSize, settings.cellSize * 0.25, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n}","// based on http://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/lib/alea.js\r\n\r\nexport class SRandom {\r\n    private c: number;\r\n    private s0: number;\r\n    private s1: number;\r\n    private s2: number;\r\n\r\n    constructor(public readonly seed: number | string) {\r\n        var mash = this.mash();\r\n\r\n        this.c = 1;\r\n        this.s0 = mash(' ');\r\n        this.s1 = mash(' ');\r\n        this.s2 = mash(' ');\r\n\r\n        this.s0 -= mash(seed);\r\n        if (this.s0 < 0) {\r\n            this.s0 += 1;\r\n        }\r\n\r\n        this.s1 -= mash(seed);\r\n        if (this.s1 < 0) {\r\n            this.s1 += 1;\r\n        }\r\n\r\n        this.s2 -= mash(seed);\r\n        if (this.s2 < 0) {\r\n            this.s2 += 1;\r\n        }\r\n    }\r\n\r\n    next() {\r\n        let t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        return this.s2 = t - (this.c = t | 0);\r\n    }\r\n    \r\n    nextInt32() {\r\n        return (this.next() * 0x100000000) | 0;\r\n    }\r\n\r\n    nextInRange(min: number, max: number) {\r\n        return min + this.next() * (max - min);\r\n    }\r\n\r\n    nextIntInRange(minInclusive: number, maxExclusive: number) {\r\n        return Math.floor(this.nextInRange(minInclusive, maxExclusive));\r\n    }\r\n\r\n    nextColor() {\r\n        const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n        const r = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const g = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const b = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        return `#${r}${g}${b}`;\r\n    }\r\n\r\n    private mash() {\r\n        let n = 0xefc8249d;\r\n\r\n        let mash = function(data: number | string) {\r\n            data = data.toString();\r\n            for (var i = 0; i < data.length; i++) {\r\n                n += data.charCodeAt(i);\r\n                var h = 0.02519603282416938 * n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                h *= n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                n += h * 0x100000000; // 2^32\r\n            }\r\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\r\n        };\r\n\r\n        return mash;\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\nimport { Line } from '../../lib/model/Line';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function createRegions(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // Remove all nodes, then create nodeCount nodes. Using same seed ensures same ones are recreated.\r\n    const random = new SRandom(seed);\r\n\r\n    let makeNode = () => {\r\n        const x = random.nextInRange(3, dungeon.width - 4);\r\n        const y = random.nextInRange(3, dungeon.height - 4);\r\n        const influence = random.nextInRange(0.6, 1.8);\r\n        const regionType = random.nextIntInRange(0, RegionType.NUM_VALUES);\r\n        const seed = random.next();\r\n        const color = random.nextColor();\r\n        return new Region(dungeon, x, y, seed, regionType, color, influence);\r\n    };\r\n\r\n    dungeon.nodes = [];\r\n    for (let i = 0; i < settings.nodeCount; i++) {\r\n        addSpacedNode(dungeon, makeNode, dungeon.width, dungeon.height);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n}\r\n\r\nfunction addSpacedNode<TNode extends Coord2D, TLine extends Line<TNode>>(\r\n    dungeon: IGraph<TNode, TLine>,\r\n    makeNode: () => TNode,\r\n    totWidth: number,\r\n    totHeight: number\r\n) {\r\n    const getScaledDistSq = (n1: TNode, n2: TNode, width: number, height: number) => {\r\n        let dxScaled = (n1.x - n2.x) / width;\r\n        let dyScaled = (n1.y - n2.y) / height;\r\n        return dxScaled * dxScaled + dyScaled * dyScaled;\r\n    };\r\n\r\n    // create two nodes, and go with the one that's furthest away from the nearest node\r\n    let node1 = makeNode(), node2 = makeNode();\r\n    let closestDist1 = Number.MAX_VALUE, closestDist2 = Number.MAX_VALUE;\r\n    for (let node of dungeon.nodes) {\r\n        // scale x/y distances, so width/height changes don't change which node is chosen during regeneration\r\n        closestDist1 = Math.min(closestDist1, getScaledDistSq(node1, node, totWidth, totHeight));\r\n        closestDist2 = Math.min(closestDist2, getScaledDistSq(node2, node, totWidth, totHeight));\r\n    }\r\n\r\n    dungeon.nodes.push(closestDist1 < closestDist2 ? node2 : node1);\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Polygon<TNode extends Coord<TNode>> {\r\n    constructor(readonly vertices: TNode[]) {\r\n        \r\n    }\r\n}","import { Coord } from './Coord';\r\nimport { Polygon } from './Polygon';\r\n\r\nexport class Triangle<TNode extends Coord<TNode>> extends Polygon<TNode> {\r\n    circumCenter: Coord<TNode>;\r\n    circumRadiusSq: number;\r\n\r\n    constructor(vertices: [TNode, TNode, TNode]) {\r\n        super(vertices);\r\n\r\n        let circumCircle = vertices[0].circumCircle(vertices[1], vertices[2]);\r\n\r\n        this.circumCenter = circumCircle[0];\r\n        this.circumRadiusSq = circumCircle[1];\r\n    }\r\n}","import { Coord } from '../model/Coord';\r\nimport { Triangle } from '../model/Triangle';\r\n\r\nexport function computeDelauneyTriangulation<TNode extends Coord<TNode>>(\r\n    nodes: TNode[],\r\n    superTriangle: [TNode, TNode, TNode]\r\n) {\r\n    if (nodes.length < 3) {\r\n        return [];\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm\r\n    let triangulation: Triangle<TNode>[] = [];\r\n    triangulation.push(new Triangle(superTriangle));\r\n\r\n    for (let node of nodes) {\r\n        // find all triangles that are no longer valid due to this node's insertion\r\n        let badTriangles: Triangle<TNode>[] = [];\r\n        for (let triangle of triangulation) {\r\n            if (insideCircumcircle(node, triangle)) {\r\n                badTriangles.push(triangle);\r\n            }\r\n        }\r\n\r\n        // Find the boundary of polygonal hole formed by these \"bad\" triangles...\r\n        // Get the edges of the \"bad\" triangles which don't touch other bad triangles...\r\n        // Each pair of nodes here represents a line.\r\n        let polygon: TNode[] = [];\r\n        for (let triangle of badTriangles) {\r\n            for (let i = 0; i < 3; i++) {\r\n                let edgeFrom = triangle.vertices[i];\r\n                let edgeTo = triangle.vertices[i === 2 ? 0 : i + 1];\r\n\r\n                let sharedWithOther = false;\r\n                for (let other of badTriangles) {\r\n                    if (other === triangle) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeFrom) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeTo) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    sharedWithOther = true;\r\n                    break;\r\n                }\r\n\r\n                if (!sharedWithOther) {\r\n                    polygon.push(edgeFrom, edgeTo);\r\n                }\r\n            }\r\n        }\r\n\r\n        // discard all bad triangles\r\n        for (let triangle of badTriangles) {\r\n            triangulation.splice(triangulation.indexOf(triangle), 1);\r\n        }\r\n\r\n        // re-triangulate the polygonal hole ... create a new triangle for each edge\r\n        for (let i = 0; i < polygon.length - 1; i += 2) {\r\n            let triangle = new Triangle<TNode>([polygon[i], polygon[i + 1], node]);\r\n            triangulation.push(triangle);\r\n        }\r\n    }\r\n\r\n    // remove all triangles that contain a vertex from the original super-triangle\r\n    for (let i = 0; i < triangulation.length; i++) {\r\n        let triangle = triangulation[i];\r\n        for (let vertex of triangle.vertices) {\r\n            if (superTriangle.indexOf(vertex) !== -1) {\r\n                triangulation.splice(i, 1);\r\n                i--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return triangulation;\r\n}\r\n\r\nfunction insideCircumcircle<TNode extends Coord<TNode>>(\r\n    point: TNode,\r\n    triangle: Triangle<TNode>\r\n) {\r\n    let distSq = point.distanceSqTo(triangle.circumCenter);\r\n    return distSq <= triangle.circumRadiusSq;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeGabrielGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n\r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let center = link.from.halfwayTo(link.to);\r\n        let radiusSq = link.from.distanceSqTo(center);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(center) < radiusSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}","import { Coord } from '../model/Coord';\r\nimport { Line } from '../model/Line';\r\nimport { Polygon } from '../model/Polygon';\r\n\r\nexport function getUniqueLines<TNode extends Coord<TNode>, TLine extends Line<TNode>>\r\n(\r\n    polygons: Polygon<TNode>[], \r\n    createLine: (from: TNode, to: TNode) => TLine\r\n) {\r\n    const allLines: TLine[] = [];\r\n\r\n    // Convert polygons to UNIQUE lines, ignoring their direction.\r\n    for (const polygon of polygons) {\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            const v0 = polygon.vertices[i === 0 ? polygon.vertices.length - 1 : i - 1];\r\n            const v1 = polygon.vertices[i];\r\n\r\n            const isDuplicate = allLines.some(l => (l.from === v0 && l.to === v1) || (l.from === v1 && l.to === v0));\r\n            if (!isDuplicate) {\r\n                allLines.push(createLine(v0, v1));\r\n            }\r\n        }\r\n    }\r\n\r\n    return allLines;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeMinimumSpanningTree<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let unvisitedNodes = graph.nodes.slice();\r\n    let firstNode = unvisitedNodes.pop();\r\n    if (firstNode === undefined) {\r\n        return [];\r\n    }\r\n    \r\n    let possibleLinks = links.map(l => ({ link: l, lengthSq: l.from.distanceSqTo(l.to) }));\r\n    possibleLinks.sort((a, b) => a.lengthSq - b.lengthSq);\r\n\r\n    let visitedNodes: TNode[] = [firstNode];\r\n    let graphLinks: TLine[] = [];\r\n\r\n    while (unvisitedNodes.length > 0 && possibleLinks.length > 0) {\r\n        // Find the first link that connects to a node in visitedNodes...\r\n        // The links are sorted by length, so the first one will be the shortest one.\r\n        for (let i = 0; i < possibleLinks.length; i++) {\r\n            let testLink = possibleLinks[i].link;\r\n            \r\n            let alreadyHasFrom = visitedNodes.indexOf(testLink.from) !== -1;\r\n            let alreadyHasTo = visitedNodes.indexOf(testLink.to) !== -1;\r\n\r\n            // if it doesn't connect to the graph at all, discard it\r\n            if (!alreadyHasFrom && !alreadyHasTo) {\r\n                continue;\r\n            }\r\n\r\n            possibleLinks.splice(i, 1);\r\n            graphLinks.push(testLink);\r\n\r\n            let addingNode = alreadyHasFrom ? testLink.to : testLink.from;\r\n            \r\n            // remove all other links from possibleLinks that connect addingNode to visitedNodes\r\n            for (let j = i; j < possibleLinks.length; j++) {\r\n                testLink = possibleLinks[j].link;\r\n                if ((testLink.from === addingNode && visitedNodes.indexOf(testLink.to) !== -1)\r\n                || (testLink.to === addingNode && visitedNodes.indexOf(testLink.from) !== -1)) {\r\n                    possibleLinks.splice(j, 1);\r\n                    j--;\r\n                }\r\n            }\r\n\r\n            visitedNodes.push(addingNode);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeRelativeNeighbourhoodGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>, \r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n    \r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let lengthSq = link.from.distanceSqTo(link.to);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(link.from) < lengthSq && node.distanceSqTo(link.to) < lengthSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Line } from '../../lib/model/Line';\r\nimport { Region } from './Region';\r\n\r\nexport class Pathway extends Line<Region> {\r\n    constructor(from: Region, to: Region) {\r\n        super(from, to);\r\n\r\n        from.links.push(this);\r\n        to.links.push(this);\r\n    }\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Line<TCoord extends Coord<TCoord>> {\r\n    constructor(public from: TCoord, public to: TCoord) {\r\n\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport {\r\n    computeDelauneyTriangulation,\r\n    getUniqueLines,\r\n    computeGabrielGraph,\r\n    computeRelativeNeighbourhoodGraph,\r\n    computeMinimumSpanningTree\r\n} from '../../lib/graph';\r\nimport { Pathway } from '../model/Pathway';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function populateLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.lines = [];\r\n    dungeon.delauneyLines = [];\r\n    dungeon.gabrielLines = [];\r\n    dungeon.relativeNeighbourhoodLines = [];\r\n    dungeon.minimumSpanningLines = [];\r\n\r\n    const enclosingTriangle: [Region, Region, Region] = [\r\n        new Region(dungeon, 0, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 999999, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 0, 999999, 0, RegionType.Artificial, ''),\r\n    ];\r\n\r\n    const delauneyTriangles = computeDelauneyTriangulation(dungeon.nodes, enclosingTriangle);\r\n    \r\n    dungeon.delauneyLines = getUniqueLines(delauneyTriangles, (from, to) => new Pathway(from, to));\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.gabrielLines = computeGabrielGraph(dungeon, dungeon.delauneyLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.relativeNeighbourhoodLines = computeRelativeNeighbourhoodGraph(dungeon, dungeon.gabrielLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.minimumSpanningLines = computeMinimumSpanningTree(dungeon, dungeon.relativeNeighbourhoodLines);\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function filterLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let selectingFrom: Pathway[];\r\n    let selectFraction: number;\r\n        \r\n    if (settings.connectivity < 50) {\r\n        dungeon.lines = dungeon.minimumSpanningLines.slice();\r\n\r\n        selectingFrom = dungeon.relativeNeighbourhoodLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = settings.connectivity / 50;\r\n    } else {\r\n        dungeon.lines = dungeon.relativeNeighbourhoodLines.slice();\r\n\r\n        selectingFrom = dungeon.gabrielLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = (settings.connectivity - 50) / 50;\r\n    }\r\n    \r\n    let random = new SRandom(seed);\r\n    let numToSelect = Math.round(selectingFrom.length * selectFraction);\r\n\r\n    for (let i = numToSelect; i > 0; i--) {\r\n        let selectedLink = selectingFrom.splice(random.nextIntInRange(0, selectingFrom.length), 1)[0];\r\n        dungeon.lines.push(selectedLink);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function populateCaveRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    \r\n    const regionTiles = dungeon.tiles.filter(t => t.region === region);\r\n    const nonEdgeTiles = regionTiles.filter(t => t.adjacentTiles.length === 8 && !t.adjacentTiles.some(a => a.region !== region));\r\n    \r\n    const mutableTiles = nonEdgeTiles.filter(t => !t.isFloor);\r\n\r\n    // make half the non-edge cells \"alive\"\r\n    for (const tile of nonEdgeTiles) {\r\n        if (random.next() < 0.5) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < 8; i++) {\r\n        runCellularAutomataStep(mutableTiles);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n\r\n    removeUnconnectedFloorTiles(dungeon, region, nonEdgeTiles);\r\n}\r\n\r\nfunction runCellularAutomataStep(cells: Tile[]) {\r\n    const results = new Map<Tile, boolean>();\r\n\r\n    for (const cell of cells) {\r\n        // alive becomes dead if < 4 alive around it\r\n        // dead becomes alive if > 4 alive around it\r\n\r\n        const wasAlive = cell.isFloor;\r\n        const numAdjacentLiving = cell.adjacentTiles.filter(t => t.isFloor).length;\r\n\r\n        const shouldLive = wasAlive\r\n            ? numAdjacentLiving >= 4\r\n            : numAdjacentLiving > 4\r\n\r\n        results.set(cell, shouldLive);\r\n    }\r\n\r\n    for (const [cell, result] of results) {\r\n        cell.isFloor = result;\r\n    }\r\n}\r\n\r\nfunction removeUnconnectedFloorTiles(dungeon: Dungeon, region: Region, regionTiles: Tile[]) {    \r\n    const rootTile = dungeon.tilesByCoordinates[Math.floor(region.x)][Math.floor(region.y)];\r\n    \r\n    const connectedTiles = new Set([rootTile]);\r\n    let tilesToTest = [...rootTile.adjacentTiles];\r\n\r\n    while (true) {\r\n        const tile = tilesToTest.pop();\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        if (!tile.isFloor || tile.region !== region || connectedTiles.has(tile)) {\r\n            continue;\r\n        }\r\n\r\n        connectedTiles.add(tile);\r\n\r\n        tilesToTest = [\r\n            ...tilesToTest,\r\n            ...tile.adjacentTiles,\r\n        ];\r\n    }\r\n\r\n    for (const tile of regionTiles) {\r\n        if (tile.isFloor && !connectedTiles.has(tile)) {\r\n            tile.isFloor = false;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\n\r\nexport async function populateRoomRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    const nodeX = Math.floor(region.x);\r\n    const nodeY = Math.floor(region.y);\r\n\r\n    const { minX, minY, maxX, maxY } = determineBounds(dungeon, region, nodeX, nodeY, random);\r\n\r\n    for (let x = minX; x <= maxX; x++) {\r\n        for (let y = minY; y <= maxY; y++) {\r\n            let tile = dungeon.tilesByCoordinates[x][y];\r\n            if (tile.region !== region) {\r\n                continue;\r\n            }\r\n\r\n            tile.isFloor = true;\r\n            tile.region = region;\r\n        }\r\n    }\r\n}\r\n\r\nfunction determineBounds(dungeon: Dungeon, region: Region, nodeX: number, nodeY: number, random: SRandom) {\r\n    // determine the biggest possible size this room could be\r\n    let minX = nodeX, maxX = nodeX, minY = nodeY, maxY = nodeY;\r\n\r\n    if (random.next() < 0.5) {\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n    else {\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    // now possibly shrink from the maximum possible size\r\n    if (random.next() < 0.75) {\r\n        minX = random.nextIntInRange(minX, nodeX);\r\n        maxX = random.nextIntInRange(nodeX + 1, maxX + 1);\r\n        minY = random.nextIntInRange(minY, nodeY);\r\n        maxY = random.nextIntInRange(nodeY + 1, maxY + 1);    \r\n    }\r\n\r\n    return {\r\n        minX,\r\n        minY,\r\n        maxX,\r\n        maxY,\r\n    };\r\n}\r\n\r\nfunction growUpLeft(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canLeft = true, canUp = true;\r\n\r\n    while (canLeft || canUp) {\r\n        if (canUp && random.next() < 0.5) {\r\n            canUp = isRowInRegion(dungeon, region, minY - 1, minX, maxX)\r\n                && --minY > 2;\r\n        }\r\n        else if (canLeft) {\r\n            canLeft = isColInRegion(dungeon, region, minX - 1, minY, maxY)\r\n                && --minX > 2;\r\n        }\r\n    }\r\n\r\n    return [minX, minY];\r\n}\r\n\r\n\r\nfunction growDownRight(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canRight = true, canDown = true;\r\n\r\n    while (canRight || canDown) {\r\n        if (canDown && random.next() < 0.5) {\r\n            canDown = isRowInRegion(dungeon, region, maxY + 1, minX, maxX)\r\n                && ++maxY < dungeon.height - 3;\r\n        }\r\n        else if (canRight) {\r\n            canRight = isColInRegion(dungeon, region, maxX + 1, minY, maxY)\r\n                && ++maxX < dungeon.width - 3;\r\n        }\r\n    }\r\n\r\n    return [maxX, maxY];\r\n}\r\n\r\nfunction isColInRegion(dungeon: Dungeon, region: Region, x: number, y1: number, y2: number) {\r\n    const col = dungeon.tilesByCoordinates[x];\r\n\r\n    for (let y = y1; y <= y2; y++) {\r\n        if (col[y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isRowInRegion(dungeon: Dungeon, region: Region, y: number, x1: number, x2: number) {\r\n    for (let x = x1; x <= x2; x++) {\r\n        if (dungeon.tilesByCoordinates[x][y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { RegionType } from '../model/Region';\r\nimport { populateCaveRegion } from './populateCaveRegion';\r\nimport { populateRoomRegion } from './populateRoomRegion';\r\n\r\nexport async function createRooms(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const region of dungeon.nodes) {\r\n        switch (region.regionType) {\r\n            case RegionType.Natural:\r\n                await populateCaveRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            case RegionType.Artificial:\r\n                await populateRoomRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { RegionType } from '../model/Region';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function detectWalls(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isFloor) {\r\n            continue;\r\n        }\r\n\r\n        let toTest = getAdjacent(dungeon, tile, true, false);\r\n        for (let test of toTest) {\r\n            if (test.isFloor) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // artificial rooms should have \"corner\" wall nodes filled in\r\n        for (let test of tile.adjacentTiles) {\r\n            if (test.isFloor && test.region !== null && test.region.regionType === RegionType.Artificial) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Tiny);\r\n        }\r\n    }\r\n}\r\n\r\nexport function getAdjacent(dungeon: Dungeon, from: Tile, orthogonal: boolean = true, diagonal: boolean = false) {\r\n    let results = [];\r\n\r\n    if (orthogonal) {\r\n        if (from.x > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x - 1][from.y]);\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x + 1][from.y]);\r\n        }\r\n        if (from.y > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y - 1]);\r\n        }\r\n        if (from.y < dungeon.height - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y + 1]);\r\n        }\r\n    }\r\n    \r\n    if (diagonal) {\r\n        if (from.x > 0) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y + 1]);\r\n            }\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y + 1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n","import { Coord2D } from './Coord';\r\n\r\nexport class Curve {\r\n    static readonly stepsPerSegment = 16;\r\n\r\n    keyPoints: Coord2D[];\r\n    isLoop: boolean;\r\n    renderPoints: number[];\r\n\r\n    constructor(public curvature: number = 0.75) {\r\n        this.keyPoints = [];\r\n        this.isLoop = false;\r\n        this.renderPoints = [];\r\n    }\r\n\r\n    updateRenderPoints() {\r\n        this.renderPoints = [];\r\n\r\n        if (this.keyPoints.length < 2) {\r\n            return;\r\n        }\r\n\r\n        let tension = this.curvature;\r\n        let pts: number[] = [],\r\n            x: number, y: number,\r\n            t1x: number, t2x: number, t1y: number, t2y: number,\r\n            c1: number, c2: number, c3: number, c4: number,\r\n            fraction: number, step: number, iPt: number;\r\n\r\n        let firstCell = this.keyPoints[0];\r\n        let lastCell = this.keyPoints[this.keyPoints.length - 1];\r\n\r\n        // decide if it's a closed loop, which needs the ends of the array set up differently\r\n        let lastCellIndex: number;\r\n        if (firstCell === lastCell) {\r\n            lastCellIndex = this.keyPoints.length - 2; // don't copy the last cell, its the same as the first\r\n            lastCell = this.keyPoints[lastCellIndex];\r\n        } else {\r\n            lastCellIndex = this.keyPoints.length - 1;\r\n        }\r\n        \r\n        for (let cell of this.keyPoints) {\r\n            pts.push(cell.x, cell.y);\r\n        }\r\n        \r\n        if (this.isLoop) {\r\n            // copy last cell onto start, and first cells onto end\r\n            let secondCell = this.keyPoints[1];\r\n            pts.push(firstCell.x, firstCell.y);\r\n            pts.push(secondCell.x, secondCell.y);\r\n            pts.unshift(lastCell.x, lastCell.y);\r\n        } else {\r\n            // copy first cell onto start, and last cell onto end\r\n            pts.unshift(firstCell.x, firstCell.y);\r\n            pts.push(lastCell.x, lastCell.y);\r\n        }\r\n\r\n        // loop through key points. Use each set of 4 points p0 p1 p2 p3 to draw segment p1-p2.\r\n        for (iPt = 2; iPt < (pts.length - 4); iPt += 2) {\r\n            for (step = 0; step <= Curve.stepsPerSegment; step++) {\r\n                // tension vectors\r\n                t1x = (pts[iPt + 2] - pts[iPt - 2]) * tension;\r\n                t2x = (pts[iPt + 4] - pts[iPt]) * tension;\r\n\r\n                t1y = (pts[iPt + 3] - pts[iPt - 1]) * tension;\r\n                t2y = (pts[iPt + 5] - pts[iPt + 1]) * tension;\r\n\r\n                fraction = step / Curve.stepsPerSegment;\r\n\r\n                // cardinals\r\n                c1 =   2 * Math.pow(fraction, 3)  - 3 * Math.pow(fraction, 2) + 1; \r\n                c2 = -(2 * Math.pow(fraction, 3)) + 3 * Math.pow(fraction, 2); \r\n                c3 =       Math.pow(fraction, 3)  - 2 * Math.pow(fraction, 2) + fraction; \r\n                c4 =       Math.pow(fraction, 3)  -     Math.pow(fraction, 2);\r\n\r\n                // x and y coordinates\r\n                x = c1 * pts[iPt]    + c2 * pts[iPt + 2] + c3 * t1x + c4 * t2x;\r\n                y = c1 * pts[iPt + 1]  + c2 * pts[iPt + 3] + c3 * t1y + c4 * t2y;\r\n                this.renderPoints.push(x);\r\n                this.renderPoints.push(y);\r\n            }\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { getAdjacent } from './detectWalls';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function generateWallCurves(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.walls = [];\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isWall && !tile.isFloor) {\r\n            await generateWallCurve(dungeon, tile, true, subStepComplete);\r\n\r\n            if (subStepComplete) {\r\n                await subStepComplete(DelaySize.Medium);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const curve of dungeon.walls) {\r\n        curve.updateRenderPoints();\r\n    }\r\n}\r\n\r\nasync function generateWallCurve(dungeon: Dungeon, firstTile: Tile, isRootLevel: boolean, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const mainCurve = await generateSingleWallCurve(dungeon, firstTile, subStepComplete);\r\n\r\n    while (true) {\r\n        // See if we could have taken a different path at any point.\r\n        const newStartPoint = backtrackToNewStartPoint(dungeon, mainCurve);\r\n        if (newStartPoint === undefined) {\r\n            if (isRootLevel) {\r\n                checkForCurveLoops(dungeon, mainCurve);\r\n            }\r\n\r\n            if (subStepComplete !== undefined) {\r\n                mainCurve.updateRenderPoints();\r\n            }\r\n            return mainCurve;\r\n        }\r\n\r\n        // See if the different path is longer.\r\n        const branchIndex = mainCurve.keyPoints.indexOf(newStartPoint);\r\n        \r\n        const newCurve = await generateWallCurve(dungeon, newStartPoint, false, subStepComplete);\r\n\r\n        if (newCurve.keyPoints.length <= mainCurve.keyPoints.length - branchIndex || newStartPoint === firstTile) {\r\n            continue;\r\n        }\r\n\r\n        // Swap the paths around so that this path is as long as possible.\r\n\r\n        let newBranch = newCurve.keyPoints.slice(1);\r\n        let oldBranch = mainCurve.keyPoints.splice(branchIndex + 1);\r\n        oldBranch.unshift(newStartPoint);\r\n\r\n        newCurve.keyPoints = oldBranch;\r\n        mainCurve.keyPoints = mainCurve.keyPoints.concat(newBranch);\r\n        \r\n        if (isRootLevel) {\r\n            checkForCurveLoops(dungeon, newCurve);\r\n        }\r\n\r\n        if (subStepComplete !== undefined) {\r\n            newCurve.updateRenderPoints();\r\n            mainCurve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}\r\n\r\nfunction backtrackToNewStartPoint(dungeon: Dungeon, curve: Curve) {\r\n    // iterate backwards round this curve, trying to find somewhere to branch off a new curve from\r\n    for (let i = curve.keyPoints.length - 1; i >= 0; i--) {\r\n        let curveTile = curve.keyPoints[i] as Tile;\r\n\r\n        let viableTile = pickBestAdjacentWallTile(dungeon, curveTile, true, true, t => !t.isFloor && t.isWall);\r\n        if (viableTile !== undefined) {\r\n            return curveTile;\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction checkForCurveLoops(dungeon: Dungeon, mainCurve: Curve, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    // detect simple loops, as well as \"p\" and \"b\" loops that need split into two parts\r\n    const firstPoint = mainCurve.keyPoints[0];\r\n    const lastPoint = mainCurve.keyPoints[mainCurve.keyPoints.length - 1];\r\n    \r\n    if (firstPoint === lastPoint) {\r\n        mainCurve.isLoop = true;\r\n    } else {\r\n        let splitPos = mainCurve.keyPoints.lastIndexOf(firstPoint);\r\n        if (splitPos > 0) {\r\n            // p shape, loop at the start\r\n            const splitCurve = new Curve();\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(splitPos + 1);\r\n            splitCurve.keyPoints.unshift(mainCurve.keyPoints[splitPos]);\r\n\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n            \r\n            mainCurve.isLoop = true;\r\n            // console.log('found a P, splitting linear end bit into its own curve');\r\n        }\r\n        \r\n        splitPos = mainCurve.keyPoints.indexOf(lastPoint);\r\n        if (splitPos < mainCurve.keyPoints.length - 1) {\r\n            // b shape, loop at the end\r\n            /*\r\n            console.log(`loop found in curve ${dungeon.walls.indexOf(mainCurve)} at index ${splitPos} ... 0-${splitPos} will separate off linearly, keeping from ${splitPos}-${mainCurve.keyPoints.length - 1} as a loop`);\r\n            console.log(`index ${0} is ${mainCurve.keyPoints[0].x}, ${mainCurve.keyPoints[0].y}`);\r\n            console.log(`index ${splitPos} is ${mainCurve.keyPoints[splitPos].x}, ${mainCurve.keyPoints[splitPos].y}`);\r\n            console.log(`index ${mainCurve.keyPoints.length - 1} is ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].x}, ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].y}`);\r\n            */\r\n            const splitCurve = new Curve();\r\n            const splitPoint = mainCurve.keyPoints[splitPos];\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(0, splitPos - 1);\r\n            splitCurve.keyPoints.push(splitPoint);\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n\r\n            mainCurve.isLoop = true;\r\n            // console.log('found a B, splitting linear start bit into its own curve');\r\n\r\n            /*\r\n            console.log(`after splitting, main curve is ${mainCurve.keyPoints.length} long`);\r\n            console.log(`split curve is ${splitCurve.keyPoints.length} long`);\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\nexport async function generateSingleWallCurve(dungeon: Dungeon, firstTile: Tile, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const curve = new Curve();\r\n    dungeon.walls.push(curve);\r\n\r\n    let prevTile: Tile | undefined = firstTile;\r\n\r\n    // If there's an adjacent tile that's already part of a wall curve, start from that instead.\r\n    const actualFirstTile = getAdjacent(dungeon, firstTile, true, true)\r\n        .find(t => t.isWall && t.isFloor);\r\n    if (actualFirstTile !== undefined) {\r\n        curve.keyPoints.push(actualFirstTile);\r\n        firstTile = actualFirstTile;\r\n    }\r\n\r\n    curve.keyPoints.push(prevTile);\r\n    prevTile.isFloor = true;\r\n\r\n    do {\r\n        // Pick next tile, keep looping. When there isn't a next one, stop. Initially, only look orthogonally.\r\n        let tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n            dungeon,\r\n            prevTile,\r\n            t => !t.isFloor && t.isWall\r\n        );\r\n\r\n        if (tile === undefined) {\r\n            // Do the same check again, but don't ignore tiles that are part of walls. This will be the last one.\r\n            const lastTile = curve.keyPoints.length > 2\r\n                ? curve.keyPoints[curve.keyPoints.length - 2]\r\n                : undefined;\r\n\r\n            tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n                dungeon,\r\n                prevTile,\r\n                t => t.isWall && t !== lastTile\r\n            );\r\n            prevTile = undefined;\r\n        }\r\n        else {\r\n            prevTile = tile;\r\n        }\r\n\r\n        if (tile === firstTile) {\r\n            curve.isLoop = true;\r\n            break;\r\n        }\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        curve.keyPoints.push(tile);\r\n\r\n        if (tile.isFloor) {\r\n            break; // intersected a(nother) curve, so end this one\r\n        }\r\n\r\n        tile.isFloor = true;\r\n        \r\n        if (subStepComplete) {\r\n            curve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n\r\n    } while (prevTile !== undefined)\r\n\r\n    if (subStepComplete) {\r\n        curve.updateRenderPoints();\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    return curve;\r\n}\r\n\r\nexport function pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    const ortho = pickBestAdjacentWallTile(dungeon, from, true, false, filter);\r\n    return ortho !== undefined\r\n        ? ortho\r\n        : pickBestAdjacentWallTile(dungeon, from, false, true, filter);\r\n}\r\n\r\nfunction pickBestAdjacentWallTile(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    orthogonal: boolean,\r\n    diagonal: boolean,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    let bestTile: Tile | undefined;\r\n    let bestNumAdjacentNonWallTiles = 0;\r\n\r\n    let toTest = getAdjacent(dungeon, from, orthogonal, diagonal);\r\n    for (let tile of toTest) {\r\n        if (!filter(tile)) {\r\n            continue;\r\n        }\r\n\r\n        let numAdjacentNonWallTiles = 0;\r\n        let allAdjacent = getAdjacent(dungeon, tile, true, true);\r\n\r\n        for (let adjacent of allAdjacent) {\r\n            if (!adjacent.isWall) {\r\n                numAdjacentNonWallTiles++;\r\n            }\r\n        }\r\n\r\n        if (numAdjacentNonWallTiles > bestNumAdjacentNonWallTiles) {\r\n            bestNumAdjacentNonWallTiles = numAdjacentNonWallTiles;\r\n            bestTile = tile;\r\n        }\r\n    }\r\n    \r\n    return bestTile;\r\n}","import { Coord } from '../model/Coord';\r\n\r\nexport function getClosest<TNode extends Coord<TNode>>(\r\n    point: Coord<TNode>,\r\n    nodes: TNode[],\r\n    getDistance: (node: TNode, point: Coord<TNode>) => number = (node, point) => point.distanceSqTo(node),\r\n) {\r\n    let bestDist = Number.MAX_VALUE;\r\n    let bestNode: TNode | null = null;\r\n\r\n    for (const node of nodes) {\r\n        const dist = getDistance(node, point);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestNode = node;\r\n        }\r\n    }\r\n\r\n    return bestNode;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { getClosest } from '../../lib/graph/getClosest';\r\nimport { Region } from '../model/Region';\r\nimport { Coord } from '../../lib/model/Coord';\r\n\r\nexport async function associateTilesWithNodes(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n\r\n    const distance = (room: Region, point: Coord<Region>) => point.distanceSqTo(room) / room.regionInfluence;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        tile.region = getClosest(tile, dungeon.nodes, distance);\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n    }\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { SRandom } from '../../lib/SRandom';\r\n\r\nexport class Hatching extends Coord2D {\r\n    public readonly rotation: number;\r\n    public readonly lengthScale: number;\r\n    public readonly topSkew: number;\r\n    public readonly bottomSkew: number;\r\n\r\n    constructor(x: number, y: number, seed?: number) {\r\n        if (seed === undefined) {\r\n            super(x + 0.5, y + 0.5);\r\n            this.rotation = 0;\r\n            this.lengthScale = 1;\r\n            this.topSkew = 0;\r\n            this.bottomSkew = 0;\r\n            return;\r\n        }\r\n\r\n        const random = new SRandom(seed + x * x * 4987142 + x * 5947611 + y * y * 4392871 + y * 389711);\r\n\r\n        super(x + random.nextInRange(0.1, 0.9), y + random.nextInRange(0.1, 0.9));\r\n\r\n        this.rotation = random.nextInRange(0, Math.PI * 2);\r\n        this.lengthScale = random.nextInRange(0.9, 1.35);\r\n        this.topSkew = random.nextInRange(0, 0.25);\r\n        this.bottomSkew = random.nextInRange(0, 0.25);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Hatching } from '../model/Hatching';\r\n\r\nexport async function fillBackdrop(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const wallTiles = dungeon.tiles.filter(t => t.isWall);\r\n\r\n    const backdropTiles = new Set<Tile>();\r\n    addAdjacentNonFloorTiles(wallTiles, backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n\r\n    dungeon.backdropPoints = [...backdropTiles]\r\n        .filter(tile => (tile.x + tile.y) % 2 !== 0)\r\n        .map(tile => new Hatching(tile.x, tile.y, seed));\r\n}\r\n\r\nfunction addAdjacentNonFloorTiles(wallTiles: Tile[], backdropTiles: Set<Tile>) {\r\n    for (const tile of wallTiles) {\r\n        for (const adjacent of tile.adjacentTiles) {\r\n            if (!adjacent.isFloor) {\r\n                backdropTiles.add(adjacent);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Region } from './Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\n\r\nexport class Tile extends Coord2D {\r\n    public region: Region | null = null;\r\n    public readonly adjacentTiles: Tile[] = [];\r\n\r\n    constructor(x: number, y: number, public isFloor: boolean = false, public isWall: boolean = false) {\r\n        super(x, y);\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { GenerationSteps } from './GenerationSteps';\r\nimport { SRandom } from '../lib/SRandom';\r\nimport { createRegions } from './generation/createRegions';\r\nimport { populateLinks } from './generation/populateLinks';\r\nimport { filterLinks } from './generation/filterLinks';\r\nimport { createRooms } from './generation/createRooms';\r\nimport { linkLinesToGrid } from './generation/linkLinesToGrid';\r\nimport { detectWalls } from './generation/detectWalls';\r\nimport { generateWallCurves } from './generation/generateWallCurves';\r\nimport { IGenerationSettings } from './IGenerationSettings';\r\nimport { associateTilesWithNodes } from './generation/associateTilesWithNodes';\r\nimport { fillBackdrop } from './generation/fillBackdrop';\r\nimport { createTiles } from './generation/createTiles';\r\n\r\nexport enum DelaySize {\r\n    None = 0,\r\n    Minimal = 10,\r\n    Tiny = 50,\r\n    Small = 100,\r\n    Medium = 500,\r\n    Large = 1500,\r\n}\r\n\r\ntype GenerationStep = (\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepReached?: (interval: DelaySize) => Promise<void>\r\n) => Promise<void>;\r\n\r\nexport async function generateDungeon(\r\n    settings: IGenerationSettings,\r\n) {\r\n    const dungeon = new Dungeon();\r\n    await regenerateDungeon(dungeon, settings);\r\n    return dungeon;\r\n}\r\n\r\nexport async function regenerateDungeon(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n) {\r\n    dungeon.width = settings.cellsWide;\r\n    dungeon.height = settings.cellsHigh;\r\n\r\n    const seedGenerator = new SRandom(settings.seed);\r\n    \r\n    const stepFunctions = new Map<GenerationSteps, GenerationStep>([\r\n        [GenerationSteps.CreateTiles, createTiles],\r\n        [GenerationSteps.CreateNodes, createRegions],\r\n        [GenerationSteps.AssociateTiles, associateTilesWithNodes],\r\n        [GenerationSteps.LinkNodes, populateLinks],\r\n        [GenerationSteps.FilterLinks, filterLinks],\r\n        [GenerationSteps.ExpandLines, linkLinesToGrid],\r\n        [GenerationSteps.CreateRooms, createRooms],\r\n        [GenerationSteps.DetectWalls, detectWalls],\r\n        [GenerationSteps.CurveWalls, generateWallCurves],\r\n        [GenerationSteps.FillBackdrop, fillBackdrop],    \r\n    ]);\r\n\r\n    for (const step of settings.steps) {\r\n        const operation = stepFunctions.get(step);\r\n        if (operation === undefined) {\r\n            continue;\r\n        }\r\n\r\n        const stepSeed = seedGenerator.next();\r\n\r\n        const subStepReached = settings.animateSteps.indexOf(step) !== -1\r\n            ? async (interval: DelaySize) => {\r\n                if (settings.animateSteps.indexOf(step) === -1) {\r\n                    return; // give up on animation\r\n                }\r\n\r\n                settings.redraw(dungeon, step, false);\r\n                await delay(interval);\r\n            }\r\n            : undefined;\r\n        \r\n        await operation(dungeon, settings, stepSeed, subStepReached);\r\n        \r\n        if (settings.animateSteps.indexOf(step) !== -1 && step !== GenerationSteps.CreateTiles) {\r\n            settings.redraw(dungeon, step, true);\r\n            await delay(DelaySize.Large);\r\n        }\r\n    }\r\n}\r\n\r\nfunction delay(milliseconds: number): Promise<void> {\r\n    return new Promise<void>(resolve => {\r\n        setTimeout(() => resolve(), milliseconds);\r\n    });\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function createTiles(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.tiles = [];\r\n    dungeon.tilesByCoordinates = [];\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        let col = new Array<Tile>(dungeon.height);\r\n        dungeon.tilesByCoordinates[x] = col;\r\n\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = new Tile(x, y);\r\n            col[y] = tile;\r\n            dungeon.tiles.push(tile);\r\n        }\r\n    }\r\n\r\n    const maxX = dungeon.width - 1;\r\n    const maxY = dungeon.height - 1;\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = dungeon.tilesByCoordinates[x][y];\r\n\r\n            if (x > 0) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y+1]);\r\n                }\r\n            }\r\n\r\n            if (y > 0) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y-1]);\r\n            }\r\n\r\n            if (y < maxY) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y+1]);\r\n            }\r\n            \r\n            if (x < maxX) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y+1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useState, useEffect } from 'react';\r\nimport { Menu } from './menu/Menu';\r\nimport { FixedCanvas } from './Canvas';\r\nimport { Dungeon } from '../dungeon/model/Dungeon';\r\nimport './App.css';\r\nimport { renderDungeon } from '../dungeon/renderDungeon';\r\nimport { generateDungeon, regenerateDungeon } from '../dungeon/generateDungeon';\r\nimport { GenerationSteps, allSteps } from '../dungeon/GenerationSteps';\r\nimport { determineRenderSettings, IRenderSettings } from '../dungeon/IRenderSettings';\r\nimport { IGenerationSettings } from '../dungeon/IGenerationSettings';\r\n\r\nexport const App: FunctionComponent = () => {\r\n    const canvas = React.useRef<FixedCanvas>(null);\r\n\r\n    const [dungeon, setDungeon] = useState<Dungeon>(new Dungeon());\r\n    const [generating, setGenerating] = useState(false);\r\n\r\n    const cellSize = 10;\r\n\r\n    const [renderSettings, setRenderSettings] = useState<IRenderSettings>(determineRenderSettings(GenerationSteps.Render, true, cellSize));\r\n    \r\n    const [generationSettings, setGenerationSettings] = useState<IGenerationSettings>({\r\n        seed: 0,\r\n        steps: allSteps,\r\n        animateSteps: [],\r\n        cellsWide: 100,\r\n        cellsHigh: 70,\r\n        nodeCount: 25,\r\n        connectivity: 50,\r\n        redraw: (dungeon: Dungeon, stage: GenerationSteps, stageComplete: boolean) => { \r\n            if (canvas.current !== null) {\r\n                renderDungeon(dungeon, canvas.current.ctx!, determineRenderSettings(stage, stageComplete, cellSize));\r\n            }\r\n        },\r\n    });\r\n\r\n    const generate = async () => {\r\n        const settings: IGenerationSettings = {\r\n            ...generationSettings,\r\n            seed: Math.random(),\r\n            steps: allSteps,\r\n            animateSteps: [],\r\n        };\r\n\r\n        setGenerationSettings(settings);\r\n        setGenerating(true);\r\n\r\n        const dungeon = await generateDungeon(settings);\r\n\r\n        setDungeon(dungeon);\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const regenerate = async (animate: boolean, steps: GenerationSteps[]) => {\r\n        setGenerating(true);\r\n\r\n        await regenerateDungeon(dungeon, {\r\n            ...generationSettings,\r\n            steps,\r\n            animateSteps: animate ? steps.slice() : [],\r\n        });\r\n\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const skip = () => generationSettings.animateSteps.splice(0, 1); // TODO: these weren't working\r\n    const finish = () => generationSettings.animateSteps = [];\r\n\r\n    useEffect(() => { generate(); }, []); // eslint-disable-line\r\n\r\n    const setRenderSettingsAndRender = (renderSettings: IRenderSettings) => {\r\n        setRenderSettings(renderSettings);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    return (    \r\n        <div className=\"App\">\r\n            <Menu\r\n                dungeon={dungeon}\r\n                canvas={canvas.current === null ? undefined : canvas.current.canvas}\r\n                cellSize={cellSize}\r\n                isGenerating={generating}\r\n                generationSettings={generationSettings}\r\n                setGenerationSettings={setGenerationSettings}\r\n                setRenderSettings={setRenderSettingsAndRender}\r\n                generate={generate}\r\n                regenerate={regenerate}\r\n                skip={skip}\r\n                finish={finish}\r\n            />\r\n            <FixedCanvas\r\n                className=\"dungeonDisplay\"\r\n                width={cellSize * generationSettings.cellsWide}\r\n                height={cellSize * generationSettings.cellsHigh}\r\n                ref={canvas}\r\n            />\r\n        </div>\r\n    );\r\n}","// tslint:disable:no-console\r\n// In production, we register a service worker to serve assets from local cache.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on the 'N+1' visit to a page, since previously\r\n// cached resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\r\n// This link also includes instructions on opting out of this behavior.\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport default function register() {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL!,\r\n      window.location.toString()\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (!isLocalhost) {\r\n        // Is not local host. Just register service worker\r\n        registerValidSW(swUrl);\r\n      } else {\r\n        // This is running on localhost. Lets check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker) {\r\n          installingWorker.onstatechange = () => {\r\n            if (installingWorker.state === 'installed') {\r\n              if (navigator.serviceWorker.controller) {\r\n                // At this point, the old content will have been purged and\r\n                // the fresh content will have been added to the cache.\r\n                // It's the perfect time to display a 'New content is\r\n                // available; please refresh.' message in your web app.\r\n                console.log('New content is available; please refresh.');\r\n              } else {\r\n                // At this point, everything has been precached.\r\n                // It's the perfect time to display a\r\n                // 'Content is cached for offline use.' message.\r\n                console.log('Content is cached for offline use.');\r\n              }\r\n            }\r\n          };\r\n        }\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      if (\r\n        response.status === 404 ||\r\n        response.headers.get('content-type')!.indexOf('javascript') === -1\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport { App } from './components/App';\r\nimport registerServiceWorker from './registerServiceWorker';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root') as HTMLElement\r\n);\r\nregisterServiceWorker();\r\n"],"sourceRoot":""}