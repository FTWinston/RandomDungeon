{"version":3,"sources":["dungeon/GenerationSteps.ts","dungeon/IRenderSettings.ts","components/menu/Generate.tsx","components/common/RangeInput.tsx","components/menu/MapSize.tsx","dungeon/model/Region.ts","lib/model/Coord.ts","components/menu/Regions.tsx","lib/randomColor.ts","components/menu/Connections.tsx","dungeon/generation/linkLinesToGrid.ts","components/menu/Menu.tsx","components/Canvas.tsx","dungeon/model/Dungeon.ts","dungeon/renderDungeon.ts","lib/SRandom.ts","dungeon/generation/createRegions.ts","lib/model/Polygon.ts","lib/model/Triangle.ts","lib/graph/delauney.ts","lib/graph/gabriel.ts","lib/graph/getUniqueLines.ts","lib/graph/minimumSpanning.ts","lib/graph/relativeNeighbourhood.ts","dungeon/model/Pathway.ts","lib/model/Line.ts","dungeon/generation/populateLinks.ts","dungeon/generation/filterLinks.ts","dungeon/generation/populateCaveRegion.ts","dungeon/generation/populateRoomRegion.ts","dungeon/generation/createRooms.ts","dungeon/generation/detectWalls.ts","lib/model/Curve.ts","dungeon/generation/generateWallCurves.ts","lib/graph/getClosest.ts","dungeon/generation/associateTilesWithNodes.ts","dungeon/model/Hatching.ts","dungeon/generation/fillBackdrop.ts","dungeon/model/Tile.ts","dungeon/generateDungeon.ts","dungeon/generation/createTiles.ts","components/App.tsx","registerServiceWorker.ts","index.tsx"],"names":["GenerationSteps","allSteps","CreateTiles","CreateNodes","AssociateTiles","LinkNodes","FilterLinks","ExpandLines","CreateRooms","DetectWalls","CurveWalls","FillBackdrop","Render","determineRenderSettings","generationStage","stageComplete","cellSize","nodeAlpha","regionAlpha","graphAlpha","drawNodeLinks","drawGrid","drawWalls","highlightWallCurves","drawOutside","drawOutsidePoints","floorColor","floorGridColor","linkColor","linkWidth","backgroundColor","hatchingColor","wallColor","wallWidth","floorGridWidth","hatchingWidth","drawWallsAsFloor","minimumSpanningWidth","relativeNeighbourhoodWidth","gabrielWidth","delauneyWidth","Generate","props","generateOrSkip","isGenerating","className","onClick","generate","animateOrFinish","animate","useEffect","setRenderSettings","showSize","showRegions","showConnections","RangeInput","onChange","onChangeComplete","changeHandler","useMemo","undefined","e","target","valueAsNumber","changeCompleteHandler","label","type","inputClassName","min","max","value","onMouseUp","onTouchEnd","disabled","RegionType","MapSize","goBack","generationSettings","cellsWide","val","scale","dungeon","nodes","x","setGenerationSettings","redraw","cellsHigh","y","Coord2D","this","magnitude","other","length","magnitudeSq","dx","dy","b","c","a","d","center","Math","sqrt","RegionMode","Region","parent","seed","regionType","color","regionInfluence","radius","links","colorChars","ConnectionMode","Regions","dungeonDisplay","text","useState","AddRemove","mode","setMode","leftClick","rightClick","cellX","offsetX","cellY","offsetY","random","floor","NUM_VALUES","push","r","g","randomColor","preventDefault","cell","getTileAt","region","node","filter","n","Resize","ChangeType","FIRST_VALUE","addEventListener","removeEventListener","linkLinesToGrid","settings","subStepComplete","lines","link","tiles","getTouchedTiles","isFloor","x0","from","x1","to","y0","y1","col0","tilesByCoordinates","cell0","col1","cell1","steep","abs","tmp","gradient","iY","round","closestSideStep","almostInteger","MenuPage","Connections","linesByTile","allLines","Map","delauneyLines","line","tile","tileLines","get","set","singleLineTiles","paths","getLinesByTile","index","indexOf","slice","Doors","Menu","Main","currentPage","setCurrentPage","switchToMain","switchToSize","Size","switchToRegions","switchToConnections","switchToRenders","Renders","regenerate","canvas","skip","finish","showRenders","FixedCanvas","ctx","root","state","width","height","ref","updateCtx","prevProps","prevState","getContext","React","Dungeon","backdropPoints","gabrielLines","relativeNeighbourhoodLines","minimumSpanningLines","walls","col","renderDungeon","clearRect","lineWidth","drawTile","drawTileGrid","globalAlpha","strokeStyle","drawPath","drawGraph","fillStyle","save","clipOutside","fillRect","xScale","point","yScale","lengthScale","translate","rotate","rotation","beginPath","moveTo","topSkew","lineTo","bottomSkew","fill","stroke","restore","fillOutside","arc","PI","lineCap","drawCurve","i","drawNode","pathway","room","isWall","strokeRect","curve","draw","halfCellSize","keyPoints","points","renderPoints","cx","cy","rect","clip","SRandom","s0","s1","s2","mash","t","next","minInclusive","maxExclusive","nextInRange","nextIntInRange","data","toString","h","charCodeAt","createRegions","makeNode","influence","nextColor","nodeCount","addSpacedNode","DelaySize","Small","totWidth","totHeight","getScaledDistSq","n1","n2","dxScaled","dyScaled","node1","node2","closestDist1","Number","MAX_VALUE","closestDist2","Triangle","vertices","circumCenter","circumRadiusSq","circumCircle","computeDelauneyTriangulation","superTriangle","triangulation","badTriangles","triangle","insideCircumcircle","polygon","edgeFrom","edgeTo","sharedWithOther","splice","vertex","distanceSqTo","computeGabrielGraph","graph","graphLinks","anyBlocking","halfwayTo","radiusSq","getUniqueLines","polygons","createLine","v0","v1","some","l","computeMinimumSpanningTree","unvisitedNodes","firstNode","pop","possibleLinks","map","lengthSq","sort","visitedNodes","testLink","alreadyHasFrom","alreadyHasTo","addingNode","j","computeRelativeNeighbourhoodGraph","Pathway","populateLinks","console","log","enclosingTriangle","Artificial","delauneyTriangles","Medium","filterLinks","connectivity","selectingFrom","selectFraction","numToSelect","selectedLink","populateCaveRegion","regionTiles","nonEdgeTiles","adjacentTiles","mutableTiles","runCellularAutomataStep","removeUnconnectedFloorTiles","cells","results","wasAlive","numAdjacentLiving","shouldLive","result","rootTile","connectedTiles","Set","tilesToTest","has","add","populateRoomRegion","nodeX","nodeY","determineBounds","minX","minY","maxX","maxY","growUpLeft","growDownRight","canLeft","canUp","isRowInRegion","isColInRegion","canRight","canDown","y2","x2","createRooms","Natural","detectWalls","iCol","toTest","getAdjacent","test","Tiny","orthogonal","diagonal","Curve","curvature","isLoop","t1x","t2x","t1y","t2y","c1","c2","c3","c4","fraction","step","iPt","lastCellIndex","tension","pts","firstCell","lastCell","secondCell","unshift","stepsPerSegment","pow","generateWallCurves","generateWallCurve","updateRenderPoints","firstTile","isRootLevel","generateSingleWallCurve","mainCurve","newStartPoint","backtrackToNewStartPoint","checkForCurveLoops","branchIndex","newCurve","newBranch","oldBranch","concat","curveTile","pickBestAdjacentWallTile","firstPoint","lastPoint","splitPos","lastIndexOf","splitCurve","splitPoint","prevTile","actualFirstTile","find","pickBestAdjacentWallTileOrthogonalThenDiagonal","lastTile","Minimal","ortho","bestTile","bestNumAdjacentNonWallTiles","numAdjacentNonWallTiles","allAdjacent","getClosest","getDistance","bestDist","bestNode","dist","associateTilesWithNodes","distance","Hatching","fillBackdrop","wallTiles","backdropTiles","addAdjacentNonFloorTiles","adjacent","Tile","createTiles","Array","generateDungeon","regenerateDungeon","seedGenerator","stepFunctions","operation","stepSeed","subStepReached","animateSteps","interval","delay","Large","steps","milliseconds","Promise","resolve","setTimeout","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","catch","error","ReactDOM","setDungeon","generating","setGenerating","renderSettings","stage","current","document","getElementById","URL","process","origin","fetch","response","status","headers","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.f7d83fa6.chunk.js","sourcesContent":["export enum GenerationSteps {\r\n    CreateTiles,\r\n    CreateNodes,\r\n    AssociateTiles,\r\n    LinkNodes,\r\n    FilterLinks,\r\n    ExpandLines,\r\n    CreateRooms,\r\n    DetectWalls,\r\n    CurveWalls,\r\n    FillBackdrop,\r\n    Render,\r\n\r\n\r\n    FIRST_STEP = CreateTiles,\r\n}\r\n\r\nexport const allSteps = [\r\n    GenerationSteps.CreateTiles,\r\n    GenerationSteps.CreateNodes,\r\n    GenerationSteps.AssociateTiles,\r\n    GenerationSteps.LinkNodes,\r\n    GenerationSteps.FilterLinks,\r\n    GenerationSteps.ExpandLines,\r\n    GenerationSteps.CreateRooms,\r\n    GenerationSteps.DetectWalls,\r\n    GenerationSteps.CurveWalls,\r\n    GenerationSteps.FillBackdrop,\r\n    GenerationSteps.Render,\r\n];","import { GenerationSteps } from './GenerationSteps';\r\n\r\nexport interface IRenderSettings {\r\n    nodeAlpha: number;\r\n    regionAlpha: number;\r\n    graphAlpha: number;\r\n    drawNodeLinks: boolean;\r\n    drawGrid: boolean;\r\n    drawWalls: boolean;\r\n    highlightWallCurves: boolean;\r\n    drawOutsidePoints: boolean;\r\n    drawOutside: boolean;\r\n    backgroundColor: string;\r\n    linkColor: string;\r\n    linkWidth: number;\r\n    floorColor: string;\r\n    floorGridColor: string;\r\n    floorGridWidth: number;\r\n    wallColor: string;\r\n    hatchingColor: string;\r\n    cellSize: number,\r\n    wallWidth: number,\r\n    hatchingWidth: number,\r\n    drawWallsAsFloor: boolean,\r\n    minimumSpanningWidth: number,\r\n    relativeNeighbourhoodWidth: number,\r\n    gabrielWidth: number,\r\n    delauneyWidth: number,\r\n}\r\n\r\nexport function determineRenderSettings(   \r\n    generationStage = GenerationSteps.Render,\r\n    stageComplete: boolean = true,\r\n    cellSize: number,\r\n): IRenderSettings {\r\n    let nodeAlpha = 0;\r\n    let regionAlpha = 0;\r\n    let graphAlpha = 0;\r\n    let drawNodeLinks = false;\r\n    let drawGrid = false;\r\n    let drawWalls = false;\r\n    let highlightWallCurves = false;\r\n    let drawOutside = false;\r\n    let drawOutsidePoints = false;\r\n    let drawWallsAsFloor = true;\r\n\r\n    switch (generationStage) {\r\n        case GenerationSteps.CreateTiles:\r\n            drawGrid = true;\r\n            break;\r\n            \r\n        case GenerationSteps.CreateNodes:\r\n            nodeAlpha = 1;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.AssociateTiles:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.66;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.LinkNodes:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.5;\r\n            graphAlpha = 0.25;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.FilterLinks:\r\n            nodeAlpha = 0.75;\r\n            regionAlpha = 0.55;\r\n            drawNodeLinks = true;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.ExpandLines:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CreateRooms:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.DetectWalls:\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CurveWalls:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n\r\n            highlightWallCurves = !stageComplete;\r\n            break;\r\n\r\n        case GenerationSteps.FillBackdrop:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutsidePoints = true;\r\n            break;\r\n\r\n        case GenerationSteps.Render:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutside = true;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        nodeAlpha,\r\n        regionAlpha,\r\n        graphAlpha,\r\n        drawNodeLinks,\r\n        drawGrid,\r\n        drawWalls,\r\n        highlightWallCurves,\r\n        drawOutsidePoints,\r\n        drawOutside,\r\n        floorColor: '#fff',\r\n        floorGridColor: 'rgba(192,192,192,0.5)',\r\n        linkColor: '#000',\r\n        linkWidth: 1,\r\n        backgroundColor: '#fff',\r\n        hatchingColor: '#000',\r\n        wallColor: '#000',\r\n        cellSize,\r\n        wallWidth: cellSize,\r\n        floorGridWidth: 1,\r\n        hatchingWidth: cellSize * 0.175,\r\n        drawWallsAsFloor,\r\n        minimumSpanningWidth: cellSize,\r\n        relativeNeighbourhoodWidth: cellSize * 0.5,\r\n        gabrielWidth: cellSize * 0.25,\r\n        delauneyWidth: 1,\r\n    };\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\nexport interface Props {\r\n    isGenerating: boolean;\r\n    generate: () => Promise<void>;\r\n    animate: () => Promise<void>;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    skip: () => void;\r\n    finish: () => void;\r\n\r\n    showSize: () => void;\r\n    showRegions: () => void;\r\n    showConnections: () => void;\r\n    showRenders: () => void;\r\n}\r\n\r\nexport const Generate: FunctionComponent<Props> = props => {\r\n    const generateOrSkip = props.isGenerating\r\n        ? <button className=\"menu__button\">Skip step</button>\r\n        : <button className=\"menu__button\" onClick={props.generate}>Generate new</button>\r\n\r\n    const animateOrFinish = props.isGenerating\r\n        ? <button className=\"menu__button\">Finish</button>\r\n        : <button className=\"menu__button\" onClick={props.animate}>Animate generation</button>\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.Render, true, props.cellSize),\r\n        });\r\n    }, []); // eslint-disable-line\r\n    \r\n    return <div className=\"menu menu--autoGenerate\">\r\n        <button className=\"menu__link\" onClick={props.showSize}>Map size</button>\r\n        <button className=\"menu__link\" onClick={props.showRegions}>Edit regions</button>\r\n        <button className=\"menu__link\" onClick={props.showConnections}>Edit paths</button>\r\n\r\n        <div className=\"menu__spacer\" />\r\n\r\n        {generateOrSkip}\r\n        {animateOrFinish}\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo } from 'react';\r\n\r\ninterface Props {\r\n    className?: string;\r\n    inputClassName?: string;\r\n    label: string;\r\n    min: number;\r\n    max: number;\r\n    value: number;\r\n    onChange?: (val: number) => void;\r\n    onChangeComplete?: () => void;\r\n    disabled?: boolean;\r\n}\r\n\r\nexport const RangeInput: FunctionComponent<Props> = props => {\r\n    const {onChange, onChangeComplete} = props;\r\n\r\n    const changeHandler = useMemo(() => {\r\n        if (onChange === undefined) {\r\n            return undefined;\r\n        }\r\n        return (e: React.ChangeEvent<HTMLInputElement>) => onChange(e.target.valueAsNumber)\r\n    }, [onChange]);\r\n\r\n    const changeCompleteHandler = useMemo(() => {\r\n        if (onChangeComplete === undefined) {\r\n            return undefined;\r\n        }\r\n        return () => onChangeComplete();\r\n    }, [onChangeComplete]);\r\n\r\n    return (\r\n        <label className={props.className}>{props.label}\r\n            <input\r\n                type=\"range\"\r\n                className={props.inputClassName}\r\n                min={props.min}\r\n                max={props.max}\r\n                value={props.value}\r\n                onChange={changeHandler}\r\n                onMouseUp={changeCompleteHandler}\r\n                onTouchEnd={changeCompleteHandler}\r\n                disabled={props.disabled}\r\n            />\r\n        </label>\r\n    );\r\n}\r\n","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { RangeInput } from '../common/RangeInput';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    generationSettings: IGenerationSettings;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const MapSize: FunctionComponent<Props> = props => {\r\n    const setWidth = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsWide;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.x *= scale;\r\n        }\r\n\r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsWide: val,\r\n        });\r\n    }\r\n\r\n    const setHeight = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsHigh;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.y *= scale;\r\n        }\r\n        \r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsHigh: val,\r\n        });\r\n    }\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    return <div className=\"menu menu--mapSize\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n    \r\n        <div className=\"menu__group\">\r\n            <RangeInput\r\n                label=\"Width\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsWide}\r\n                onChange={setWidth}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n\r\n            <RangeInput\r\n                label=\"Height\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsHigh}\r\n                onChange={setHeight}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n        </div>\r\n    </div>\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { Dungeon } from './Dungeon';\r\nimport { Pathway } from './Pathway';\r\n\r\nexport enum RegionType {\r\n    Junction = 0,\r\n    Natural = 1,\r\n    Artificial = 2,\r\n\r\n    NUM_VALUES,\r\n    FIRST_VALUE = 0,\r\n}\r\n\r\nexport class Region extends Coord2D {\r\n    radius: number = 0.75;\r\n    links: Pathway[] = [];\r\n\r\n    constructor(\r\n        readonly parent: Dungeon,\r\n        x: number,\r\n        y: number,\r\n        public seed: number,\r\n        public regionType: RegionType,\r\n        public readonly color: string,\r\n        public regionInfluence = 1\r\n    ) {\r\n        super(x, y);\r\n    }\r\n}","export abstract class Coord<TCoord extends Coord<TCoord>> {\r\n    abstract length(): number;\r\n\r\n    abstract equals(other: Coord<TCoord>): boolean;\r\n    \r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract toUnitLength(): Coord<TCoord>;\r\n\r\n    abstract distanceTo(other: Coord<TCoord>): number;\r\n    \r\n    abstract distanceSqTo(other: Coord<TCoord>): number;\r\n\r\n    abstract directionTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract halfwayTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract scale(scale: number): Coord<TCoord>;\r\n    \r\n    abstract crossProduct(other: Coord<TCoord>): number;\r\n\r\n    abstract circumCircle(b: Coord<TCoord>, c: Coord<TCoord>): [Coord<TCoord>, number];\r\n}\r\n\r\nexport class Coord2D extends Coord<Coord2D> {\r\n    constructor(public x: number, public y: number) {\r\n        super();\r\n    }\r\n\r\n    length() {\r\n        return this.magnitude(this.x, this.y);\r\n    }\r\n\r\n    equals(other: Coord2D) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    add(other: Coord2D) {\r\n        return new Coord2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subtract(other: Coord2D) {\r\n        return new Coord2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    toUnitLength() {\r\n        let length = this.length();\r\n        return new Coord2D(this.x / length, this.y / length);\r\n    }\r\n    \r\n    distanceTo(other: Coord2D) {\r\n        return this.magnitude(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    distanceSqTo(other: Coord2D) {\r\n        return this.magnitudeSq(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    directionTo(other: Coord2D) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        \r\n        let length = this.magnitude(dx, dy);\r\n        return new Coord2D(dx / length, dy / length);\r\n    }\r\n\r\n    halfwayTo(other: Coord2D) {\r\n        return new Coord2D((this.x + other.x) / 2, (this.y + other.y) / 2);\r\n    }\r\n\r\n    scale(scale: number) {\r\n        return new Coord2D(this.x * scale, this.y * scale);\r\n    }\r\n\r\n    crossProduct(other: Coord2D) {\r\n        return this.x * other.y - this.y * other.x;\r\n    }\r\n\r\n    circumCircle(b: Coord2D, c: Coord2D) {\r\n        let a = this;\r\n        let d = (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n        \r\n        let x = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) \r\n             -  ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.y - c.y))\r\n        / d;\r\n\r\n        let y = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x)\r\n            -  ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x))\r\n        / d;\r\n\r\n        let center = new Coord2D(x, y);\r\n\r\n        let rSquared = (c.x - center.x) * (c.x - center.x) + (c.y - center.y) * (c.y - center.y);\r\n\r\n        let retVal: [Coord2D, number] = [\r\n            center,\r\n            rSquared\r\n        ];\r\n\r\n        return retVal;\r\n    }\r\n\r\n    private magnitude(dx: number, dy: number) {\r\n        return Math.sqrt(this.magnitudeSq(dx, dy));\r\n    }\r\n\r\n    private magnitudeSq(dx: number, dy: number) {\r\n        return dx * dx + dy * dy;\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect, useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { Region, RegionType } from '../../dungeon/model/Region';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { randomColor } from '../../lib/randomColor';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nenum RegionMode {\r\n    AddRemove,\r\n    Resize,\r\n    ChangeType,\r\n}\r\n\r\nexport const Regions: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const [mode, setMode] = useState(RegionMode.AddRemove);\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        let leftClick: (e: MouseEvent) => void;\r\n        let rightClick: (e: MouseEvent) => void;\r\n\r\n        switch (mode) {\r\n            case RegionMode.AddRemove:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    // add new node\r\n                    const seed = Math.random();\r\n                    const regionType = Math.floor(Math.random() * RegionType.NUM_VALUES);\r\n                    dungeon.nodes.push(new Region(dungeon, cellX, cellY, seed, regionType, randomColor()));\r\n                    redraw();\r\n                };\r\n\r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    // remove associated node\r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    const node = cell.region;\r\n                    dungeon.nodes = dungeon.nodes.filter(n => n !== node);\r\n        \r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.Resize:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence *= 1.2;\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence /= 1.2;\r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.ChangeType:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    if (++cell.region.regionType >= RegionType.NUM_VALUES) {\r\n                        cell.region.regionType = RegionType.FIRST_VALUE;\r\n                    }\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n\r\n                    cell.region.seed = Math.random();\r\n                    redraw();\r\n                };\r\n                break;\r\n            default:\r\n                return;       \r\n        }\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize, mode]);\r\n\r\n    let text: string | undefined;\r\n\r\n    switch (mode) {\r\n        case RegionMode.AddRemove:\r\n            text = \"Left click the map to place region nodes. Right click to remove a region.\";\r\n            break;\r\n        case RegionMode.Resize:\r\n            text = \"Left click the a region to grow it, right click a region to shrink it.\";\r\n            break;\r\n        case RegionMode.ChangeType:\r\n            text = \"Left click a region to change its type. Right click to regenerate it with the same type.\";\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === RegionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.AddRemove)}>Add/remove regions</li>\r\n            <li className={mode === RegionMode.Resize ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.Resize)}>Resize regions</li>\r\n            <li className={mode === RegionMode.ChangeType ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.ChangeType)}>Change region types</li>\r\n        </ul>\r\n\r\n        <div className=\"menu__section\">\r\n            {text}\r\n        </div>\r\n    </div>\r\n}","const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n\r\nexport function randomColor() {\r\n    const r = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const g = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const b = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    return `#${r}${g}${b}`;\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect, useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { Pathway } from '../../dungeon/model/Pathway';\r\nimport { getTouchedTiles } from '../../dungeon/generation/linkLinesToGrid';\r\nimport { Tile } from '../../dungeon/model/Tile';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nenum ConnectionMode {\r\n    AddRemove,\r\n    Doors,\r\n}\r\n\r\nexport const Connections: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.FilterLinks, true, props.cellSize),\r\n            regionAlpha: 0.33,\r\n            drawWallsAsFloor: false,\r\n            linkWidth: cellSize * 0.5,\r\n            linkColor: '#0c0',\r\n            graphAlpha: 0.5,\r\n            minimumSpanningWidth: cellSize * 0.5,\r\n            relativeNeighbourhoodWidth: cellSize * 0.25,\r\n            gabrielWidth: cellSize * 0.125,\r\n            delauneyWidth: 1,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const [mode, setMode] = useState(ConnectionMode.AddRemove);\r\n\r\n    const linesByTile = getLinesByTile(dungeon); // I tried to memoise this, but it didn't work\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        let leftClick: (e: MouseEvent) => void;\r\n        let rightClick: (e: MouseEvent) => void;\r\n\r\n        switch (mode) {\r\n            case ConnectionMode.AddRemove:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined) {\r\n                        return;\r\n                    }\r\n        \r\n                    const line = linesByTile.get(cell);\r\n                    if (line === undefined) {\r\n                        return;\r\n                    }\r\n\r\n                    // add or remove this line\r\n                    const index = dungeon.lines.indexOf(line);\r\n                    if (index !== -1) {\r\n                        dungeon.lines = [\r\n                            ...dungeon.lines.slice(0, index),\r\n                            ...dungeon.lines.slice(index + 1),\r\n                        ];\r\n                    }\r\n                    else {\r\n                        dungeon.lines = [\r\n                            ...dungeon.lines,\r\n                            line\r\n                        ];\r\n                    }\r\n                    redraw();\r\n                };\r\n\r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined) {\r\n                        return;\r\n                    }\r\n        \r\n                    const line = linesByTile.get(cell);\r\n                    if (line === undefined) {\r\n                        return;\r\n                    }\r\n\r\n                    // TODO: something\r\n                    redraw();\r\n                };\r\n                break;\r\n            case ConnectionMode.Doors:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined) {\r\n                        return;\r\n                    }\r\n        \r\n                    const line = linesByTile.get(cell);\r\n                    if (line === undefined) {\r\n                        return;\r\n                    }\r\n\r\n                    // TODO: something\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined) {\r\n                        return;\r\n                    }\r\n        \r\n                    const line = linesByTile.get(cell);\r\n                    if (line === undefined) {\r\n                        return;\r\n                    }\r\n\r\n                    // TODO: something\r\n                    redraw();\r\n                };\r\n                break;\r\n            default:\r\n                return;       \r\n        }\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, dungeon.lines, dungeon.delauneyLines, linesByTile, redraw, cellSize, mode]);\r\n\r\n    let text: string | undefined;\r\n\r\n    switch (mode) {\r\n        case ConnectionMode.AddRemove:\r\n            text = \"Left click the map to toggle a pathway on / off.\";\r\n            break;\r\n        case ConnectionMode.Doors:\r\n            text = \"Doors haven't yet been implemented.\";\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === ConnectionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(ConnectionMode.AddRemove)}>Add/remove paths</li>\r\n            <li className={mode === ConnectionMode.Doors ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(ConnectionMode.Doors)}>Add/remove doors</li>\r\n        </ul>\r\n\r\n        <div className=\"menu__section\">\r\n            {text}\r\n        </div>\r\n    </div>\r\n}\r\n\r\nfunction getLinesByTile(dungeon: Dungeon) {\r\n    const allLines = new Map<Tile, Pathway[]>();\r\n    for (const line of dungeon.delauneyLines) {\r\n        const tiles = getTouchedTiles(line, dungeon);\r\n        for (const tile of tiles) {\r\n            let tileLines = allLines.get(tile);\r\n            if (tileLines === undefined) {\r\n                tileLines = [];\r\n                allLines.set(tile, tileLines);\r\n            }\r\n\r\n            tileLines.push(line);\r\n        }\r\n    }\r\n\r\n    const singleLineTiles = new Map<Tile, Pathway>();\r\n    for (const [tile, paths] of allLines) {\r\n        if (paths.length === 1) {\r\n            singleLineTiles.set(tile, paths[0]);\r\n        }\r\n    }\r\n\r\n    return singleLineTiles;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function linkLinesToGrid(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const link of dungeon.lines) {\r\n        const tiles = getTouchedTiles(link, dungeon);\r\n\r\n        for (const tile of tiles) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getTouchedTiles(link: Pathway, dungeon: Dungeon) {\r\n    // Associate each tile that this link overlaps or touches.\r\n    // This is Xiaolin Wi's algorithm, without the antialiasing.\r\n    let x0 = Math.floor(link.from.x);\r\n    let x1 = Math.floor(link.to.x);\r\n    let y0 = Math.floor(link.from.y);\r\n    let y1 = Math.floor(link.to.y);\r\n    const col0 = dungeon.tilesByCoordinates[x0];\r\n\r\n    const tiles: Tile[] = [];\r\n\r\n    if (col0 !== undefined) {\r\n        const cell0 = col0[y0];\r\n        if (cell0 !== undefined) {\r\n            tiles.push(cell0);\r\n        }\r\n    }\r\n\r\n    const col1 = dungeon.tilesByCoordinates[x1];\r\n    if (col1 !== undefined) {\r\n        const cell1 = col1[y1];\r\n        if (cell1 !== undefined) {\r\n            tiles.push(cell1);\r\n        }\r\n    }\r\n\r\n    let steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n    if (steep) { // swap x & y, ensure not steep\r\n        let tmp = y0;\r\n        y0 = x0;\r\n        x0 = tmp;\r\n        tmp = y1;\r\n        y1 = x1;\r\n        x1 = tmp;\r\n    }\r\n    if (x0 > x1) { // swap 0 & 1, ensure moving rightwards\r\n        let tmp = x1;\r\n        x1 = x0;\r\n        x0 = tmp;\r\n        tmp = y1;\r\n        y1 = y0;\r\n        y0 = tmp;\r\n    }\r\n\r\n    let gradient = (y1 - y0) / (x1 - x0);\r\n    let y = y0 + gradient * 0.5; // move to the \"middle\" of the cell\r\n    for (let x = x0; x < x1; x++) {\r\n        let iY = Math.round(y - 0.5); // round to the nearest i+0.5, then truncate to int\r\n        let closestSideStep = iY + 0.5 > y ? -1 : 1;\r\n        let almostInteger = Math.abs(y - iY) < 0.10;\r\n\r\n        if (steep) {\r\n            tiles.push(dungeon.tilesByCoordinates[iY + closestSideStep][x]);\r\n            tiles.push(dungeon.tilesByCoordinates[iY][x]);\r\n            if (!almostInteger) {\r\n                tiles.push(dungeon.tilesByCoordinates[iY - closestSideStep][x]);\r\n            }\r\n        }\r\n        else {\r\n            tiles.push(dungeon.tilesByCoordinates[x][iY + closestSideStep]);\r\n            tiles.push(dungeon.tilesByCoordinates[x][iY]);\r\n            if (!almostInteger) {\r\n                tiles.push(dungeon.tilesByCoordinates[x][iY - closestSideStep]);\r\n            }\r\n        }\r\n\r\n        y += gradient;\r\n    }\r\n\r\n    return tiles;\r\n}","import * as React from 'react';\r\nimport './Menu.css';\r\nimport { FunctionComponent, useState, useMemo } from 'react';\r\nimport { Generate } from './Generate';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { MapSize } from './MapSize';\r\nimport { GenerationSteps, allSteps } from '../../dungeon/GenerationSteps';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { Regions } from './Regions';\r\nimport { IRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { Connections } from './Connections';\r\n\r\ninterface Props {\r\n    isGenerating: boolean;\r\n    dungeon: Dungeon;\r\n    canvas?: HTMLCanvasElement;\r\n    cellSize: number;\r\n    generationSettings: Readonly<IGenerationSettings>;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    generate: () => Promise<void>;\r\n    regenerate: (animate: boolean, steps: GenerationSteps[]) => Promise<void>;\r\n    skip: () => void;\r\n    finish: () => void;\r\n}\r\n\r\nenum MenuPage {\r\n    Main,\r\n    Size,\r\n    Regions,\r\n    Connections,\r\n    Renders,\r\n}\r\n\r\nexport const Menu: FunctionComponent<Props> = props => {\r\n    const [currentPage, setCurrentPage] = useState(MenuPage.Main);\r\n\r\n    const switchToMain = useMemo(() => () => setCurrentPage(MenuPage.Main), []);\r\n    const switchToSize = useMemo(() => () => setCurrentPage(MenuPage.Size), []);\r\n    const switchToRegions = useMemo(() => () => setCurrentPage(MenuPage.Regions), []);\r\n    const switchToConnections = useMemo(() => () => setCurrentPage(MenuPage.Connections), []);\r\n    const switchToRenders = useMemo(() => () => setCurrentPage(MenuPage.Renders), []);\r\n    \r\n    const { regenerate } = props;\r\n\r\n    const animate = useMemo(() => (() => regenerate(true, [GenerationSteps.CreateTiles, ...allSteps.slice(2)])), [regenerate]);\r\n\r\n    switch (currentPage) {\r\n        case MenuPage.Size:\r\n            return (\r\n                <MapSize\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    generationSettings={props.generationSettings}\r\n                    setGenerationSettings={props.setGenerationSettings}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, [GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n                />\r\n            );\r\n        case MenuPage.Regions:\r\n            return (\r\n                <Regions\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, [GenerationSteps.CreateTiles, ...allSteps.slice(2)])} // skip CreateTiles and CreateNodes\r\n                />\r\n            );\r\n        case MenuPage.Connections:\r\n            return (\r\n                <Connections\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, [GenerationSteps.CreateTiles, GenerationSteps.AssociateTiles, ...allSteps.slice(5)])} // jump to ExpandLines\r\n                />\r\n            );\r\n\r\n        // TODO: other pages\r\n\r\n        default:\r\n            return (\r\n                <Generate\r\n                    isGenerating={props.isGenerating}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    cellSize={props.cellSize}\r\n                    generate={props.generate}\r\n                    animate={animate}\r\n                    skip={props.skip}\r\n                    finish={props.finish}\r\n\r\n                    showSize={switchToSize}\r\n                    showRegions={switchToRegions}\r\n                    showConnections={switchToConnections}\r\n                    showRenders={switchToRenders}\r\n                />\r\n            );\r\n    }\r\n};","import * as React from 'react';\r\n\r\ninterface FixedProps {\r\n    width: number;\r\n    height: number;\r\n    className?: string;\r\n}\r\n\r\nexport class FixedCanvas extends React.Component<FixedProps, {}> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    public canvas?: HTMLCanvasElement;\r\n\r\n    constructor(props: FixedProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: props.width === undefined ? 0 : props.width,\r\n            height: props.height === undefined ? 0 : props.height,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.props.width}\r\n                    height={this.props.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    componentDidMount() {\r\n        this.updateCtx();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        const ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n}\r\n\r\ninterface ResponsiveProps {\r\n    className?: string;\r\n    sizeChanged?: (width: number, height: number) => void;\r\n}\r\n\r\ninterface ResponsiveState {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport class ResponsiveCanvas extends React.Component<ResponsiveProps, ResponsiveState> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    private canvas?: HTMLCanvasElement;\r\n    private resizeListener?: () => void;\r\n\r\n    constructor(props: ResponsiveProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.state.width}\r\n                    height={this.state.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateCtx();\r\n\r\n        this.resizeListener = () => this.updateSize();\r\n        window.addEventListener('resize', this.resizeListener);\r\n    \r\n        this.updateSize();\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        if (this.resizeListener !== undefined) {\r\n            window.removeEventListener('resize', this.resizeListener);\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    updateSize() {\r\n        if (this.root === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let scrollSize = this.getScrollbarSize();\r\n        let width = this.root.offsetWidth - scrollSize.width;\r\n        let height = this.root.offsetHeight - scrollSize.height;\r\n\r\n        this.setState({\r\n            width: width,\r\n            height: height,\r\n        });\r\n\r\n        if (this.props.sizeChanged !== undefined) {\r\n            this.props.sizeChanged(width, height);\r\n        }\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n\r\n    private getScrollbarSize() {\r\n        let outer = document.createElement('div');\r\n        outer.style.visibility = 'hidden';\r\n        outer.style.width = '100px';\r\n        outer.style.height = '100px';\r\n        outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\r\n\r\n        document.body.appendChild(outer);\r\n\r\n        let widthNoScroll = outer.offsetWidth;\r\n        let heightNoScroll = outer.offsetHeight;\r\n\r\n        // force scrollbars\r\n        outer.style.overflow = 'scroll';\r\n\r\n        // add innerdiv\r\n        let inner = document.createElement('div');\r\n        inner.style.width = '100%';\r\n        inner.style.height = '100%';\r\n        outer.appendChild(inner);\r\n\r\n        let widthWithScroll = inner.offsetWidth;\r\n        let heightWithScroll = inner.offsetHeight;\r\n\r\n        // remove divs\r\n        (outer.parentNode as HTMLElement).removeChild(outer);\r\n\r\n        return {\r\n            width: widthNoScroll - widthWithScroll,\r\n            height: heightNoScroll - heightWithScroll,\r\n        };\r\n    }\r\n}","import { Pathway } from './Pathway';\r\nimport { Region } from './Region';\r\nimport { Tile } from './Tile';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { Hatching } from './Hatching';\r\n\r\nexport class Dungeon implements IGraph<Region, Pathway> {\r\n    nodes: Region[] = [];\r\n    lines: Pathway[] = [];\r\n    backdropPoints: Hatching[] = [];\r\n    delauneyLines: Pathway[] = [];\r\n    gabrielLines: Pathway[] = [];\r\n    relativeNeighbourhoodLines: Pathway[] = [];\r\n    minimumSpanningLines: Pathway[] = [];\r\n\r\n    width: number = 0;\r\n    height: number = 0;\r\n\r\n    tiles: Tile[] = [];\r\n    tilesByCoordinates: Tile[][] = [];\r\n    walls: Curve[] = [];\r\n\r\n    public getTileAt(x: number, y: number) {\r\n        const col = this.tilesByCoordinates[Math.floor(x)];\r\n\r\n        if (col === undefined) {\r\n            return;\r\n        }\r\n\r\n        return col[Math.floor(y)];\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { Pathway } from './model/Pathway';\r\nimport { Region } from './model/Region';\r\nimport { Tile } from './model/Tile';\r\nimport { Curve } from '../lib/model/Curve';\r\nimport { IRenderSettings } from './IRenderSettings';\r\n\r\nexport function renderDungeon(   \r\n    dungeon: Dungeon,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n) {\r\n    ctx.clearRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n\r\n    if (settings.drawGrid) {\r\n        drawTileGrid(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.graphAlpha > 0) {\r\n        drawGraph(ctx, dungeon, settings);\r\n    }\r\n    \r\n    if (settings.drawOutside) {\r\n        fillOutside(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawOutsidePoints) {\r\n        drawOutsidePoints(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawWalls) {\r\n        ctx.strokeStyle = ctx.fillStyle = settings.highlightWallCurves ? '#f00' : '#000';\r\n        ctx.lineCap = 'round';\r\n        for (const curve of dungeon.walls) {\r\n            drawCurve(curve, ctx, settings);\r\n        }\r\n        ctx.lineCap = 'butt';\r\n    }\r\n    \r\n    if (settings.drawNodeLinks) {\r\n        ctx.lineWidth = settings.linkWidth;\r\n        ctx.strokeStyle = settings.linkColor;\r\n        for (let line of dungeon.lines) {\r\n            drawPath(line, ctx, settings);\r\n        }\r\n    }\r\n\r\n    if (settings.nodeAlpha > 0) {\r\n        ctx.globalAlpha = settings.nodeAlpha;\r\n        for (let i = 0; i < dungeon.nodes.length; i++) {\r\n            drawNode(dungeon.nodes[i], ctx, settings);\r\n        }\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawTileGrid(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.lineWidth = settings.floorGridWidth;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        drawTile(tile, ctx, settings);\r\n    }\r\n}\r\n\r\nfunction drawPath(pathway: Pathway, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(pathway.from.x * settings.cellSize, pathway.from.y * settings.cellSize);\r\n    ctx.lineTo(pathway.to.x * settings.cellSize, pathway.to.y * settings.cellSize);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction drawNode(room: Region, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.fillStyle = '#c00';\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(room.x * settings.cellSize, room.y * settings.cellSize, settings.cellSize * room.radius, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n}\r\n\r\nfunction drawTile(tile: Tile, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    if (tile.isFloor && (!tile.isWall || settings.drawWallsAsFloor)) {\r\n        ctx.fillStyle = settings.floorColor;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.strokeStyle = settings.floorGridColor;\r\n        ctx.strokeRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n    else if (tile.isWall) {\r\n        ctx.fillStyle = '#333';\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n\r\n    if (settings.regionAlpha > 0 && tile.region !== null) {\r\n        ctx.globalAlpha = settings.regionAlpha;\r\n        ctx.fillStyle = tile.region.color;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.globalAlpha = settings.graphAlpha;\r\n    ctx.strokeStyle = '#000';\r\n\r\n    ctx.lineWidth = settings.minimumSpanningWidth;\r\n    for (let line of dungeon.minimumSpanningLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.relativeNeighbourhoodWidth;\r\n    for (let line of dungeon.relativeNeighbourhoodLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.gabrielWidth;\r\n    for (let line of dungeon.gabrielLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.delauneyWidth;\r\n    for (let line of dungeon.delauneyLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.globalAlpha = 1;\r\n}\r\n\r\nfunction drawCurve(\r\n    curve: Curve,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n    draw: boolean = true\r\n) {\r\n    let halfCellSize = settings.cellSize / 2;\r\n\r\n    if (curve.keyPoints.length === 1) {\r\n        if (draw) {\r\n            let cell = curve.keyPoints[0];\r\n            let cx = cell.x * settings.cellSize + halfCellSize;\r\n            let cy = cell.y * settings.cellSize + halfCellSize;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy, settings.wallWidth / 2, 0, Math.PI * 2);\r\n        \r\n            ctx.fill();\r\n        }\r\n        return;\r\n    }\r\n    \r\n    let points = curve.renderPoints;\r\n    let x = points[0] * settings.cellSize + halfCellSize;\r\n    let y = points[1] * settings.cellSize + halfCellSize;\r\n    \r\n    if (draw) {\r\n        ctx.beginPath();\r\n    }\r\n    ctx.moveTo(x, y);\r\n    \r\n    ctx.lineWidth = settings.wallWidth;\r\n    for (let i = 0; i < points.length; i += 2) {\r\n        x = points[i] * settings.cellSize + halfCellSize;\r\n        y = points[i + 1] * settings.cellSize + halfCellSize;\r\n        ctx.lineTo(x, y);\r\n    }\r\n\r\n    if (draw) {\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nfunction clipOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    for (let curve of dungeon.walls) {\r\n        drawCurve(curve, ctx, settings, false);\r\n    }\r\n    ctx.clip('evenodd');\r\n}\r\n\r\nfunction fillOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.fillStyle = settings.backgroundColor;\r\n\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.fillRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    \r\n    ctx.strokeStyle = settings.hatchingColor;\r\n    ctx.lineWidth = settings.hatchingWidth;\r\n\r\n    const xScale = settings.cellSize * 0.6;\r\n    for (const point of dungeon.backdropPoints) {\r\n        const yScale = settings.cellSize * point.lengthScale;\r\n        \r\n        ctx.save();\r\n\r\n        ctx.translate(point.x * settings.cellSize, point.y * settings.cellSize);\r\n        ctx.rotate(point.rotation);\r\n\r\n        // first clear the background of this segment\r\n        ctx.beginPath();\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n        ctx.fill();\r\n\r\n        // then draw the lines\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.moveTo(0, -yScale);\r\n        ctx.lineTo(0, yScale);\r\n\r\n        ctx.moveTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction drawOutsidePoints(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.globalAlpha = 0.75;\r\n    ctx.fillStyle = '#009';\r\n\r\n    for (const point of dungeon.backdropPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(point.x * settings.cellSize, point.y * settings.cellSize, settings.cellSize * 0.25, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n}","// based on http://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/lib/alea.js\r\n\r\nexport class SRandom {\r\n    private c: number;\r\n    private s0: number;\r\n    private s1: number;\r\n    private s2: number;\r\n\r\n    constructor(public readonly seed: number | string) {\r\n        var mash = this.mash();\r\n\r\n        this.c = 1;\r\n        this.s0 = mash(' ');\r\n        this.s1 = mash(' ');\r\n        this.s2 = mash(' ');\r\n\r\n        this.s0 -= mash(seed);\r\n        if (this.s0 < 0) {\r\n            this.s0 += 1;\r\n        }\r\n\r\n        this.s1 -= mash(seed);\r\n        if (this.s1 < 0) {\r\n            this.s1 += 1;\r\n        }\r\n\r\n        this.s2 -= mash(seed);\r\n        if (this.s2 < 0) {\r\n            this.s2 += 1;\r\n        }\r\n    }\r\n\r\n    next() {\r\n        let t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        return this.s2 = t - (this.c = t | 0);\r\n    }\r\n    \r\n    nextInt32() {\r\n        return (this.next() * 0x100000000) | 0;\r\n    }\r\n\r\n    nextInRange(min: number, max: number) {\r\n        return min + this.next() * (max - min);\r\n    }\r\n\r\n    nextIntInRange(minInclusive: number, maxExclusive: number) {\r\n        return Math.floor(this.nextInRange(minInclusive, maxExclusive));\r\n    }\r\n\r\n    nextColor() {\r\n        const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n        const r = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const g = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const b = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        return `#${r}${g}${b}`;\r\n    }\r\n\r\n    private mash() {\r\n        let n = 0xefc8249d;\r\n\r\n        let mash = function(data: number | string) {\r\n            data = data.toString();\r\n            for (var i = 0; i < data.length; i++) {\r\n                n += data.charCodeAt(i);\r\n                var h = 0.02519603282416938 * n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                h *= n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                n += h * 0x100000000; // 2^32\r\n            }\r\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\r\n        };\r\n\r\n        return mash;\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\nimport { Line } from '../../lib/model/Line';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function createRegions(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // Remove all nodes, then create nodeCount nodes. Using same seed ensures same ones are recreated.\r\n    const random = new SRandom(seed);\r\n\r\n    let makeNode = () => {\r\n        const x = random.nextInRange(3, dungeon.width - 4);\r\n        const y = random.nextInRange(3, dungeon.height - 4);\r\n        const influence = random.nextInRange(0.6, 1.8);\r\n        const regionType = random.nextIntInRange(0, RegionType.NUM_VALUES);\r\n        const seed = random.next();\r\n        const color = random.nextColor();\r\n        return new Region(dungeon, x, y, seed, regionType, color, influence);\r\n    };\r\n\r\n    dungeon.nodes = [];\r\n    for (let i = 0; i < settings.nodeCount; i++) {\r\n        addSpacedNode(dungeon, makeNode, dungeon.width, dungeon.height);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n}\r\n\r\nfunction addSpacedNode<TNode extends Coord2D, TLine extends Line<TNode>>(\r\n    dungeon: IGraph<TNode, TLine>,\r\n    makeNode: () => TNode,\r\n    totWidth: number,\r\n    totHeight: number\r\n) {\r\n    const getScaledDistSq = (n1: TNode, n2: TNode, width: number, height: number) => {\r\n        let dxScaled = (n1.x - n2.x) / width;\r\n        let dyScaled = (n1.y - n2.y) / height;\r\n        return dxScaled * dxScaled + dyScaled * dyScaled;\r\n    };\r\n\r\n    // create two nodes, and go with the one that's furthest away from the nearest node\r\n    let node1 = makeNode(), node2 = makeNode();\r\n    let closestDist1 = Number.MAX_VALUE, closestDist2 = Number.MAX_VALUE;\r\n    for (let node of dungeon.nodes) {\r\n        // scale x/y distances, so width/height changes don't change which node is chosen during regeneration\r\n        closestDist1 = Math.min(closestDist1, getScaledDistSq(node1, node, totWidth, totHeight));\r\n        closestDist2 = Math.min(closestDist2, getScaledDistSq(node2, node, totWidth, totHeight));\r\n    }\r\n\r\n    dungeon.nodes.push(closestDist1 < closestDist2 ? node2 : node1);\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Polygon<TNode extends Coord<TNode>> {\r\n    constructor(readonly vertices: TNode[]) {\r\n        \r\n    }\r\n}","import { Coord } from './Coord';\r\nimport { Polygon } from './Polygon';\r\n\r\nexport class Triangle<TNode extends Coord<TNode>> extends Polygon<TNode> {\r\n    circumCenter: Coord<TNode>;\r\n    circumRadiusSq: number;\r\n\r\n    constructor(vertices: [TNode, TNode, TNode]) {\r\n        super(vertices);\r\n\r\n        let circumCircle = vertices[0].circumCircle(vertices[1], vertices[2]);\r\n\r\n        this.circumCenter = circumCircle[0];\r\n        this.circumRadiusSq = circumCircle[1];\r\n    }\r\n}","import { Coord } from '../model/Coord';\r\nimport { Triangle } from '../model/Triangle';\r\n\r\nexport function computeDelauneyTriangulation<TNode extends Coord<TNode>>(\r\n    nodes: TNode[],\r\n    superTriangle: [TNode, TNode, TNode]\r\n) {\r\n    if (nodes.length < 3) {\r\n        return [];\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm\r\n    let triangulation: Triangle<TNode>[] = [];\r\n    triangulation.push(new Triangle(superTriangle));\r\n\r\n    for (let node of nodes) {\r\n        // find all triangles that are no longer valid due to this node's insertion\r\n        let badTriangles: Triangle<TNode>[] = [];\r\n        for (let triangle of triangulation) {\r\n            if (insideCircumcircle(node, triangle)) {\r\n                badTriangles.push(triangle);\r\n            }\r\n        }\r\n\r\n        // Find the boundary of polygonal hole formed by these \"bad\" triangles...\r\n        // Get the edges of the \"bad\" triangles which don't touch other bad triangles...\r\n        // Each pair of nodes here represents a line.\r\n        let polygon: TNode[] = [];\r\n        for (let triangle of badTriangles) {\r\n            for (let i = 0; i < 3; i++) {\r\n                let edgeFrom = triangle.vertices[i];\r\n                let edgeTo = triangle.vertices[i === 2 ? 0 : i + 1];\r\n\r\n                let sharedWithOther = false;\r\n                for (let other of badTriangles) {\r\n                    if (other === triangle) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeFrom) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeTo) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    sharedWithOther = true;\r\n                    break;\r\n                }\r\n\r\n                if (!sharedWithOther) {\r\n                    polygon.push(edgeFrom, edgeTo);\r\n                }\r\n            }\r\n        }\r\n\r\n        // discard all bad triangles\r\n        for (let triangle of badTriangles) {\r\n            triangulation.splice(triangulation.indexOf(triangle), 1);\r\n        }\r\n\r\n        // re-triangulate the polygonal hole ... create a new triangle for each edge\r\n        for (let i = 0; i < polygon.length - 1; i += 2) {\r\n            let triangle = new Triangle<TNode>([polygon[i], polygon[i + 1], node]);\r\n            triangulation.push(triangle);\r\n        }\r\n    }\r\n\r\n    // remove all triangles that contain a vertex from the original super-triangle\r\n    for (let i = 0; i < triangulation.length; i++) {\r\n        let triangle = triangulation[i];\r\n        for (let vertex of triangle.vertices) {\r\n            if (superTriangle.indexOf(vertex) !== -1) {\r\n                triangulation.splice(i, 1);\r\n                i--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return triangulation;\r\n}\r\n\r\nfunction insideCircumcircle<TNode extends Coord<TNode>>(\r\n    point: TNode,\r\n    triangle: Triangle<TNode>\r\n) {\r\n    let distSq = point.distanceSqTo(triangle.circumCenter);\r\n    return distSq <= triangle.circumRadiusSq;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeGabrielGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n\r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let center = link.from.halfwayTo(link.to);\r\n        let radiusSq = link.from.distanceSqTo(center);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(center) < radiusSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}","import { Coord } from '../model/Coord';\r\nimport { Line } from '../model/Line';\r\nimport { Polygon } from '../model/Polygon';\r\n\r\nexport function getUniqueLines<TNode extends Coord<TNode>, TLine extends Line<TNode>>\r\n(\r\n    polygons: Polygon<TNode>[], \r\n    createLine: (from: TNode, to: TNode) => TLine\r\n) {\r\n    const allLines: TLine[] = [];\r\n\r\n    // Convert polygons to UNIQUE lines, ignoring their direction.\r\n    for (const polygon of polygons) {\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            const v0 = polygon.vertices[i === 0 ? polygon.vertices.length - 1 : i - 1];\r\n            const v1 = polygon.vertices[i];\r\n\r\n            const isDuplicate = allLines.some(l => (l.from === v0 && l.to === v1) || (l.from === v1 && l.to === v0));\r\n            if (!isDuplicate) {\r\n                allLines.push(createLine(v0, v1));\r\n            }\r\n        }\r\n    }\r\n\r\n    return allLines;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeMinimumSpanningTree<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let unvisitedNodes = graph.nodes.slice();\r\n    let firstNode = unvisitedNodes.pop();\r\n    if (firstNode === undefined) {\r\n        return [];\r\n    }\r\n    \r\n    let possibleLinks = links.map(l => ({ link: l, lengthSq: l.from.distanceSqTo(l.to) }));\r\n    possibleLinks.sort((a, b) => a.lengthSq - b.lengthSq);\r\n\r\n    let visitedNodes: TNode[] = [firstNode];\r\n    let graphLinks: TLine[] = [];\r\n\r\n    while (unvisitedNodes.length > 0 && possibleLinks.length > 0) {\r\n        // Find the first link that connects to a node in visitedNodes...\r\n        // The links are sorted by length, so the first one will be the shortest one.\r\n        for (let i = 0; i < possibleLinks.length; i++) {\r\n            let testLink = possibleLinks[i].link;\r\n            \r\n            let alreadyHasFrom = visitedNodes.indexOf(testLink.from) !== -1;\r\n            let alreadyHasTo = visitedNodes.indexOf(testLink.to) !== -1;\r\n\r\n            // if it doesn't connect to the graph at all, discard it\r\n            if (!alreadyHasFrom && !alreadyHasTo) {\r\n                continue;\r\n            }\r\n\r\n            possibleLinks.splice(i, 1);\r\n            graphLinks.push(testLink);\r\n\r\n            let addingNode = alreadyHasFrom ? testLink.to : testLink.from;\r\n            \r\n            // remove all other links from possibleLinks that connect addingNode to visitedNodes\r\n            for (let j = i; j < possibleLinks.length; j++) {\r\n                testLink = possibleLinks[j].link;\r\n                if ((testLink.from === addingNode && visitedNodes.indexOf(testLink.to) !== -1)\r\n                || (testLink.to === addingNode && visitedNodes.indexOf(testLink.from) !== -1)) {\r\n                    possibleLinks.splice(j, 1);\r\n                    j--;\r\n                }\r\n            }\r\n\r\n            visitedNodes.push(addingNode);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeRelativeNeighbourhoodGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>, \r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n    \r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let lengthSq = link.from.distanceSqTo(link.to);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(link.from) < lengthSq && node.distanceSqTo(link.to) < lengthSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Line } from '../../lib/model/Line';\r\nimport { Region } from './Region';\r\n\r\nexport class Pathway extends Line<Region> {\r\n    constructor(from: Region, to: Region) {\r\n        super(from, to);\r\n\r\n        from.links.push(this);\r\n        to.links.push(this);\r\n    }\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Line<TCoord extends Coord<TCoord>> {\r\n    constructor(public from: TCoord, public to: TCoord) {\r\n\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport {\r\n    computeDelauneyTriangulation,\r\n    getUniqueLines,\r\n    computeGabrielGraph,\r\n    computeRelativeNeighbourhoodGraph,\r\n    computeMinimumSpanningTree\r\n} from '../../lib/graph';\r\nimport { Pathway } from '../model/Pathway';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function populateLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    console.log('setting lines C');\r\n    dungeon.lines = [];\r\n    dungeon.delauneyLines = [];\r\n    dungeon.gabrielLines = [];\r\n    dungeon.relativeNeighbourhoodLines = [];\r\n    dungeon.minimumSpanningLines = [];\r\n\r\n    const enclosingTriangle: [Region, Region, Region] = [\r\n        new Region(dungeon, 0, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 999999, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 0, 999999, 0, RegionType.Artificial, ''),\r\n    ];\r\n\r\n    const delauneyTriangles = computeDelauneyTriangulation(dungeon.nodes, enclosingTriangle);\r\n    \r\n    dungeon.delauneyLines = getUniqueLines(delauneyTriangles, (from, to) => new Pathway(from, to));\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.gabrielLines = computeGabrielGraph(dungeon, dungeon.delauneyLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.relativeNeighbourhoodLines = computeRelativeNeighbourhoodGraph(dungeon, dungeon.gabrielLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.minimumSpanningLines = computeMinimumSpanningTree(dungeon, dungeon.relativeNeighbourhoodLines);\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function filterLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let selectingFrom: Pathway[];\r\n    let selectFraction: number;\r\n        \r\n    if (settings.connectivity < 50) {\r\n        console.log('setting lines A');\r\n        dungeon.lines = dungeon.minimumSpanningLines.slice();\r\n\r\n        selectingFrom = dungeon.relativeNeighbourhoodLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = settings.connectivity / 50;\r\n    } else {\r\n        console.log('setting lines B');\r\n        dungeon.lines = dungeon.relativeNeighbourhoodLines.slice();\r\n\r\n        selectingFrom = dungeon.gabrielLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = (settings.connectivity - 50) / 50;\r\n    }\r\n    \r\n    let random = new SRandom(seed);\r\n    let numToSelect = Math.round(selectingFrom.length * selectFraction);\r\n\r\n    for (let i = numToSelect; i > 0; i--) {\r\n        let selectedLink = selectingFrom.splice(random.nextIntInRange(0, selectingFrom.length), 1)[0];\r\n        dungeon.lines.push(selectedLink);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function populateCaveRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    \r\n    const regionTiles = dungeon.tiles.filter(t => t.region === region);\r\n    const nonEdgeTiles = regionTiles.filter(t => t.adjacentTiles.length === 8 && !t.adjacentTiles.some(a => a.region !== region));\r\n    \r\n    const mutableTiles = nonEdgeTiles.filter(t => !t.isFloor);\r\n\r\n    // make half the non-edge cells \"alive\"\r\n    for (const tile of nonEdgeTiles) {\r\n        if (random.next() < 0.5) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < 8; i++) {\r\n        runCellularAutomataStep(mutableTiles);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n\r\n    removeUnconnectedFloorTiles(dungeon, region, nonEdgeTiles);\r\n}\r\n\r\nfunction runCellularAutomataStep(cells: Tile[]) {\r\n    const results = new Map<Tile, boolean>();\r\n\r\n    for (const cell of cells) {\r\n        // alive becomes dead if < 4 alive around it\r\n        // dead becomes alive if > 4 alive around it\r\n\r\n        const wasAlive = cell.isFloor;\r\n        const numAdjacentLiving = cell.adjacentTiles.filter(t => t.isFloor).length;\r\n\r\n        const shouldLive = wasAlive\r\n            ? numAdjacentLiving >= 4\r\n            : numAdjacentLiving > 4\r\n\r\n        results.set(cell, shouldLive);\r\n    }\r\n\r\n    for (const [cell, result] of results) {\r\n        cell.isFloor = result;\r\n    }\r\n}\r\n\r\nfunction removeUnconnectedFloorTiles(dungeon: Dungeon, region: Region, regionTiles: Tile[]) {    \r\n    const rootTile = dungeon.tilesByCoordinates[Math.floor(region.x)][Math.floor(region.y)];\r\n    \r\n    const connectedTiles = new Set([rootTile]);\r\n    let tilesToTest = [...rootTile.adjacentTiles];\r\n\r\n    while (true) {\r\n        const tile = tilesToTest.pop();\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        if (!tile.isFloor || tile.region !== region || connectedTiles.has(tile)) {\r\n            continue;\r\n        }\r\n\r\n        connectedTiles.add(tile);\r\n\r\n        tilesToTest = [\r\n            ...tilesToTest,\r\n            ...tile.adjacentTiles,\r\n        ];\r\n    }\r\n\r\n    for (const tile of regionTiles) {\r\n        if (tile.isFloor && !connectedTiles.has(tile)) {\r\n            tile.isFloor = false;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\n\r\nexport async function populateRoomRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    const nodeX = Math.floor(region.x);\r\n    const nodeY = Math.floor(region.y);\r\n\r\n    const { minX, minY, maxX, maxY } = determineBounds(dungeon, region, nodeX, nodeY, random);\r\n\r\n    for (let x = minX; x <= maxX; x++) {\r\n        for (let y = minY; y <= maxY; y++) {\r\n            let tile = dungeon.tilesByCoordinates[x][y];\r\n            if (tile.region !== region) {\r\n                continue;\r\n            }\r\n\r\n            tile.isFloor = true;\r\n            tile.region = region;\r\n        }\r\n    }\r\n}\r\n\r\nfunction determineBounds(dungeon: Dungeon, region: Region, nodeX: number, nodeY: number, random: SRandom) {\r\n    // determine the biggest possible size this room could be\r\n    let minX = nodeX, maxX = nodeX, minY = nodeY, maxY = nodeY;\r\n\r\n    if (random.next() < 0.5) {\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n    else {\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    // now possibly shrink from the maximum possible size\r\n    if (random.next() < 0.75) {\r\n        minX = random.nextIntInRange(minX, nodeX);\r\n        maxX = random.nextIntInRange(nodeX + 1, maxX + 1);\r\n        minY = random.nextIntInRange(minY, nodeY);\r\n        maxY = random.nextIntInRange(nodeY + 1, maxY + 1);    \r\n    }\r\n\r\n    return {\r\n        minX,\r\n        minY,\r\n        maxX,\r\n        maxY,\r\n    };\r\n}\r\n\r\nfunction growUpLeft(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canLeft = true, canUp = true;\r\n\r\n    while (canLeft || canUp) {\r\n        if (canUp && random.next() < 0.5) {\r\n            canUp = isRowInRegion(dungeon, region, minY - 1, minX, maxX)\r\n                && --minY > 2;\r\n        }\r\n        else if (canLeft) {\r\n            canLeft = isColInRegion(dungeon, region, minX - 1, minY, maxY)\r\n                && --minX > 2;\r\n        }\r\n    }\r\n\r\n    return [minX, minY];\r\n}\r\n\r\n\r\nfunction growDownRight(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canRight = true, canDown = true;\r\n\r\n    while (canRight || canDown) {\r\n        if (canDown && random.next() < 0.5) {\r\n            canDown = isRowInRegion(dungeon, region, maxY + 1, minX, maxX)\r\n                && ++maxY < dungeon.height - 3;\r\n        }\r\n        else if (canRight) {\r\n            canRight = isColInRegion(dungeon, region, maxX + 1, minY, maxY)\r\n                && ++maxX < dungeon.width - 3;\r\n        }\r\n    }\r\n\r\n    return [maxX, maxY];\r\n}\r\n\r\nfunction isColInRegion(dungeon: Dungeon, region: Region, x: number, y1: number, y2: number) {\r\n    const col = dungeon.tilesByCoordinates[x];\r\n\r\n    for (let y = y1; y <= y2; y++) {\r\n        if (col[y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isRowInRegion(dungeon: Dungeon, region: Region, y: number, x1: number, x2: number) {\r\n    for (let x = x1; x <= x2; x++) {\r\n        if (dungeon.tilesByCoordinates[x][y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { RegionType } from '../model/Region';\r\nimport { populateCaveRegion } from './populateCaveRegion';\r\nimport { populateRoomRegion } from './populateRoomRegion';\r\n\r\nexport async function createRooms(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const region of dungeon.nodes) {\r\n        switch (region.regionType) {\r\n            case RegionType.Natural:\r\n                await populateCaveRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            case RegionType.Artificial:\r\n                await populateRoomRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { RegionType } from '../model/Region';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function detectWalls(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isFloor) {\r\n            continue;\r\n        }\r\n\r\n        let toTest = getAdjacent(dungeon, tile, true, false);\r\n        for (let test of toTest) {\r\n            if (test.isFloor) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // artificial rooms should have \"corner\" wall nodes filled in\r\n        for (let test of tile.adjacentTiles) {\r\n            if (test.isFloor && test.region !== null && test.region.regionType === RegionType.Artificial) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Tiny);\r\n        }\r\n    }\r\n}\r\n\r\nexport function getAdjacent(dungeon: Dungeon, from: Tile, orthogonal: boolean = true, diagonal: boolean = false) {\r\n    let results = [];\r\n\r\n    if (orthogonal) {\r\n        if (from.x > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x - 1][from.y]);\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x + 1][from.y]);\r\n        }\r\n        if (from.y > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y - 1]);\r\n        }\r\n        if (from.y < dungeon.height - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y + 1]);\r\n        }\r\n    }\r\n    \r\n    if (diagonal) {\r\n        if (from.x > 0) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y + 1]);\r\n            }\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y + 1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n","import { Coord2D } from './Coord';\r\n\r\nexport class Curve {\r\n    static readonly stepsPerSegment = 16;\r\n\r\n    keyPoints: Coord2D[];\r\n    isLoop: boolean;\r\n    renderPoints: number[];\r\n\r\n    constructor(public curvature: number = 0.75) {\r\n        this.keyPoints = [];\r\n        this.isLoop = false;\r\n        this.renderPoints = [];\r\n    }\r\n\r\n    updateRenderPoints() {\r\n        this.renderPoints = [];\r\n\r\n        if (this.keyPoints.length < 2) {\r\n            return;\r\n        }\r\n\r\n        let tension = this.curvature;\r\n        let pts: number[] = [],\r\n            x: number, y: number,\r\n            t1x: number, t2x: number, t1y: number, t2y: number,\r\n            c1: number, c2: number, c3: number, c4: number,\r\n            fraction: number, step: number, iPt: number;\r\n\r\n        let firstCell = this.keyPoints[0];\r\n        let lastCell = this.keyPoints[this.keyPoints.length - 1];\r\n\r\n        // decide if it's a closed loop, which needs the ends of the array set up differently\r\n        let lastCellIndex: number;\r\n        if (firstCell === lastCell) {\r\n            lastCellIndex = this.keyPoints.length - 2; // don't copy the last cell, its the same as the first\r\n            lastCell = this.keyPoints[lastCellIndex];\r\n        } else {\r\n            lastCellIndex = this.keyPoints.length - 1;\r\n        }\r\n        \r\n        for (let cell of this.keyPoints) {\r\n            pts.push(cell.x, cell.y);\r\n        }\r\n        \r\n        if (this.isLoop) {\r\n            // copy last cell onto start, and first cells onto end\r\n            let secondCell = this.keyPoints[1];\r\n            pts.push(firstCell.x, firstCell.y);\r\n            pts.push(secondCell.x, secondCell.y);\r\n            pts.unshift(lastCell.x, lastCell.y);\r\n        } else {\r\n            // copy first cell onto start, and last cell onto end\r\n            pts.unshift(firstCell.x, firstCell.y);\r\n            pts.push(lastCell.x, lastCell.y);\r\n        }\r\n\r\n        // loop through key points. Use each set of 4 points p0 p1 p2 p3 to draw segment p1-p2.\r\n        for (iPt = 2; iPt < (pts.length - 4); iPt += 2) {\r\n            for (step = 0; step <= Curve.stepsPerSegment; step++) {\r\n                // tension vectors\r\n                t1x = (pts[iPt + 2] - pts[iPt - 2]) * tension;\r\n                t2x = (pts[iPt + 4] - pts[iPt]) * tension;\r\n\r\n                t1y = (pts[iPt + 3] - pts[iPt - 1]) * tension;\r\n                t2y = (pts[iPt + 5] - pts[iPt + 1]) * tension;\r\n\r\n                fraction = step / Curve.stepsPerSegment;\r\n\r\n                // cardinals\r\n                c1 =   2 * Math.pow(fraction, 3)  - 3 * Math.pow(fraction, 2) + 1; \r\n                c2 = -(2 * Math.pow(fraction, 3)) + 3 * Math.pow(fraction, 2); \r\n                c3 =       Math.pow(fraction, 3)  - 2 * Math.pow(fraction, 2) + fraction; \r\n                c4 =       Math.pow(fraction, 3)  -     Math.pow(fraction, 2);\r\n\r\n                // x and y coordinates\r\n                x = c1 * pts[iPt]    + c2 * pts[iPt + 2] + c3 * t1x + c4 * t2x;\r\n                y = c1 * pts[iPt + 1]  + c2 * pts[iPt + 3] + c3 * t1y + c4 * t2y;\r\n                this.renderPoints.push(x);\r\n                this.renderPoints.push(y);\r\n            }\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { getAdjacent } from './detectWalls';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function generateWallCurves(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.walls = [];\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isWall && !tile.isFloor) {\r\n            await generateWallCurve(dungeon, tile, true, subStepComplete);\r\n\r\n            if (subStepComplete) {\r\n                await subStepComplete(DelaySize.Medium);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const curve of dungeon.walls) {\r\n        curve.updateRenderPoints();\r\n    }\r\n}\r\n\r\nasync function generateWallCurve(dungeon: Dungeon, firstTile: Tile, isRootLevel: boolean, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const mainCurve = await generateSingleWallCurve(dungeon, firstTile, subStepComplete);\r\n\r\n    while (true) {\r\n        // See if we could have taken a different path at any point.\r\n        const newStartPoint = backtrackToNewStartPoint(dungeon, mainCurve);\r\n        if (newStartPoint === undefined) {\r\n            if (isRootLevel) {\r\n                checkForCurveLoops(dungeon, mainCurve);\r\n            }\r\n\r\n            if (subStepComplete !== undefined) {\r\n                mainCurve.updateRenderPoints();\r\n            }\r\n            return mainCurve;\r\n        }\r\n\r\n        // See if the different path is longer.\r\n        const branchIndex = mainCurve.keyPoints.indexOf(newStartPoint);\r\n        \r\n        const newCurve = await generateWallCurve(dungeon, newStartPoint, false, subStepComplete);\r\n\r\n        if (newCurve.keyPoints.length <= mainCurve.keyPoints.length - branchIndex || newStartPoint === firstTile) {\r\n            continue;\r\n        }\r\n\r\n        // Swap the paths around so that this path is as long as possible.\r\n\r\n        let newBranch = newCurve.keyPoints.slice(1);\r\n        let oldBranch = mainCurve.keyPoints.splice(branchIndex + 1);\r\n        oldBranch.unshift(newStartPoint);\r\n\r\n        newCurve.keyPoints = oldBranch;\r\n        mainCurve.keyPoints = mainCurve.keyPoints.concat(newBranch);\r\n        \r\n        if (isRootLevel) {\r\n            checkForCurveLoops(dungeon, newCurve);\r\n        }\r\n\r\n        if (subStepComplete !== undefined) {\r\n            newCurve.updateRenderPoints();\r\n            mainCurve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}\r\n\r\nfunction backtrackToNewStartPoint(dungeon: Dungeon, curve: Curve) {\r\n    // iterate backwards round this curve, trying to find somewhere to branch off a new curve from\r\n    for (let i = curve.keyPoints.length - 1; i >= 0; i--) {\r\n        let curveTile = curve.keyPoints[i] as Tile;\r\n\r\n        let viableTile = pickBestAdjacentWallTile(dungeon, curveTile, true, true, t => !t.isFloor && t.isWall);\r\n        if (viableTile !== undefined) {\r\n            return curveTile;\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction checkForCurveLoops(dungeon: Dungeon, mainCurve: Curve, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    // detect simple loops, as well as \"p\" and \"b\" loops that need split into two parts\r\n    const firstPoint = mainCurve.keyPoints[0];\r\n    const lastPoint = mainCurve.keyPoints[mainCurve.keyPoints.length - 1];\r\n    \r\n    if (firstPoint === lastPoint) {\r\n        mainCurve.isLoop = true;\r\n    } else {\r\n        let splitPos = mainCurve.keyPoints.lastIndexOf(firstPoint);\r\n        if (splitPos > 0) {\r\n            // p shape, loop at the start\r\n            const splitCurve = new Curve();\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(splitPos + 1);\r\n            splitCurve.keyPoints.unshift(mainCurve.keyPoints[splitPos]);\r\n\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n            \r\n            mainCurve.isLoop = true;\r\n            // console.log('found a P, splitting linear end bit into its own curve');\r\n        }\r\n        \r\n        splitPos = mainCurve.keyPoints.indexOf(lastPoint);\r\n        if (splitPos < mainCurve.keyPoints.length - 1) {\r\n            // b shape, loop at the end\r\n            /*\r\n            console.log(`loop found in curve ${dungeon.walls.indexOf(mainCurve)} at index ${splitPos} ... 0-${splitPos} will separate off linearly, keeping from ${splitPos}-${mainCurve.keyPoints.length - 1} as a loop`);\r\n            console.log(`index ${0} is ${mainCurve.keyPoints[0].x}, ${mainCurve.keyPoints[0].y}`);\r\n            console.log(`index ${splitPos} is ${mainCurve.keyPoints[splitPos].x}, ${mainCurve.keyPoints[splitPos].y}`);\r\n            console.log(`index ${mainCurve.keyPoints.length - 1} is ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].x}, ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].y}`);\r\n            */\r\n            const splitCurve = new Curve();\r\n            const splitPoint = mainCurve.keyPoints[splitPos];\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(0, splitPos - 1);\r\n            splitCurve.keyPoints.push(splitPoint);\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n\r\n            mainCurve.isLoop = true;\r\n            // console.log('found a B, splitting linear start bit into its own curve');\r\n\r\n            /*\r\n            console.log(`after splitting, main curve is ${mainCurve.keyPoints.length} long`);\r\n            console.log(`split curve is ${splitCurve.keyPoints.length} long`);\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\nexport async function generateSingleWallCurve(dungeon: Dungeon, firstTile: Tile, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const curve = new Curve();\r\n    dungeon.walls.push(curve);\r\n\r\n    let prevTile: Tile | undefined = firstTile;\r\n\r\n    // If there's an adjacent tile that's already part of a wall curve, start from that instead.\r\n    const actualFirstTile = getAdjacent(dungeon, firstTile, true, true)\r\n        .find(t => t.isWall && t.isFloor);\r\n    if (actualFirstTile !== undefined) {\r\n        curve.keyPoints.push(actualFirstTile);\r\n        firstTile = actualFirstTile;\r\n    }\r\n\r\n    curve.keyPoints.push(prevTile);\r\n    prevTile.isFloor = true;\r\n\r\n    do {\r\n        // Pick next tile, keep looping. When there isn't a next one, stop. Initially, only look orthogonally.\r\n        let tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n            dungeon,\r\n            prevTile,\r\n            t => !t.isFloor && t.isWall\r\n        );\r\n\r\n        if (tile === undefined) {\r\n            // Do the same check again, but don't ignore tiles that are part of walls. This will be the last one.\r\n            const lastTile = curve.keyPoints.length > 2\r\n                ? curve.keyPoints[curve.keyPoints.length - 2]\r\n                : undefined;\r\n\r\n            tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n                dungeon,\r\n                prevTile,\r\n                t => t.isWall && t !== lastTile\r\n            );\r\n            prevTile = undefined;\r\n        }\r\n        else {\r\n            prevTile = tile;\r\n        }\r\n\r\n        if (tile === firstTile) {\r\n            curve.isLoop = true;\r\n            break;\r\n        }\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        curve.keyPoints.push(tile);\r\n\r\n        if (tile.isFloor) {\r\n            break; // intersected a(nother) curve, so end this one\r\n        }\r\n\r\n        tile.isFloor = true;\r\n        \r\n        if (subStepComplete) {\r\n            curve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n\r\n    } while (prevTile !== undefined)\r\n\r\n    if (subStepComplete) {\r\n        curve.updateRenderPoints();\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    return curve;\r\n}\r\n\r\nexport function pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    const ortho = pickBestAdjacentWallTile(dungeon, from, true, false, filter);\r\n    return ortho !== undefined\r\n        ? ortho\r\n        : pickBestAdjacentWallTile(dungeon, from, false, true, filter);\r\n}\r\n\r\nfunction pickBestAdjacentWallTile(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    orthogonal: boolean,\r\n    diagonal: boolean,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    let bestTile: Tile | undefined;\r\n    let bestNumAdjacentNonWallTiles = 0;\r\n\r\n    let toTest = getAdjacent(dungeon, from, orthogonal, diagonal);\r\n    for (let tile of toTest) {\r\n        if (!filter(tile)) {\r\n            continue;\r\n        }\r\n\r\n        let numAdjacentNonWallTiles = 0;\r\n        let allAdjacent = getAdjacent(dungeon, tile, true, true);\r\n\r\n        for (let adjacent of allAdjacent) {\r\n            if (!adjacent.isWall) {\r\n                numAdjacentNonWallTiles++;\r\n            }\r\n        }\r\n\r\n        if (numAdjacentNonWallTiles > bestNumAdjacentNonWallTiles) {\r\n            bestNumAdjacentNonWallTiles = numAdjacentNonWallTiles;\r\n            bestTile = tile;\r\n        }\r\n    }\r\n    \r\n    return bestTile;\r\n}","import { Coord } from '../model/Coord';\r\n\r\nexport function getClosest<TNode extends Coord<TNode>>(\r\n    point: Coord<TNode>,\r\n    nodes: TNode[],\r\n    getDistance: (node: TNode, point: Coord<TNode>) => number = (node, point) => point.distanceSqTo(node),\r\n) {\r\n    let bestDist = Number.MAX_VALUE;\r\n    let bestNode: TNode | null = null;\r\n\r\n    for (const node of nodes) {\r\n        const dist = getDistance(node, point);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestNode = node;\r\n        }\r\n    }\r\n\r\n    return bestNode;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { getClosest } from '../../lib/graph/getClosest';\r\nimport { Region } from '../model/Region';\r\nimport { Coord } from '../../lib/model/Coord';\r\n\r\nexport async function associateTilesWithNodes(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n\r\n    const distance = (room: Region, point: Coord<Region>) => point.distanceSqTo(room) / room.regionInfluence;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        tile.region = getClosest(tile, dungeon.nodes, distance);\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n    }\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { SRandom } from '../../lib/SRandom';\r\n\r\nexport class Hatching extends Coord2D {\r\n    public readonly rotation: number;\r\n    public readonly lengthScale: number;\r\n    public readonly topSkew: number;\r\n    public readonly bottomSkew: number;\r\n\r\n    constructor(x: number, y: number, seed?: number) {\r\n        if (seed === undefined) {\r\n            super(x + 0.5, y + 0.5);\r\n            this.rotation = 0;\r\n            this.lengthScale = 1;\r\n            this.topSkew = 0;\r\n            this.bottomSkew = 0;\r\n            return;\r\n        }\r\n\r\n        const random = new SRandom(seed + x * x * 4987142 + x * 5947611 + y * y * 4392871 + y * 389711);\r\n\r\n        super(x + random.nextInRange(0.1, 0.9), y + random.nextInRange(0.1, 0.9));\r\n\r\n        this.rotation = random.nextInRange(0, Math.PI * 2);\r\n        this.lengthScale = random.nextInRange(0.9, 1.35);\r\n        this.topSkew = random.nextInRange(0, 0.25);\r\n        this.bottomSkew = random.nextInRange(0, 0.25);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Hatching } from '../model/Hatching';\r\n\r\nexport async function fillBackdrop(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const wallTiles = dungeon.tiles.filter(t => t.isWall);\r\n\r\n    const backdropTiles = new Set<Tile>();\r\n    addAdjacentNonFloorTiles(wallTiles, backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n\r\n    dungeon.backdropPoints = [...backdropTiles]\r\n        .filter(tile => (tile.x + tile.y) % 2 !== 0)\r\n        .map(tile => new Hatching(tile.x, tile.y, seed));\r\n}\r\n\r\nfunction addAdjacentNonFloorTiles(wallTiles: Tile[], backdropTiles: Set<Tile>) {\r\n    for (const tile of wallTiles) {\r\n        for (const adjacent of tile.adjacentTiles) {\r\n            if (!adjacent.isFloor) {\r\n                backdropTiles.add(adjacent);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Region } from './Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\n\r\nexport class Tile extends Coord2D {\r\n    public region: Region | null = null;\r\n    public readonly adjacentTiles: Tile[] = [];\r\n\r\n    constructor(x: number, y: number, public isFloor: boolean = false, public isWall: boolean = false) {\r\n        super(x, y);\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { GenerationSteps } from './GenerationSteps';\r\nimport { SRandom } from '../lib/SRandom';\r\nimport { createRegions } from './generation/createRegions';\r\nimport { populateLinks } from './generation/populateLinks';\r\nimport { filterLinks } from './generation/filterLinks';\r\nimport { createRooms } from './generation/createRooms';\r\nimport { linkLinesToGrid } from './generation/linkLinesToGrid';\r\nimport { detectWalls } from './generation/detectWalls';\r\nimport { generateWallCurves } from './generation/generateWallCurves';\r\nimport { IGenerationSettings } from './IGenerationSettings';\r\nimport { associateTilesWithNodes } from './generation/associateTilesWithNodes';\r\nimport { fillBackdrop } from './generation/fillBackdrop';\r\nimport { createTiles } from './generation/createTiles';\r\n\r\nexport enum DelaySize {\r\n    None = 0,\r\n    Minimal = 10,\r\n    Tiny = 50,\r\n    Small = 100,\r\n    Medium = 500,\r\n    Large = 1500,\r\n}\r\n\r\ntype GenerationStep = (\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepReached?: (interval: DelaySize) => Promise<void>\r\n) => Promise<void>;\r\n\r\nexport async function generateDungeon(\r\n    settings: IGenerationSettings,\r\n) {\r\n    const dungeon = new Dungeon();\r\n    await regenerateDungeon(dungeon, settings);\r\n    return dungeon;\r\n}\r\n\r\nexport async function regenerateDungeon(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n) {\r\n    dungeon.width = settings.cellsWide;\r\n    dungeon.height = settings.cellsHigh;\r\n\r\n    const seedGenerator = new SRandom(settings.seed);\r\n    \r\n    const stepFunctions = new Map<GenerationSteps, GenerationStep>([\r\n        [GenerationSteps.CreateTiles, createTiles],\r\n        [GenerationSteps.CreateNodes, createRegions],\r\n        [GenerationSteps.AssociateTiles, associateTilesWithNodes],\r\n        [GenerationSteps.LinkNodes, populateLinks],\r\n        [GenerationSteps.FilterLinks, filterLinks],\r\n        [GenerationSteps.ExpandLines, linkLinesToGrid],\r\n        [GenerationSteps.CreateRooms, createRooms],\r\n        [GenerationSteps.DetectWalls, detectWalls],\r\n        [GenerationSteps.CurveWalls, generateWallCurves],\r\n        [GenerationSteps.FillBackdrop, fillBackdrop],    \r\n    ]);\r\n\r\n    for (const step of settings.steps) {\r\n        const operation = stepFunctions.get(step);\r\n        if (operation === undefined) {\r\n            continue;\r\n        }\r\n\r\n        const stepSeed = seedGenerator.next();\r\n\r\n        const subStepReached = settings.animateSteps.indexOf(step) !== -1\r\n            ? async (interval: DelaySize) => {\r\n                if (settings.animateSteps.indexOf(step) === -1) {\r\n                    return; // give up on animation\r\n                }\r\n\r\n                settings.redraw(dungeon, step, false);\r\n                await delay(interval);\r\n            }\r\n            : undefined;\r\n        \r\n        await operation(dungeon, settings, stepSeed, subStepReached);\r\n        \r\n        if (settings.animateSteps.indexOf(step) !== -1 && step !== GenerationSteps.CreateTiles) {\r\n            settings.redraw(dungeon, step, true);\r\n            await delay(DelaySize.Large);\r\n        }\r\n    }\r\n}\r\n\r\nfunction delay(milliseconds: number): Promise<void> {\r\n    return new Promise<void>(resolve => {\r\n        setTimeout(() => resolve(), milliseconds);\r\n    });\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function createTiles(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.tiles = [];\r\n    dungeon.tilesByCoordinates = [];\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        let col = new Array<Tile>(dungeon.height);\r\n        dungeon.tilesByCoordinates[x] = col;\r\n\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = new Tile(x, y);\r\n            col[y] = tile;\r\n            dungeon.tiles.push(tile);\r\n        }\r\n    }\r\n\r\n    const maxX = dungeon.width - 1;\r\n    const maxY = dungeon.height - 1;\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = dungeon.tilesByCoordinates[x][y];\r\n\r\n            if (x > 0) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y+1]);\r\n                }\r\n            }\r\n\r\n            if (y > 0) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y-1]);\r\n            }\r\n\r\n            if (y < maxY) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y+1]);\r\n            }\r\n            \r\n            if (x < maxX) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y+1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useState, useEffect } from 'react';\r\nimport { Menu } from './menu/Menu';\r\nimport { FixedCanvas } from './Canvas';\r\nimport { Dungeon } from '../dungeon/model/Dungeon';\r\nimport './App.css';\r\nimport { renderDungeon } from '../dungeon/renderDungeon';\r\nimport { generateDungeon, regenerateDungeon } from '../dungeon/generateDungeon';\r\nimport { GenerationSteps, allSteps } from '../dungeon/GenerationSteps';\r\nimport { determineRenderSettings, IRenderSettings } from '../dungeon/IRenderSettings';\r\nimport { IGenerationSettings } from '../dungeon/IGenerationSettings';\r\n\r\nexport const App: FunctionComponent = () => {\r\n    const canvas = React.useRef<FixedCanvas>(null);\r\n\r\n    const [dungeon, setDungeon] = useState<Dungeon>(new Dungeon());\r\n    const [generating, setGenerating] = useState(false);\r\n\r\n    const cellSize = 10;\r\n\r\n    const [renderSettings, setRenderSettings] = useState<IRenderSettings>(determineRenderSettings(GenerationSteps.Render, true, cellSize));\r\n    \r\n    const [generationSettings, setGenerationSettings] = useState<IGenerationSettings>({\r\n        seed: 0,\r\n        steps: allSteps,\r\n        animateSteps: [],\r\n        cellsWide: 100,\r\n        cellsHigh: 70,\r\n        nodeCount: 25,\r\n        connectivity: 50,\r\n        redraw: (dungeon: Dungeon, stage: GenerationSteps, stageComplete: boolean) => { \r\n            if (canvas.current !== null) {\r\n                renderDungeon(dungeon, canvas.current.ctx!, determineRenderSettings(stage, stageComplete, cellSize));\r\n            }\r\n        },\r\n    });\r\n\r\n    const generate = async () => {\r\n        const settings: IGenerationSettings = {\r\n            ...generationSettings,\r\n            seed: Math.random(),\r\n            steps: allSteps,\r\n            animateSteps: [],\r\n        };\r\n\r\n        setGenerationSettings(settings);\r\n        setGenerating(true);\r\n\r\n        const dungeon = await generateDungeon(settings);\r\n\r\n        setDungeon(dungeon);\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const regenerate = async (animate: boolean, steps: GenerationSteps[]) => {\r\n        setGenerating(true);\r\n\r\n        await regenerateDungeon(dungeon, {\r\n            ...generationSettings,\r\n            steps,\r\n            animateSteps: animate ? steps.slice() : [],\r\n        });\r\n\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const skip = () => generationSettings.animateSteps.splice(0, 1); // TODO: these weren't working\r\n    const finish = () => generationSettings.animateSteps = [];\r\n\r\n    useEffect(() => { generate(); }, []); // eslint-disable-line\r\n\r\n    const setRenderSettingsAndRender = (renderSettings: IRenderSettings) => {\r\n        setRenderSettings(renderSettings);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    return (    \r\n        <div className=\"App\">\r\n            <Menu\r\n                dungeon={dungeon}\r\n                canvas={canvas.current === null ? undefined : canvas.current.canvas}\r\n                cellSize={cellSize}\r\n                isGenerating={generating}\r\n                generationSettings={generationSettings}\r\n                setGenerationSettings={setGenerationSettings}\r\n                setRenderSettings={setRenderSettingsAndRender}\r\n                generate={generate}\r\n                regenerate={regenerate}\r\n                skip={skip}\r\n                finish={finish}\r\n            />\r\n            <FixedCanvas\r\n                className=\"dungeonDisplay\"\r\n                width={cellSize * generationSettings.cellsWide}\r\n                height={cellSize * generationSettings.cellsHigh}\r\n                ref={canvas}\r\n            />\r\n        </div>\r\n    );\r\n}","// tslint:disable:no-console\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the 'N+1' visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL!,\n      window.location.toString()\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker) {\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and\n                // the fresh content will have been added to the cache.\n                // It's the perfect time to display a 'New content is\n                // available; please refresh.' message in your web app.\n                console.log('New content is available; please refresh.');\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // 'Content is cached for offline use.' message.\n                console.log('Content is cached for offline use.');\n              }\n            }\n          };\n        }\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type')!.indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport { App } from './components/App';\r\nimport registerServiceWorker from './registerServiceWorker';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root') as HTMLElement\r\n);\r\nregisterServiceWorker();\r\n"],"sourceRoot":""}