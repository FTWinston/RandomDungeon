{"version":3,"sources":["dungeon/GenerationSteps.ts","dungeon/IRenderSettings.ts","components/menu/Generate.tsx","components/common/RangeInput.tsx","components/menu/MapSize.tsx","dungeon/model/Region.ts","lib/model/Coord.ts","components/menu/Regions.tsx","lib/randomColor.ts","components/menu/Connections.tsx","components/menu/Menu.tsx","components/Canvas.tsx","dungeon/model/Dungeon.ts","dungeon/renderDungeon.ts","lib/SRandom.ts","dungeon/generation/createRegions.ts","lib/model/Polygon.ts","lib/model/Triangle.ts","lib/graph/delauney.ts","lib/graph/gabriel.ts","lib/graph/getUniqueLines.ts","lib/graph/minimumSpanning.ts","lib/graph/relativeNeighbourhood.ts","dungeon/model/Pathway.ts","lib/model/Line.ts","dungeon/generation/populateLinks.ts","dungeon/generation/filterLinks.ts","dungeon/generation/populateCaveRegion.ts","dungeon/generation/populateRoomRegion.ts","dungeon/generation/createRooms.ts","dungeon/generation/linkLinesToGrid.ts","dungeon/generation/detectWalls.ts","lib/model/Curve.ts","dungeon/generation/generateWallCurves.ts","lib/graph/getClosest.ts","dungeon/generation/associateTilesWithNodes.ts","dungeon/model/Hatching.ts","dungeon/generation/fillBackdrop.ts","dungeon/model/Tile.ts","dungeon/generateDungeon.ts","dungeon/generation/createTiles.ts","components/App.tsx","registerServiceWorker.ts","index.tsx"],"names":["GenerationSteps","determineRenderSettings","generationStage","Render","stageComplete","cellSize","nodeAlpha","regionAlpha","graphAlpha","drawNodeLinks","drawGrid","drawWalls","highlightWallCurves","drawOutside","drawOutsidePoints","CreateTiles","CreateNodes","AssociateTiles","LinkNodes","FilterLinks","ExpandLines","CreateRooms","DetectWalls","CurveWalls","FillBackdrop","floorColor","floorGridColor","linkColor","linkWidth","backgroundColor","hatchingColor","wallColor","wallWidth","floorGridWidth","hatchingWidth","drawWallsAsFloor","minimumSpanningWidth","relativeNeighbourhoodWidth","gabrielWidth","delauneyWidth","Generate","props","generate","regenerate","generateNew","useMemo","animate","generateOrSkip","isGenerating","className","onClick","animateOrFinish","useEffect","setRenderSettings","showSize","showRegions","showConnections","showRenders","RangeInput","onChange","onChangeComplete","changeHandler","undefined","e","target","valueAsNumber","changeCompleteHandler","label","type","inputClassName","min","max","value","onMouseUp","onTouchEnd","disabled","RegionType","MapSize","goBack","generationSettings","cellsWide","val","scale","dungeon","nodes","x","setGenerationSettings","redraw","cellsHigh","y","Coord2D","this","magnitude","other","length","magnitudeSq","dx","dy","b","c","a","d","center","Math","sqrt","RegionMode","Region","parent","seed","regionType","color","regionInfluence","radius","links","colorChars","ConnectionMode","Regions","dungeonDisplay","text","useState","AddRemove","mode","setMode","leftClick","rightClick","cellX","offsetX","cellY","offsetY","random","floor","NUM_VALUES","push","r","g","randomColor","preventDefault","cell","getTileAt","region","node","filter","n","Resize","ChangeType","FIRST_VALUE","addEventListener","removeEventListener","MenuPage","Connections","Doors","Menu","Main","currentPage","setCurrentPage","switchToMain","switchToSize","Size","switchToRegions","switchToConnections","switchToRenders","Renders","canvas","skip","finish","FixedCanvas","ctx","root","state","width","height","ref","updateCtx","prevProps","prevState","getContext","React","Dungeon","lines","backdropPoints","delauneyLines","gabrielLines","relativeNeighbourhoodLines","minimumSpanningLines","tiles","tilesByCoordinates","walls","col","renderDungeon","settings","clearRect","lineWidth","drawTile","drawTileGrid","globalAlpha","strokeStyle","drawPath","drawGraph","fillStyle","save","clipOutside","fillRect","xScale","point","yScale","lengthScale","translate","rotate","rotation","beginPath","moveTo","topSkew","lineTo","bottomSkew","fill","stroke","restore","fillOutside","arc","PI","lineCap","drawCurve","i","drawNode","pathway","from","to","room","tile","isFloor","isWall","strokeRect","curve","draw","halfCellSize","keyPoints","points","renderPoints","cx","cy","rect","clip","SRandom","s0","s1","s2","mash","t","next","minInclusive","maxExclusive","nextInRange","nextIntInRange","data","toString","h","charCodeAt","createRegions","subStepComplete","makeNode","influence","nextColor","nodeCount","addSpacedNode","DelaySize","Small","totWidth","totHeight","getScaledDistSq","n1","n2","dxScaled","dyScaled","node1","node2","closestDist1","Number","MAX_VALUE","closestDist2","Triangle","vertices","circumCenter","circumRadiusSq","circumCircle","computeDelauneyTriangulation","superTriangle","triangulation","badTriangles","triangle","insideCircumcircle","polygon","edgeFrom","edgeTo","sharedWithOther","indexOf","splice","vertex","distanceSqTo","computeGabrielGraph","graph","graphLinks","link","anyBlocking","halfwayTo","radiusSq","getUniqueLines","polygons","createLine","allLines","v0","v1","some","l","computeMinimumSpanningTree","unvisitedNodes","slice","firstNode","pop","possibleLinks","map","lengthSq","sort","visitedNodes","testLink","alreadyHasFrom","alreadyHasTo","addingNode","j","computeRelativeNeighbourhoodGraph","Pathway","populateLinks","enclosingTriangle","Artificial","delauneyTriangles","Medium","filterLinks","connectivity","selectingFrom","selectFraction","numToSelect","round","selectedLink","populateCaveRegion","regionTiles","nonEdgeTiles","adjacentTiles","mutableTiles","runCellularAutomataStep","removeUnconnectedFloorTiles","cells","results","Map","wasAlive","numAdjacentLiving","shouldLive","set","result","rootTile","connectedTiles","Set","tilesToTest","has","add","populateRoomRegion","nodeX","nodeY","determineBounds","minX","minY","maxX","maxY","growUpLeft","growDownRight","canLeft","canUp","isRowInRegion","isColInRegion","canRight","canDown","y1","y2","x1","x2","createRooms","Natural","linkLinesToGrid","x0","y0","col0","cell0","col1","cell1","steep","abs","tmp","gradient","iY","closestSideStep","almostInteger","detectWalls","iCol","toTest","getAdjacent","test","Tiny","orthogonal","diagonal","Curve","curvature","isLoop","t1x","t2x","t1y","t2y","c1","c2","c3","c4","fraction","step","iPt","lastCellIndex","tension","pts","firstCell","lastCell","secondCell","unshift","stepsPerSegment","pow","generateWallCurves","generateWallCurve","updateRenderPoints","firstTile","isRootLevel","generateSingleWallCurve","mainCurve","newStartPoint","backtrackToNewStartPoint","checkForCurveLoops","branchIndex","newCurve","newBranch","oldBranch","concat","curveTile","pickBestAdjacentWallTile","firstPoint","lastPoint","splitPos","lastIndexOf","splitCurve","splitPoint","prevTile","actualFirstTile","find","pickBestAdjacentWallTileOrthogonalThenDiagonal","lastTile","Minimal","ortho","bestTile","bestNumAdjacentNonWallTiles","numAdjacentNonWallTiles","allAdjacent","getClosest","getDistance","bestDist","bestNode","dist","associateTilesWithNodes","distance","Hatching","fillBackdrop","wallTiles","backdropTiles","addAdjacentNonFloorTiles","adjacent","Tile","createTiles","Array","generateDungeon","regenerateDungeon","seedGenerator","steps","None","Large","operation","endDelay","stepSeed","generateFrom","generateTo","subStepReached","animateFrom","interval","delay","milliseconds","Promise","resolve","setTimeout","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","catch","error","ReactDOM","setDungeon","generating","setGenerating","renderSettings","FIRST_STEP","stage","current","regenerateFrom","document","getElementById","URL","process","origin","fetch","response","status","headers","get","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.d4e0313b.chunk.js","sourcesContent":["export enum GenerationSteps {\r\n    CreateTiles,\r\n    CreateNodes,\r\n    AssociateTiles,\r\n    LinkNodes,\r\n    FilterLinks,\r\n    ExpandLines,\r\n    CreateRooms,\r\n    DetectWalls,\r\n    CurveWalls,\r\n    FillBackdrop,\r\n    Render,\r\n\r\n\r\n    FIRST_STEP = CreateTiles,\r\n}\r\n","import { GenerationSteps } from './GenerationSteps';\r\n\r\nexport interface IRenderSettings {\r\n    nodeAlpha: number;\r\n    regionAlpha: number;\r\n    graphAlpha: number;\r\n    drawNodeLinks: boolean;\r\n    drawGrid: boolean;\r\n    drawWalls: boolean;\r\n    highlightWallCurves: boolean;\r\n    drawOutsidePoints: boolean;\r\n    drawOutside: boolean;\r\n    backgroundColor: string;\r\n    linkColor: string;\r\n    linkWidth: number;\r\n    floorColor: string;\r\n    floorGridColor: string;\r\n    floorGridWidth: number;\r\n    wallColor: string;\r\n    hatchingColor: string;\r\n    cellSize: number,\r\n    wallWidth: number,\r\n    hatchingWidth: number,\r\n    drawWallsAsFloor: boolean,\r\n    minimumSpanningWidth: number,\r\n    relativeNeighbourhoodWidth: number,\r\n    gabrielWidth: number,\r\n    delauneyWidth: number,\r\n}\r\n\r\nexport function determineRenderSettings(   \r\n    generationStage = GenerationSteps.Render,\r\n    stageComplete: boolean = true,\r\n    cellSize: number,\r\n): IRenderSettings {\r\n    let nodeAlpha = 0;\r\n    let regionAlpha = 0;\r\n    let graphAlpha = 0;\r\n    let drawNodeLinks = false;\r\n    let drawGrid = false;\r\n    let drawWalls = false;\r\n    let highlightWallCurves = false;\r\n    let drawOutside = false;\r\n    let drawOutsidePoints = false;\r\n    let drawWallsAsFloor = true;\r\n\r\n    switch (generationStage) {\r\n        case GenerationSteps.CreateTiles:\r\n            drawGrid = true;\r\n            break;\r\n            \r\n        case GenerationSteps.CreateNodes:\r\n            nodeAlpha = 1;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.AssociateTiles:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.66;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.LinkNodes:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.5;\r\n            graphAlpha = 0.25;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.FilterLinks:\r\n            nodeAlpha = 0.75;\r\n            regionAlpha = 0.55;\r\n            drawNodeLinks = true;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.ExpandLines:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CreateRooms:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.DetectWalls:\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CurveWalls:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n\r\n            highlightWallCurves = !stageComplete;\r\n            break;\r\n\r\n        case GenerationSteps.FillBackdrop:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutsidePoints = true;\r\n            break;\r\n\r\n        case GenerationSteps.Render:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutside = true;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        nodeAlpha,\r\n        regionAlpha,\r\n        graphAlpha,\r\n        drawNodeLinks,\r\n        drawGrid,\r\n        drawWalls,\r\n        highlightWallCurves,\r\n        drawOutsidePoints,\r\n        drawOutside,\r\n        floorColor: '#fff',\r\n        floorGridColor: 'rgba(192,192,192,0.5)',\r\n        linkColor: '#000',\r\n        linkWidth: 1,\r\n        backgroundColor: '#fff',\r\n        hatchingColor: '#000',\r\n        wallColor: '#000',\r\n        cellSize,\r\n        wallWidth: cellSize,\r\n        floorGridWidth: 1,\r\n        hatchingWidth: cellSize * 0.175,\r\n        drawWallsAsFloor,\r\n        minimumSpanningWidth: cellSize,\r\n        relativeNeighbourhoodWidth: cellSize * 0.5,\r\n        gabrielWidth: cellSize * 0.25,\r\n        delauneyWidth: 1,\r\n    };\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo, useEffect } from 'react';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\nexport interface Props {\r\n    isGenerating: boolean;\r\n    generate: (generateTo: GenerationSteps) => Promise<void>;\r\n    regenerate: (animate: boolean, generateFrom: GenerationSteps, generateTo: GenerationSteps) => Promise<void>;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    skip: () => void;\r\n    finish: () => void;\r\n\r\n    showSize: () => void;\r\n    showRegions: () => void;\r\n    showConnections: () => void;\r\n    showRenders: () => void;\r\n}\r\n\r\nexport const Generate: FunctionComponent<Props> = props => {\r\n    const { generate, regenerate } = props;\r\n\r\n    const generateNew = useMemo(() => (() => generate(GenerationSteps.Render)), [generate]);\r\n    const animate = useMemo(() => (() => regenerate(true, GenerationSteps.AssociateTiles, GenerationSteps.Render)), [regenerate]);\r\n\r\n    const generateOrSkip = props.isGenerating\r\n        ? <button className=\"menu__button\">Skip step</button>\r\n        : <button className=\"menu__button\" onClick={generateNew}>Generate new</button>\r\n\r\n    const animateOrFinish = props.isGenerating\r\n        ? <button className=\"menu__button\">Finish</button>\r\n        : <button className=\"menu__button\" onClick={animate}>Animate generation</button>\r\n\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.Render, true, props.cellSize),\r\n        });\r\n    }, []); // eslint-disable-line\r\n    \r\n    return <div className=\"menu menu--autoGenerate\">\r\n        <button className=\"menu__link\" onClick={props.showSize}>Map size</button>\r\n        <button className=\"menu__link\" onClick={props.showRegions}>Edit regions</button>\r\n        <button className=\"menu__link\" onClick={props.showConnections}>Edit paths</button>\r\n        <button className=\"menu__link\" onClick={props.showRenders}>Renders</button>\r\n\r\n        <div className=\"menu__spacer\" />\r\n\r\n        {generateOrSkip}\r\n        {animateOrFinish}\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo } from 'react';\r\n\r\ninterface Props {\r\n    className?: string;\r\n    inputClassName?: string;\r\n    label: string;\r\n    min: number;\r\n    max: number;\r\n    value: number;\r\n    onChange?: (val: number) => void;\r\n    onChangeComplete?: () => void;\r\n    disabled?: boolean;\r\n}\r\n\r\nexport const RangeInput: FunctionComponent<Props> = props => {\r\n    const {onChange, onChangeComplete} = props;\r\n\r\n    const changeHandler = useMemo(() => {\r\n        if (onChange === undefined) {\r\n            return undefined;\r\n        }\r\n        return (e: React.ChangeEvent<HTMLInputElement>) => onChange(e.target.valueAsNumber)\r\n    }, [onChange]);\r\n\r\n    const changeCompleteHandler = useMemo(() => {\r\n        if (onChangeComplete === undefined) {\r\n            return undefined;\r\n        }\r\n        return () => onChangeComplete();\r\n    }, [onChangeComplete]);\r\n\r\n    return (\r\n        <label className={props.className}>{props.label}\r\n            <input\r\n                type=\"range\"\r\n                className={props.inputClassName}\r\n                min={props.min}\r\n                max={props.max}\r\n                value={props.value}\r\n                onChange={changeHandler}\r\n                onMouseUp={changeCompleteHandler}\r\n                onTouchEnd={changeCompleteHandler}\r\n                disabled={props.disabled}\r\n            />\r\n        </label>\r\n    );\r\n}\r\n","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { RangeInput } from '../common/RangeInput';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    generationSettings: IGenerationSettings;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const MapSize: FunctionComponent<Props> = props => {\r\n    const setWidth = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsWide;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.x *= scale;\r\n        }\r\n\r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsWide: val,\r\n        });\r\n    }\r\n\r\n    const setHeight = (val: number) => {\r\n        const scale = val / props.generationSettings.cellsHigh;\r\n        for (const node of props.dungeon.nodes) {\r\n            node.y *= scale;\r\n        }\r\n        \r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsHigh: val,\r\n        });\r\n    }\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    return <div className=\"menu menu--mapSize\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n    \r\n        <div className=\"menu__group\">\r\n            <RangeInput\r\n                label=\"Width\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsWide}\r\n                onChange={setWidth}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n\r\n            <RangeInput\r\n                label=\"Height\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsHigh}\r\n                onChange={setHeight}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n        </div>\r\n    </div>\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { Dungeon } from './Dungeon';\r\nimport { Pathway } from './Pathway';\r\n\r\nexport enum RegionType {\r\n    Natural = 0,\r\n    Artificial = 1,\r\n\r\n    NUM_VALUES,\r\n    FIRST_VALUE = 0,\r\n}\r\n\r\nexport class Region extends Coord2D {\r\n    radius: number = 0.75;\r\n    links: Pathway[] = [];\r\n\r\n    constructor(\r\n        readonly parent: Dungeon,\r\n        x: number,\r\n        y: number,\r\n        public seed: number,\r\n        public regionType: RegionType,\r\n        public readonly color: string,\r\n        public regionInfluence = 1\r\n    ) {\r\n        super(x, y);\r\n    }\r\n}","export abstract class Coord<TCoord extends Coord<TCoord>> {\r\n    abstract length(): number;\r\n\r\n    abstract equals(other: Coord<TCoord>): boolean;\r\n    \r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract toUnitLength(): Coord<TCoord>;\r\n\r\n    abstract distanceTo(other: Coord<TCoord>): number;\r\n    \r\n    abstract distanceSqTo(other: Coord<TCoord>): number;\r\n\r\n    abstract directionTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract halfwayTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract scale(scale: number): Coord<TCoord>;\r\n    \r\n    abstract crossProduct(other: Coord<TCoord>): number;\r\n\r\n    abstract circumCircle(b: Coord<TCoord>, c: Coord<TCoord>): [Coord<TCoord>, number];\r\n}\r\n\r\nexport class Coord2D extends Coord<Coord2D> {\r\n    constructor(public x: number, public y: number) {\r\n        super();\r\n    }\r\n\r\n    length() {\r\n        return this.magnitude(this.x, this.y);\r\n    }\r\n\r\n    equals(other: Coord2D) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    add(other: Coord2D) {\r\n        return new Coord2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subtract(other: Coord2D) {\r\n        return new Coord2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    toUnitLength() {\r\n        let length = this.length();\r\n        return new Coord2D(this.x / length, this.y / length);\r\n    }\r\n    \r\n    distanceTo(other: Coord2D) {\r\n        return this.magnitude(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    distanceSqTo(other: Coord2D) {\r\n        return this.magnitudeSq(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    directionTo(other: Coord2D) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        \r\n        let length = this.magnitude(dx, dy);\r\n        return new Coord2D(dx / length, dy / length);\r\n    }\r\n\r\n    halfwayTo(other: Coord2D) {\r\n        return new Coord2D((this.x + other.x) / 2, (this.y + other.y) / 2);\r\n    }\r\n\r\n    scale(scale: number) {\r\n        return new Coord2D(this.x * scale, this.y * scale);\r\n    }\r\n\r\n    crossProduct(other: Coord2D) {\r\n        return this.x * other.y - this.y * other.x;\r\n    }\r\n\r\n    circumCircle(b: Coord2D, c: Coord2D) {\r\n        let a = this;\r\n        let d = (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n        \r\n        let x = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) \r\n             -  ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.y - c.y))\r\n        / d;\r\n\r\n        let y = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x)\r\n            -  ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x))\r\n        / d;\r\n\r\n        let center = new Coord2D(x, y);\r\n\r\n        let rSquared = (c.x - center.x) * (c.x - center.x) + (c.y - center.y) * (c.y - center.y);\r\n\r\n        let retVal: [Coord2D, number] = [\r\n            center,\r\n            rSquared\r\n        ];\r\n\r\n        return retVal;\r\n    }\r\n\r\n    private magnitude(dx: number, dy: number) {\r\n        return Math.sqrt(this.magnitudeSq(dx, dy));\r\n    }\r\n\r\n    private magnitudeSq(dx: number, dy: number) {\r\n        return dx * dx + dy * dy;\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect, useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { Region, RegionType } from '../../dungeon/model/Region';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { randomColor } from '../../lib/randomColor';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nenum RegionMode {\r\n    AddRemove,\r\n    Resize,\r\n    ChangeType,\r\n}\r\n\r\nexport const Regions: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const [mode, setMode] = useState(RegionMode.AddRemove);\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        let leftClick: (e: MouseEvent) => void;\r\n        let rightClick: (e: MouseEvent) => void;\r\n\r\n        switch (mode) {\r\n            case RegionMode.AddRemove:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    // add new node\r\n                    const seed = Math.random();\r\n                    const regionType = Math.floor(Math.random() * RegionType.NUM_VALUES);\r\n                    dungeon.nodes.push(new Region(dungeon, cellX, cellY, seed, regionType, randomColor()));\r\n                    redraw();\r\n                };\r\n\r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    // remove associated node\r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    const node = cell.region;\r\n                    dungeon.nodes = dungeon.nodes.filter(n => n !== node);\r\n        \r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.Resize:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence *= 1.2;\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence /= 1.2;\r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.ChangeType:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    if (++cell.region.regionType >= RegionType.NUM_VALUES) {\r\n                        cell.region.regionType = RegionType.FIRST_VALUE;\r\n                    }\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n\r\n                    cell.region.seed = Math.random();\r\n                    redraw();\r\n                };\r\n                break;\r\n            default:\r\n                return;       \r\n        }\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize, mode]);\r\n\r\n    let text: string | undefined;\r\n\r\n    switch (mode) {\r\n        case RegionMode.AddRemove:\r\n            text = \"Left click the map to place region nodes. Right click to remove a region.\";\r\n            break;\r\n        case RegionMode.Resize:\r\n            text = \"Left click the a region to grow it, right click a region to shrink it.\";\r\n            break;\r\n        case RegionMode.ChangeType:\r\n            text = \"Left click a region to change its type. Right click to regenerate it with the same type.\";\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === RegionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.AddRemove)}>Add/remove regions</li>\r\n            <li className={mode === RegionMode.Resize ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.Resize)}>Resize regions</li>\r\n            <li className={mode === RegionMode.ChangeType ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.ChangeType)}>Change region types</li>\r\n        </ul>\r\n\r\n        <div className=\"menu__section\">\r\n            {text}\r\n        </div>\r\n    </div>\r\n}","const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n\r\nexport function randomColor() {\r\n    const r = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const g = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const b = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    return `#${r}${g}${b}`;\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect, useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nenum ConnectionMode {\r\n    AddRemove,\r\n    Doors,\r\n}\r\n\r\nexport const Connections: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.FilterLinks, true, props.cellSize),\r\n            regionAlpha: 0.33,\r\n            drawWallsAsFloor: false,\r\n            linkWidth: cellSize * 0.5,\r\n            linkColor: '#0c0',\r\n            graphAlpha: 0.5,\r\n            minimumSpanningWidth: cellSize * 0.5,\r\n            relativeNeighbourhoodWidth: cellSize * 0.25,\r\n            gabrielWidth: cellSize * 0.125,\r\n            delauneyWidth: 1,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const [mode, setMode] = useState(ConnectionMode.AddRemove);\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n        let leftClick: (e: MouseEvent) => void;\r\n        let rightClick: (e: MouseEvent) => void;\r\n\r\n        switch (mode) {\r\n            case ConnectionMode.AddRemove:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    // add new node\r\n                    const seed = Math.random();\r\n                    const regionType = Math.floor(Math.random() * RegionType.NUM_VALUES);\r\n                    dungeon.nodes.push(new Region(dungeon, cellX, cellY, seed, regionType, randomColor()));\r\n                    redraw();\r\n                };\r\n\r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    // remove associated node\r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    const node = cell.region;\r\n                    dungeon.nodes = dungeon.nodes.filter(n => n !== node);\r\n        \r\n                    redraw();\r\n                };\r\n                break;\r\n            case ConnectionMode.Reshape:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence *= 1.2;\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence /= 1.2;\r\n                    redraw();\r\n                };\r\n                break;\r\n            case ConnectionMode.Doors:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    if (++cell.region.regionType >= RegionType.NUM_VALUES) {\r\n                        cell.region.regionType = RegionType.FIRST_VALUE;\r\n                    }\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n\r\n                    cell.region.seed = Math.random();\r\n                    redraw();\r\n                };\r\n                break;\r\n            default:\r\n                return;       \r\n        }\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n        */\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize, mode]);\r\n\r\n    let text: string | undefined;\r\n\r\n    switch (mode) {\r\n        case ConnectionMode.AddRemove:\r\n            text = \"Left click the map to toggle a pathway on / off. Right click to regenerate a pathway.\";\r\n            break;\r\n        case ConnectionMode.Doors:\r\n            text = \"Left click on a pathway to toggle a door. Right click to toggle a secret door.\";\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === ConnectionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(ConnectionMode.AddRemove)}>Add/remove paths</li>\r\n            <li className={mode === ConnectionMode.Doors ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(ConnectionMode.Doors)}>Add/remove doors</li>\r\n        </ul>\r\n\r\n        <div className=\"menu__section\">\r\n            {text}\r\n        </div>\r\n    </div>\r\n}","import * as React from 'react';\r\nimport './Menu.css';\r\nimport { FunctionComponent, useState, useMemo } from 'react';\r\nimport { Generate } from './Generate';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { MapSize } from './MapSize';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { Regions } from './Regions';\r\nimport { IRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { Connections } from './Connections';\r\n\r\ninterface Props {\r\n    isGenerating: boolean;\r\n    dungeon: Dungeon;\r\n    canvas?: HTMLCanvasElement;\r\n    cellSize: number;\r\n    generationSettings: Readonly<IGenerationSettings>;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    generate: (generateTo: GenerationSteps) => Promise<void>;\r\n    regenerate: (animate: boolean, generateFrom: GenerationSteps, generateTo: GenerationSteps) => Promise<void>;\r\n    skip: () => void;\r\n    finish: () => void;\r\n}\r\n\r\nenum MenuPage {\r\n    Main,\r\n    Size,\r\n    Regions,\r\n    Connections,\r\n    Renders,\r\n}\r\n\r\nexport const Menu: FunctionComponent<Props> = props => {\r\n    const [currentPage, setCurrentPage] = useState(MenuPage.Main);\r\n\r\n    const switchToMain = useMemo(() => () => setCurrentPage(MenuPage.Main), []);\r\n    const switchToSize = useMemo(() => () => setCurrentPage(MenuPage.Size), []);\r\n    const switchToRegions = useMemo(() => () => setCurrentPage(MenuPage.Regions), []);\r\n    const switchToConnections = useMemo(() => () => setCurrentPage(MenuPage.Connections), []);\r\n    const switchToRenders = useMemo(() => () => setCurrentPage(MenuPage.Renders), []);\r\n\r\n    switch (currentPage) {\r\n        case MenuPage.Size:\r\n            return (\r\n                <MapSize\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    generationSettings={props.generationSettings}\r\n                    setGenerationSettings={props.setGenerationSettings}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, GenerationSteps.AssociateTiles, GenerationSteps.Render)}\r\n                />\r\n            );\r\n        case MenuPage.Regions:\r\n            return (\r\n                <Regions\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, GenerationSteps.AssociateTiles, GenerationSteps.Render)}\r\n                />\r\n            );\r\n        case MenuPage.Connections:\r\n            return (\r\n                <Connections\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, GenerationSteps.ExpandLines, GenerationSteps.Render)}\r\n                />\r\n            );\r\n\r\n        // TODO: other pages\r\n\r\n        default:\r\n            return (\r\n                <Generate\r\n                    isGenerating={props.isGenerating}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    cellSize={props.cellSize}\r\n                    generate={props.generate}\r\n                    regenerate={props.regenerate}\r\n                    skip={props.skip}\r\n                    finish={props.finish}\r\n\r\n                    showSize={switchToSize}\r\n                    showRegions={switchToRegions}\r\n                    showConnections={switchToConnections}\r\n                    showRenders={switchToRenders}\r\n                />\r\n            );\r\n    }\r\n};","import * as React from 'react';\r\n\r\ninterface FixedProps {\r\n    width: number;\r\n    height: number;\r\n    className?: string;\r\n}\r\n\r\nexport class FixedCanvas extends React.Component<FixedProps, {}> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    public canvas?: HTMLCanvasElement;\r\n\r\n    constructor(props: FixedProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: props.width === undefined ? 0 : props.width,\r\n            height: props.height === undefined ? 0 : props.height,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.props.width}\r\n                    height={this.props.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    componentDidMount() {\r\n        this.updateCtx();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        const ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n}\r\n\r\ninterface ResponsiveProps {\r\n    className?: string;\r\n    sizeChanged?: (width: number, height: number) => void;\r\n}\r\n\r\ninterface ResponsiveState {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport class ResponsiveCanvas extends React.Component<ResponsiveProps, ResponsiveState> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    private canvas?: HTMLCanvasElement;\r\n    private resizeListener?: () => void;\r\n\r\n    constructor(props: ResponsiveProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.state.width}\r\n                    height={this.state.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateCtx();\r\n\r\n        this.resizeListener = () => this.updateSize();\r\n        window.addEventListener('resize', this.resizeListener);\r\n    \r\n        this.updateSize();\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        if (this.resizeListener !== undefined) {\r\n            window.removeEventListener('resize', this.resizeListener);\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    updateSize() {\r\n        if (this.root === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let scrollSize = this.getScrollbarSize();\r\n        let width = this.root.offsetWidth - scrollSize.width;\r\n        let height = this.root.offsetHeight - scrollSize.height;\r\n\r\n        this.setState({\r\n            width: width,\r\n            height: height,\r\n        });\r\n\r\n        if (this.props.sizeChanged !== undefined) {\r\n            this.props.sizeChanged(width, height);\r\n        }\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n\r\n    private getScrollbarSize() {\r\n        let outer = document.createElement('div');\r\n        outer.style.visibility = 'hidden';\r\n        outer.style.width = '100px';\r\n        outer.style.height = '100px';\r\n        outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\r\n\r\n        document.body.appendChild(outer);\r\n\r\n        let widthNoScroll = outer.offsetWidth;\r\n        let heightNoScroll = outer.offsetHeight;\r\n\r\n        // force scrollbars\r\n        outer.style.overflow = 'scroll';\r\n\r\n        // add innerdiv\r\n        let inner = document.createElement('div');\r\n        inner.style.width = '100%';\r\n        inner.style.height = '100%';\r\n        outer.appendChild(inner);\r\n\r\n        let widthWithScroll = inner.offsetWidth;\r\n        let heightWithScroll = inner.offsetHeight;\r\n\r\n        // remove divs\r\n        (outer.parentNode as HTMLElement).removeChild(outer);\r\n\r\n        return {\r\n            width: widthNoScroll - widthWithScroll,\r\n            height: heightNoScroll - heightWithScroll,\r\n        };\r\n    }\r\n}","import { Pathway } from './Pathway';\r\nimport { Region } from './Region';\r\nimport { Tile } from './Tile';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { Hatching } from './Hatching';\r\n\r\nexport class Dungeon implements IGraph<Region, Pathway> {\r\n    nodes: Region[] = [];\r\n    lines: Pathway[] = [];\r\n    backdropPoints: Hatching[] = [];\r\n    delauneyLines: Pathway[] = [];\r\n    gabrielLines: Pathway[] = [];\r\n    relativeNeighbourhoodLines: Pathway[] = [];\r\n    minimumSpanningLines: Pathway[] = [];\r\n\r\n    width: number = 0;\r\n    height: number = 0;\r\n\r\n    tiles: Tile[] = [];\r\n    tilesByCoordinates: Tile[][] = [];\r\n    walls: Curve[] = [];\r\n\r\n    public getTileAt(x: number, y: number) {\r\n        const col = this.tilesByCoordinates[Math.floor(x)];\r\n\r\n        if (col === undefined) {\r\n            return;\r\n        }\r\n\r\n        return col[Math.floor(y)];\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { Pathway } from './model/Pathway';\r\nimport { Region } from './model/Region';\r\nimport { Tile } from './model/Tile';\r\nimport { Curve } from '../lib/model/Curve';\r\nimport { IRenderSettings } from './IRenderSettings';\r\n\r\nexport function renderDungeon(   \r\n    dungeon: Dungeon,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n) {\r\n    ctx.clearRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n\r\n    if (settings.drawGrid) {\r\n        drawTileGrid(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.graphAlpha > 0) {\r\n        drawGraph(ctx, dungeon, settings);\r\n    }\r\n    \r\n    if (settings.drawOutside) {\r\n        fillOutside(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawOutsidePoints) {\r\n        drawOutsidePoints(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawWalls) {\r\n        ctx.strokeStyle = ctx.fillStyle = settings.highlightWallCurves ? '#f00' : '#000';\r\n        ctx.lineCap = 'round';\r\n        for (const curve of dungeon.walls) {\r\n            drawCurve(curve, ctx, settings);\r\n        }\r\n        ctx.lineCap = 'butt';\r\n    }\r\n    \r\n    if (settings.drawNodeLinks) {\r\n        ctx.lineWidth = settings.linkWidth;\r\n        ctx.strokeStyle = settings.linkColor;\r\n        for (let line of dungeon.lines) {\r\n            drawPath(line, ctx, settings);\r\n        }\r\n    }\r\n\r\n    if (settings.nodeAlpha > 0) {\r\n        ctx.globalAlpha = settings.nodeAlpha;\r\n        for (let i = 0; i < dungeon.nodes.length; i++) {\r\n            drawNode(dungeon.nodes[i], ctx, settings);\r\n        }\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawTileGrid(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.lineWidth = settings.floorGridWidth;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        drawTile(tile, ctx, settings);\r\n    }\r\n}\r\n\r\nfunction drawPath(pathway: Pathway, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(pathway.from.x * settings.cellSize, pathway.from.y * settings.cellSize);\r\n    ctx.lineTo(pathway.to.x * settings.cellSize, pathway.to.y * settings.cellSize);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction drawNode(room: Region, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.fillStyle = '#c00';\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(room.x * settings.cellSize, room.y * settings.cellSize, settings.cellSize * room.radius, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n}\r\n\r\nfunction drawTile(tile: Tile, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    if (tile.isFloor && (!tile.isWall || settings.drawWallsAsFloor)) {\r\n        ctx.fillStyle = settings.floorColor;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.strokeStyle = settings.floorGridColor;\r\n        ctx.strokeRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n    else if (tile.isWall) {\r\n        ctx.fillStyle = '#333';\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n\r\n    if (settings.regionAlpha > 0 && tile.region !== null) {\r\n        ctx.globalAlpha = settings.regionAlpha;\r\n        ctx.fillStyle = tile.region.color;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.globalAlpha = settings.graphAlpha;\r\n    ctx.strokeStyle = '#000';\r\n\r\n    ctx.lineWidth = settings.minimumSpanningWidth;\r\n    for (let line of dungeon.minimumSpanningLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.relativeNeighbourhoodWidth;\r\n    for (let line of dungeon.relativeNeighbourhoodLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.gabrielWidth;\r\n    for (let line of dungeon.gabrielLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.delauneyWidth;\r\n    for (let line of dungeon.delauneyLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.globalAlpha = 1;\r\n}\r\n\r\nfunction drawCurve(\r\n    curve: Curve,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n    draw: boolean = true\r\n) {\r\n    let halfCellSize = settings.cellSize / 2;\r\n\r\n    if (curve.keyPoints.length === 1) {\r\n        if (draw) {\r\n            let cell = curve.keyPoints[0];\r\n            let cx = cell.x * settings.cellSize + halfCellSize;\r\n            let cy = cell.y * settings.cellSize + halfCellSize;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy, settings.wallWidth / 2, 0, Math.PI * 2);\r\n        \r\n            ctx.fill();\r\n        }\r\n        return;\r\n    }\r\n    \r\n    let points = curve.renderPoints;\r\n    let x = points[0] * settings.cellSize + halfCellSize;\r\n    let y = points[1] * settings.cellSize + halfCellSize;\r\n    \r\n    if (draw) {\r\n        ctx.beginPath();\r\n    }\r\n    ctx.moveTo(x, y);\r\n    \r\n    ctx.lineWidth = settings.wallWidth;\r\n    for (let i = 0; i < points.length; i += 2) {\r\n        x = points[i] * settings.cellSize + halfCellSize;\r\n        y = points[i + 1] * settings.cellSize + halfCellSize;\r\n        ctx.lineTo(x, y);\r\n    }\r\n\r\n    if (draw) {\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nfunction clipOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    for (let curve of dungeon.walls) {\r\n        drawCurve(curve, ctx, settings, false);\r\n    }\r\n    ctx.clip('evenodd');\r\n}\r\n\r\nfunction fillOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.fillStyle = settings.backgroundColor;\r\n\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.fillRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    \r\n    ctx.strokeStyle = settings.hatchingColor;\r\n    ctx.lineWidth = settings.hatchingWidth;\r\n\r\n    const xScale = settings.cellSize * 0.6;\r\n    for (const point of dungeon.backdropPoints) {\r\n        const yScale = settings.cellSize * point.lengthScale;\r\n        \r\n        ctx.save();\r\n\r\n        ctx.translate(point.x * settings.cellSize, point.y * settings.cellSize);\r\n        ctx.rotate(point.rotation);\r\n\r\n        // first clear the background of this segment\r\n        ctx.beginPath();\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n        ctx.fill();\r\n\r\n        // then draw the lines\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.moveTo(0, -yScale);\r\n        ctx.lineTo(0, yScale);\r\n\r\n        ctx.moveTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction drawOutsidePoints(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.globalAlpha = 0.75;\r\n    ctx.fillStyle = '#009';\r\n\r\n    for (const point of dungeon.backdropPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(point.x * settings.cellSize, point.y * settings.cellSize, settings.cellSize * 0.25, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n}","// based on http://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/lib/alea.js\r\n\r\nexport class SRandom {\r\n    private c: number;\r\n    private s0: number;\r\n    private s1: number;\r\n    private s2: number;\r\n\r\n    constructor(public readonly seed: number | string) {\r\n        var mash = this.mash();\r\n\r\n        this.c = 1;\r\n        this.s0 = mash(' ');\r\n        this.s1 = mash(' ');\r\n        this.s2 = mash(' ');\r\n\r\n        this.s0 -= mash(seed);\r\n        if (this.s0 < 0) {\r\n            this.s0 += 1;\r\n        }\r\n\r\n        this.s1 -= mash(seed);\r\n        if (this.s1 < 0) {\r\n            this.s1 += 1;\r\n        }\r\n\r\n        this.s2 -= mash(seed);\r\n        if (this.s2 < 0) {\r\n            this.s2 += 1;\r\n        }\r\n    }\r\n\r\n    next() {\r\n        let t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        return this.s2 = t - (this.c = t | 0);\r\n    }\r\n    \r\n    nextInt32() {\r\n        return (this.next() * 0x100000000) | 0;\r\n    }\r\n\r\n    nextInRange(min: number, max: number) {\r\n        return min + this.next() * (max - min);\r\n    }\r\n\r\n    nextIntInRange(minInclusive: number, maxExclusive: number) {\r\n        return Math.floor(this.nextInRange(minInclusive, maxExclusive));\r\n    }\r\n\r\n    nextColor() {\r\n        const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n        const r = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const g = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const b = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        return `#${r}${g}${b}`;\r\n    }\r\n\r\n    private mash() {\r\n        let n = 0xefc8249d;\r\n\r\n        let mash = function(data: number | string) {\r\n            data = data.toString();\r\n            for (var i = 0; i < data.length; i++) {\r\n                n += data.charCodeAt(i);\r\n                var h = 0.02519603282416938 * n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                h *= n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                n += h * 0x100000000; // 2^32\r\n            }\r\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\r\n        };\r\n\r\n        return mash;\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\nimport { Line } from '../../lib/model/Line';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function createRegions(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // Remove all nodes, then create nodeCount nodes. Using same seed ensures same ones are recreated.\r\n    const random = new SRandom(seed);\r\n\r\n    let makeNode = () => {\r\n        const x = random.nextInRange(3, dungeon.width - 4);\r\n        const y = random.nextInRange(3, dungeon.height - 4);\r\n        const influence = random.nextInRange(0.6, 1.8);\r\n        const regionType = random.nextIntInRange(0, RegionType.NUM_VALUES);\r\n        const seed = random.next();\r\n        const color = random.nextColor();\r\n        return new Region(dungeon, x, y, seed, regionType, color, influence);\r\n    };\r\n\r\n    dungeon.nodes = [];\r\n    for (let i = 0; i < settings.nodeCount; i++) {\r\n        addSpacedNode(dungeon, makeNode, dungeon.width, dungeon.height);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n}\r\n\r\nfunction addSpacedNode<TNode extends Coord2D, TLine extends Line<TNode>>(\r\n    dungeon: IGraph<TNode, TLine>,\r\n    makeNode: () => TNode,\r\n    totWidth: number,\r\n    totHeight: number\r\n) {\r\n    const getScaledDistSq = (n1: TNode, n2: TNode, width: number, height: number) => {\r\n        let dxScaled = (n1.x - n2.x) / width;\r\n        let dyScaled = (n1.y - n2.y) / height;\r\n        return dxScaled * dxScaled + dyScaled * dyScaled;\r\n    };\r\n\r\n    // create two nodes, and go with the one that's furthest away from the nearest node\r\n    let node1 = makeNode(), node2 = makeNode();\r\n    let closestDist1 = Number.MAX_VALUE, closestDist2 = Number.MAX_VALUE;\r\n    for (let node of dungeon.nodes) {\r\n        // scale x/y distances, so width/height changes don't change which node is chosen during regeneration\r\n        closestDist1 = Math.min(closestDist1, getScaledDistSq(node1, node, totWidth, totHeight));\r\n        closestDist2 = Math.min(closestDist2, getScaledDistSq(node2, node, totWidth, totHeight));\r\n    }\r\n\r\n    dungeon.nodes.push(closestDist1 < closestDist2 ? node2 : node1);\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Polygon<TNode extends Coord<TNode>> {\r\n    constructor(readonly vertices: TNode[]) {\r\n        \r\n    }\r\n}","import { Coord } from './Coord';\r\nimport { Polygon } from './Polygon';\r\n\r\nexport class Triangle<TNode extends Coord<TNode>> extends Polygon<TNode> {\r\n    circumCenter: Coord<TNode>;\r\n    circumRadiusSq: number;\r\n\r\n    constructor(vertices: [TNode, TNode, TNode]) {\r\n        super(vertices);\r\n\r\n        let circumCircle = vertices[0].circumCircle(vertices[1], vertices[2]);\r\n\r\n        this.circumCenter = circumCircle[0];\r\n        this.circumRadiusSq = circumCircle[1];\r\n    }\r\n}","import { Coord } from '../model/Coord';\r\nimport { Triangle } from '../model/Triangle';\r\n\r\nexport function computeDelauneyTriangulation<TNode extends Coord<TNode>>(\r\n    nodes: TNode[],\r\n    superTriangle: [TNode, TNode, TNode]\r\n) {\r\n    if (nodes.length < 3) {\r\n        return [];\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm\r\n    let triangulation: Triangle<TNode>[] = [];\r\n    triangulation.push(new Triangle(superTriangle));\r\n\r\n    for (let node of nodes) {\r\n        // find all triangles that are no longer valid due to this node's insertion\r\n        let badTriangles: Triangle<TNode>[] = [];\r\n        for (let triangle of triangulation) {\r\n            if (insideCircumcircle(node, triangle)) {\r\n                badTriangles.push(triangle);\r\n            }\r\n        }\r\n\r\n        // Find the boundary of polygonal hole formed by these \"bad\" triangles...\r\n        // Get the edges of the \"bad\" triangles which don't touch other bad triangles...\r\n        // Each pair of nodes here represents a line.\r\n        let polygon: TNode[] = [];\r\n        for (let triangle of badTriangles) {\r\n            for (let i = 0; i < 3; i++) {\r\n                let edgeFrom = triangle.vertices[i];\r\n                let edgeTo = triangle.vertices[i === 2 ? 0 : i + 1];\r\n\r\n                let sharedWithOther = false;\r\n                for (let other of badTriangles) {\r\n                    if (other === triangle) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeFrom) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeTo) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    sharedWithOther = true;\r\n                    break;\r\n                }\r\n\r\n                if (!sharedWithOther) {\r\n                    polygon.push(edgeFrom, edgeTo);\r\n                }\r\n            }\r\n        }\r\n\r\n        // discard all bad triangles\r\n        for (let triangle of badTriangles) {\r\n            triangulation.splice(triangulation.indexOf(triangle), 1);\r\n        }\r\n\r\n        // re-triangulate the polygonal hole ... create a new triangle for each edge\r\n        for (let i = 0; i < polygon.length - 1; i += 2) {\r\n            let triangle = new Triangle<TNode>([polygon[i], polygon[i + 1], node]);\r\n            triangulation.push(triangle);\r\n        }\r\n    }\r\n\r\n    // remove all triangles that contain a vertex from the original super-triangle\r\n    for (let i = 0; i < triangulation.length; i++) {\r\n        let triangle = triangulation[i];\r\n        for (let vertex of triangle.vertices) {\r\n            if (superTriangle.indexOf(vertex) !== -1) {\r\n                triangulation.splice(i, 1);\r\n                i--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return triangulation;\r\n}\r\n\r\nfunction insideCircumcircle<TNode extends Coord<TNode>>(\r\n    point: TNode,\r\n    triangle: Triangle<TNode>\r\n) {\r\n    let distSq = point.distanceSqTo(triangle.circumCenter);\r\n    return distSq <= triangle.circumRadiusSq;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeGabrielGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n\r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let center = link.from.halfwayTo(link.to);\r\n        let radiusSq = link.from.distanceSqTo(center);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(center) < radiusSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}","import { Coord } from '../model/Coord';\r\nimport { Line } from '../model/Line';\r\nimport { Polygon } from '../model/Polygon';\r\n\r\nexport function getUniqueLines<TNode extends Coord<TNode>, TLine extends Line<TNode>>\r\n(\r\n    polygons: Polygon<TNode>[], \r\n    createLine: (from: TNode, to: TNode) => TLine\r\n) {\r\n    const allLines: TLine[] = [];\r\n\r\n    // Convert polygons to UNIQUE lines, ignoring their direction.\r\n    for (const polygon of polygons) {\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            const v0 = polygon.vertices[i === 0 ? polygon.vertices.length - 1 : i - 1];\r\n            const v1 = polygon.vertices[i];\r\n\r\n            const isDuplicate = allLines.some(l => (l.from === v0 && l.to === v1) || (l.from === v1 && l.to === v0));\r\n            if (!isDuplicate) {\r\n                allLines.push(createLine(v0, v1));\r\n            }\r\n        }\r\n    }\r\n\r\n    return allLines;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeMinimumSpanningTree<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let unvisitedNodes = graph.nodes.slice();\r\n    let firstNode = unvisitedNodes.pop();\r\n    if (firstNode === undefined) {\r\n        return [];\r\n    }\r\n    \r\n    let possibleLinks = links.map(l => ({ link: l, lengthSq: l.from.distanceSqTo(l.to) }));\r\n    possibleLinks.sort((a, b) => a.lengthSq - b.lengthSq);\r\n\r\n    let visitedNodes: TNode[] = [firstNode];\r\n    let graphLinks: TLine[] = [];\r\n\r\n    while (unvisitedNodes.length > 0 && possibleLinks.length > 0) {\r\n        // Find the first link that connects to a node in visitedNodes...\r\n        // The links are sorted by length, so the first one will be the shortest one.\r\n        for (let i = 0; i < possibleLinks.length; i++) {\r\n            let testLink = possibleLinks[i].link;\r\n            \r\n            let alreadyHasFrom = visitedNodes.indexOf(testLink.from) !== -1;\r\n            let alreadyHasTo = visitedNodes.indexOf(testLink.to) !== -1;\r\n\r\n            // if it doesn't connect to the graph at all, discard it\r\n            if (!alreadyHasFrom && !alreadyHasTo) {\r\n                continue;\r\n            }\r\n\r\n            possibleLinks.splice(i, 1);\r\n            graphLinks.push(testLink);\r\n\r\n            let addingNode = alreadyHasFrom ? testLink.to : testLink.from;\r\n            \r\n            // remove all other links from possibleLinks that connect addingNode to visitedNodes\r\n            for (let j = i; j < possibleLinks.length; j++) {\r\n                testLink = possibleLinks[j].link;\r\n                if ((testLink.from === addingNode && visitedNodes.indexOf(testLink.to) !== -1)\r\n                || (testLink.to === addingNode && visitedNodes.indexOf(testLink.from) !== -1)) {\r\n                    possibleLinks.splice(j, 1);\r\n                    j--;\r\n                }\r\n            }\r\n\r\n            visitedNodes.push(addingNode);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeRelativeNeighbourhoodGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>, \r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n    \r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let lengthSq = link.from.distanceSqTo(link.to);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(link.from) < lengthSq && node.distanceSqTo(link.to) < lengthSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Line } from '../../lib/model/Line';\r\nimport { Region } from './Region';\r\n\r\nexport class Pathway extends Line<Region> {\r\n    constructor(from: Region, to: Region) {\r\n        super(from, to);\r\n\r\n        from.links.push(this);\r\n        to.links.push(this);\r\n    }\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Line<TCoord extends Coord<TCoord>> {\r\n    constructor(public from: TCoord, public to: TCoord) {\r\n\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport {\r\n    computeDelauneyTriangulation,\r\n    getUniqueLines,\r\n    computeGabrielGraph,\r\n    computeRelativeNeighbourhoodGraph,\r\n    computeMinimumSpanningTree\r\n} from '../../lib/graph';\r\nimport { Pathway } from '../model/Pathway';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function populateLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.lines = [];\r\n    dungeon.delauneyLines = [];\r\n    dungeon.gabrielLines = [];\r\n    dungeon.relativeNeighbourhoodLines = [];\r\n    dungeon.minimumSpanningLines = [];\r\n\r\n    const enclosingTriangle: [Region, Region, Region] = [\r\n        new Region(dungeon, 0, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 999999, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 0, 999999, 0, RegionType.Artificial, ''),\r\n    ];\r\n\r\n    const delauneyTriangles = computeDelauneyTriangulation(dungeon.nodes, enclosingTriangle);\r\n    \r\n    dungeon.delauneyLines = getUniqueLines(delauneyTriangles, (from, to) => new Pathway(from, to));\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.gabrielLines = computeGabrielGraph(dungeon, dungeon.delauneyLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.relativeNeighbourhoodLines = computeRelativeNeighbourhoodGraph(dungeon, dungeon.gabrielLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.minimumSpanningLines = computeMinimumSpanningTree(dungeon, dungeon.relativeNeighbourhoodLines);\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function filterLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let selectingFrom: Pathway[];\r\n    let selectFraction: number;\r\n        \r\n    if (settings.connectivity < 50) {\r\n        dungeon.lines = dungeon.minimumSpanningLines.slice();\r\n\r\n        selectingFrom = dungeon.relativeNeighbourhoodLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = settings.connectivity / 50;\r\n    } else {\r\n        dungeon.lines = dungeon.relativeNeighbourhoodLines.slice();\r\n\r\n        selectingFrom = dungeon.gabrielLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = (settings.connectivity - 50) / 50;\r\n    }\r\n    \r\n    let random = new SRandom(seed);\r\n    let numToSelect = Math.round(selectingFrom.length * selectFraction);\r\n\r\n    for (let i = numToSelect; i > 0; i--) {\r\n        let selectedLink = selectingFrom.splice(random.nextIntInRange(0, selectingFrom.length), 1)[0];\r\n        dungeon.lines.push(selectedLink);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function populateCaveRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    \r\n    const regionTiles = dungeon.tiles.filter(t => t.region === region);\r\n    const nonEdgeTiles = regionTiles.filter(t => t.adjacentTiles.length === 8 && !t.adjacentTiles.some(a => a.region !== region));\r\n    \r\n    const mutableTiles = nonEdgeTiles.filter(t => !t.isFloor);\r\n\r\n    // make half the non-edge cells \"alive\"\r\n    for (const tile of nonEdgeTiles) {\r\n        if (random.next() < 0.5) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < 8; i++) {\r\n        runCellularAutomataStep(mutableTiles);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n\r\n    removeUnconnectedFloorTiles(dungeon, region, nonEdgeTiles);\r\n}\r\n\r\nfunction runCellularAutomataStep(cells: Tile[]) {\r\n    const results = new Map<Tile, boolean>();\r\n\r\n    for (const cell of cells) {\r\n        // alive becomes dead if < 4 alive around it\r\n        // dead becomes alive if > 4 alive around it\r\n\r\n        const wasAlive = cell.isFloor;\r\n        const numAdjacentLiving = cell.adjacentTiles.filter(t => t.isFloor).length;\r\n\r\n        const shouldLive = wasAlive\r\n            ? numAdjacentLiving >= 4\r\n            : numAdjacentLiving > 4\r\n\r\n        results.set(cell, shouldLive);\r\n    }\r\n\r\n    for (const [cell, result] of results) {\r\n        cell.isFloor = result;\r\n    }\r\n}\r\n\r\nfunction removeUnconnectedFloorTiles(dungeon: Dungeon, region: Region, regionTiles: Tile[]) {    \r\n    const rootTile = dungeon.tilesByCoordinates[Math.floor(region.x)][Math.floor(region.y)];\r\n    \r\n    const connectedTiles = new Set([rootTile]);\r\n    let tilesToTest = [...rootTile.adjacentTiles];\r\n\r\n    while (true) {\r\n        const tile = tilesToTest.pop();\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        if (!tile.isFloor || tile.region !== region || connectedTiles.has(tile)) {\r\n            continue;\r\n        }\r\n\r\n        connectedTiles.add(tile);\r\n\r\n        tilesToTest = [\r\n            ...tilesToTest,\r\n            ...tile.adjacentTiles,\r\n        ];\r\n    }\r\n\r\n    for (const tile of regionTiles) {\r\n        if (tile.isFloor && !connectedTiles.has(tile)) {\r\n            tile.isFloor = false;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\n\r\nexport async function populateRoomRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    const nodeX = Math.floor(region.x);\r\n    const nodeY = Math.floor(region.y);\r\n\r\n    const { minX, minY, maxX, maxY } = determineBounds(dungeon, region, nodeX, nodeY, random);\r\n\r\n    for (let x = minX; x <= maxX; x++) {\r\n        for (let y = minY; y <= maxY; y++) {\r\n            let tile = dungeon.tilesByCoordinates[x][y];\r\n            if (tile.region !== region) {\r\n                continue;\r\n            }\r\n\r\n            tile.isFloor = true;\r\n            tile.region = region;\r\n        }\r\n    }\r\n}\r\n\r\nfunction determineBounds(dungeon: Dungeon, region: Region, nodeX: number, nodeY: number, random: SRandom) {\r\n    // determine the biggest possible size this room could be\r\n    let minX = nodeX, maxX = nodeX, minY = nodeY, maxY = nodeY;\r\n\r\n    if (random.next() < 0.5) {\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n    else {\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    // now possibly shrink from the maximum possible size\r\n    if (random.next() < 0.75) {\r\n        minX = random.nextIntInRange(minX, nodeX);\r\n        maxX = random.nextIntInRange(nodeX + 1, maxX + 1);\r\n        minY = random.nextIntInRange(minY, nodeY);\r\n        maxY = random.nextIntInRange(nodeY + 1, maxY + 1);    \r\n    }\r\n\r\n    return {\r\n        minX,\r\n        minY,\r\n        maxX,\r\n        maxY,\r\n    };\r\n}\r\n\r\nfunction growUpLeft(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canLeft = true, canUp = true;\r\n\r\n    while (canLeft || canUp) {\r\n        if (canUp && random.next() < 0.5) {\r\n            canUp = isRowInRegion(dungeon, region, minY - 1, minX, maxX)\r\n                && --minY > 2;\r\n        }\r\n        else if (canLeft) {\r\n            canLeft = isColInRegion(dungeon, region, minX - 1, minY, maxY)\r\n                && --minX > 2;\r\n        }\r\n    }\r\n\r\n    return [minX, minY];\r\n}\r\n\r\n\r\nfunction growDownRight(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canRight = true, canDown = true;\r\n\r\n    while (canRight || canDown) {\r\n        if (canDown && random.next() < 0.5) {\r\n            canDown = isRowInRegion(dungeon, region, maxY + 1, minX, maxX)\r\n                && ++maxY < dungeon.height - 3;\r\n        }\r\n        else if (canRight) {\r\n            canRight = isColInRegion(dungeon, region, maxX + 1, minY, maxY)\r\n                && ++maxX < dungeon.width - 3;\r\n        }\r\n    }\r\n\r\n    return [maxX, maxY];\r\n}\r\n\r\nfunction isColInRegion(dungeon: Dungeon, region: Region, x: number, y1: number, y2: number) {\r\n    const col = dungeon.tilesByCoordinates[x];\r\n\r\n    for (let y = y1; y <= y2; y++) {\r\n        if (col[y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isRowInRegion(dungeon: Dungeon, region: Region, y: number, x1: number, x2: number) {\r\n    for (let x = x1; x <= x2; x++) {\r\n        if (dungeon.tilesByCoordinates[x][y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { RegionType } from '../model/Region';\r\nimport { populateCaveRegion } from './populateCaveRegion';\r\nimport { populateRoomRegion } from './populateRoomRegion';\r\n\r\nexport async function createRooms(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const region of dungeon.nodes) {\r\n        switch (region.regionType) {\r\n            case RegionType.Natural:\r\n                await populateCaveRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            case RegionType.Artificial:\r\n                await populateRoomRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function linkLinesToGrid(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // associate each tile of the grid with all of the links that overlap or touch it\r\n    // this is Xiaolin Wi's algorithm, without the antialiasing.\r\n    for (let link of dungeon.lines) {\r\n        let x0 = Math.floor(link.from.x);\r\n        let x1 = Math.floor(link.to.x);\r\n        let y0 = Math.floor(link.from.y);\r\n        let y1 = Math.floor(link.to.y);\r\n\r\n        const col0 = dungeon.tilesByCoordinates[x0];\r\n        if (col0 !== undefined) {\r\n            const cell0 = col0[y0];\r\n            if (cell0 !== undefined) {\r\n                cell0.isFloor = true;\r\n            }\r\n        }\r\n        \r\n        const col1 = dungeon.tilesByCoordinates[x1];\r\n        if (col1 !== undefined) {\r\n            const cell1 = col1[y1];\r\n            if (cell1 !== undefined) {\r\n                cell1.isFloor = true;\r\n            }\r\n        }\r\n\r\n        let steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n        if (steep) { // swap x & y, ensure not steep\r\n            let tmp = y0;\r\n            y0 = x0;\r\n            x0 = tmp;\r\n            \r\n            tmp = y1;\r\n            y1 = x1;\r\n            x1 = tmp;\r\n        }\r\n        if (x0 > x1) { // swap 0 & 1, ensure moving rightwards\r\n            let tmp = x1;\r\n            x1 = x0;\r\n            x0 = tmp;\r\n            \r\n            tmp = y1;\r\n            y1 = y0;\r\n            y0 = tmp;\r\n        }\r\n        \r\n        let gradient = (y1 - y0) / (x1 - x0);\r\n        let y = y0 + gradient * 0.5; // move to the \"middle\" of the cell\r\n        \r\n        for (let x = x0; x < x1; x++) {\r\n            let iY = Math.round(y - 0.5); // round to the nearest i+0.5, then truncate to int\r\n            let closestSideStep = iY + 0.5 > y ? -1 : 1;\r\n            let almostInteger = Math.abs(y - iY) < 0.10;\r\n            \r\n            if (steep) {\r\n                dungeon.tilesByCoordinates[iY + closestSideStep][x].isFloor = true;\r\n                dungeon.tilesByCoordinates[iY][x].isFloor = true;\r\n                if (!almostInteger) {\r\n                    dungeon.tilesByCoordinates[iY - closestSideStep][x].isFloor = true;\r\n                }\r\n            } else {\r\n                dungeon.tilesByCoordinates[x][iY + closestSideStep].isFloor = true;\r\n                dungeon.tilesByCoordinates[x][iY].isFloor = true;\r\n                if (!almostInteger) {\r\n                    dungeon.tilesByCoordinates[x][iY - closestSideStep].isFloor = true;\r\n                }\r\n            }\r\n            \r\n            y += gradient;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { RegionType } from '../model/Region';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function detectWalls(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isFloor) {\r\n            continue;\r\n        }\r\n\r\n        let toTest = getAdjacent(dungeon, tile, true, false);\r\n        for (let test of toTest) {\r\n            if (test.isFloor) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // artificial rooms should have \"corner\" wall nodes filled in\r\n        for (let test of tile.adjacentTiles) {\r\n            if (test.isFloor && test.region !== null && test.region.regionType === RegionType.Artificial) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Tiny);\r\n        }\r\n    }\r\n}\r\n\r\nexport function getAdjacent(dungeon: Dungeon, from: Tile, orthogonal: boolean = true, diagonal: boolean = false) {\r\n    let results = [];\r\n\r\n    if (orthogonal) {\r\n        if (from.x > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x - 1][from.y]);\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x + 1][from.y]);\r\n        }\r\n        if (from.y > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y - 1]);\r\n        }\r\n        if (from.y < dungeon.height - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y + 1]);\r\n        }\r\n    }\r\n    \r\n    if (diagonal) {\r\n        if (from.x > 0) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y + 1]);\r\n            }\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y + 1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n","import { Coord2D } from './Coord';\r\n\r\nexport class Curve {\r\n    static readonly stepsPerSegment = 16;\r\n\r\n    keyPoints: Coord2D[];\r\n    isLoop: boolean;\r\n    renderPoints: number[];\r\n\r\n    constructor(public curvature: number = 0.75) {\r\n        this.keyPoints = [];\r\n        this.isLoop = false;\r\n        this.renderPoints = [];\r\n    }\r\n\r\n    updateRenderPoints() {\r\n        this.renderPoints = [];\r\n\r\n        if (this.keyPoints.length < 2) {\r\n            return;\r\n        }\r\n\r\n        let tension = this.curvature;\r\n        let pts: number[] = [],\r\n            x: number, y: number,\r\n            t1x: number, t2x: number, t1y: number, t2y: number,\r\n            c1: number, c2: number, c3: number, c4: number,\r\n            fraction: number, step: number, iPt: number;\r\n\r\n        let firstCell = this.keyPoints[0];\r\n        let lastCell = this.keyPoints[this.keyPoints.length - 1];\r\n\r\n        // decide if it's a closed loop, which needs the ends of the array set up differently\r\n        let lastCellIndex: number;\r\n        if (firstCell === lastCell) {\r\n            lastCellIndex = this.keyPoints.length - 2; // don't copy the last cell, its the same as the first\r\n            lastCell = this.keyPoints[lastCellIndex];\r\n        } else {\r\n            lastCellIndex = this.keyPoints.length - 1;\r\n        }\r\n        \r\n        for (let cell of this.keyPoints) {\r\n            pts.push(cell.x, cell.y);\r\n        }\r\n        \r\n        if (this.isLoop) {\r\n            // copy last cell onto start, and first cells onto end\r\n            let secondCell = this.keyPoints[1];\r\n            pts.push(firstCell.x, firstCell.y);\r\n            pts.push(secondCell.x, secondCell.y);\r\n            pts.unshift(lastCell.x, lastCell.y);\r\n        } else {\r\n            // copy first cell onto start, and last cell onto end\r\n            pts.unshift(firstCell.x, firstCell.y);\r\n            pts.push(lastCell.x, lastCell.y);\r\n        }\r\n\r\n        // loop through key points. Use each set of 4 points p0 p1 p2 p3 to draw segment p1-p2.\r\n        for (iPt = 2; iPt < (pts.length - 4); iPt += 2) {\r\n            for (step = 0; step <= Curve.stepsPerSegment; step++) {\r\n                // tension vectors\r\n                t1x = (pts[iPt + 2] - pts[iPt - 2]) * tension;\r\n                t2x = (pts[iPt + 4] - pts[iPt]) * tension;\r\n\r\n                t1y = (pts[iPt + 3] - pts[iPt - 1]) * tension;\r\n                t2y = (pts[iPt + 5] - pts[iPt + 1]) * tension;\r\n\r\n                fraction = step / Curve.stepsPerSegment;\r\n\r\n                // cardinals\r\n                c1 =   2 * Math.pow(fraction, 3)  - 3 * Math.pow(fraction, 2) + 1; \r\n                c2 = -(2 * Math.pow(fraction, 3)) + 3 * Math.pow(fraction, 2); \r\n                c3 =       Math.pow(fraction, 3)  - 2 * Math.pow(fraction, 2) + fraction; \r\n                c4 =       Math.pow(fraction, 3)  -     Math.pow(fraction, 2);\r\n\r\n                // x and y coordinates\r\n                x = c1 * pts[iPt]    + c2 * pts[iPt + 2] + c3 * t1x + c4 * t2x;\r\n                y = c1 * pts[iPt + 1]  + c2 * pts[iPt + 3] + c3 * t1y + c4 * t2y;\r\n                this.renderPoints.push(x);\r\n                this.renderPoints.push(y);\r\n            }\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { getAdjacent } from './detectWalls';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function generateWallCurves(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.walls = [];\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isWall && !tile.isFloor) {\r\n            await generateWallCurve(dungeon, tile, true, subStepComplete);\r\n\r\n            if (subStepComplete) {\r\n                await subStepComplete(DelaySize.Medium);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const curve of dungeon.walls) {\r\n        curve.updateRenderPoints();\r\n    }\r\n}\r\n\r\nasync function generateWallCurve(dungeon: Dungeon, firstTile: Tile, isRootLevel: boolean, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const mainCurve = await generateSingleWallCurve(dungeon, firstTile, subStepComplete);\r\n\r\n    while (true) {\r\n        // See if we could have taken a different path at any point.\r\n        const newStartPoint = backtrackToNewStartPoint(dungeon, mainCurve);\r\n        if (newStartPoint === undefined) {\r\n            if (isRootLevel) {\r\n                checkForCurveLoops(dungeon, mainCurve);\r\n            }\r\n\r\n            if (subStepComplete !== undefined) {\r\n                mainCurve.updateRenderPoints();\r\n            }\r\n            return mainCurve;\r\n        }\r\n\r\n        // See if the different path is longer.\r\n        const branchIndex = mainCurve.keyPoints.indexOf(newStartPoint);\r\n        \r\n        const newCurve = await generateWallCurve(dungeon, newStartPoint, false, subStepComplete);\r\n\r\n        if (newCurve.keyPoints.length <= mainCurve.keyPoints.length - branchIndex || newStartPoint === firstTile) {\r\n            continue;\r\n        }\r\n\r\n        // Swap the paths around so that this path is as long as possible.\r\n\r\n        let newBranch = newCurve.keyPoints.slice(1);\r\n        let oldBranch = mainCurve.keyPoints.splice(branchIndex + 1);\r\n        oldBranch.unshift(newStartPoint);\r\n\r\n        newCurve.keyPoints = oldBranch;\r\n        mainCurve.keyPoints = mainCurve.keyPoints.concat(newBranch);\r\n        \r\n        if (isRootLevel) {\r\n            checkForCurveLoops(dungeon, newCurve);\r\n        }\r\n\r\n        if (subStepComplete !== undefined) {\r\n            newCurve.updateRenderPoints();\r\n            mainCurve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}\r\n\r\nfunction backtrackToNewStartPoint(dungeon: Dungeon, curve: Curve) {\r\n    // iterate backwards round this curve, trying to find somewhere to branch off a new curve from\r\n    for (let i = curve.keyPoints.length - 1; i >= 0; i--) {\r\n        let curveTile = curve.keyPoints[i] as Tile;\r\n\r\n        let viableTile = pickBestAdjacentWallTile(dungeon, curveTile, true, true, t => !t.isFloor && t.isWall);\r\n        if (viableTile !== undefined) {\r\n            return curveTile;\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction checkForCurveLoops(dungeon: Dungeon, mainCurve: Curve, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    // detect simple loops, as well as \"p\" and \"b\" loops that need split into two parts\r\n    const firstPoint = mainCurve.keyPoints[0];\r\n    const lastPoint = mainCurve.keyPoints[mainCurve.keyPoints.length - 1];\r\n    \r\n    if (firstPoint === lastPoint) {\r\n        mainCurve.isLoop = true;\r\n    } else {\r\n        let splitPos = mainCurve.keyPoints.lastIndexOf(firstPoint);\r\n        if (splitPos > 0) {\r\n            // p shape, loop at the start\r\n            const splitCurve = new Curve();\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(splitPos + 1);\r\n            splitCurve.keyPoints.unshift(mainCurve.keyPoints[splitPos]);\r\n\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n            \r\n            mainCurve.isLoop = true;\r\n            // console.log('found a P, splitting linear end bit into its own curve');\r\n        }\r\n        \r\n        splitPos = mainCurve.keyPoints.indexOf(lastPoint);\r\n        if (splitPos < mainCurve.keyPoints.length - 1) {\r\n            // b shape, loop at the end\r\n            /*\r\n            console.log(`loop found in curve ${dungeon.walls.indexOf(mainCurve)} at index ${splitPos} ... 0-${splitPos} will separate off linearly, keeping from ${splitPos}-${mainCurve.keyPoints.length - 1} as a loop`);\r\n            console.log(`index ${0} is ${mainCurve.keyPoints[0].x}, ${mainCurve.keyPoints[0].y}`);\r\n            console.log(`index ${splitPos} is ${mainCurve.keyPoints[splitPos].x}, ${mainCurve.keyPoints[splitPos].y}`);\r\n            console.log(`index ${mainCurve.keyPoints.length - 1} is ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].x}, ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].y}`);\r\n            */\r\n            const splitCurve = new Curve();\r\n            const splitPoint = mainCurve.keyPoints[splitPos];\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(0, splitPos - 1);\r\n            splitCurve.keyPoints.push(splitPoint);\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n\r\n            mainCurve.isLoop = true;\r\n            // console.log('found a B, splitting linear start bit into its own curve');\r\n\r\n            /*\r\n            console.log(`after splitting, main curve is ${mainCurve.keyPoints.length} long`);\r\n            console.log(`split curve is ${splitCurve.keyPoints.length} long`);\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\nexport async function generateSingleWallCurve(dungeon: Dungeon, firstTile: Tile, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const curve = new Curve();\r\n    dungeon.walls.push(curve);\r\n\r\n    let prevTile: Tile | undefined = firstTile;\r\n\r\n    // If there's an adjacent tile that's already part of a wall curve, start from that instead.\r\n    const actualFirstTile = getAdjacent(dungeon, firstTile, true, true)\r\n        .find(t => t.isWall && t.isFloor);\r\n    if (actualFirstTile !== undefined) {\r\n        curve.keyPoints.push(actualFirstTile);\r\n        firstTile = actualFirstTile;\r\n    }\r\n\r\n    curve.keyPoints.push(prevTile);\r\n    prevTile.isFloor = true;\r\n\r\n    do {\r\n        // Pick next tile, keep looping. When there isn't a next one, stop. Initially, only look orthogonally.\r\n        let tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n            dungeon,\r\n            prevTile,\r\n            t => !t.isFloor && t.isWall\r\n        );\r\n\r\n        if (tile === undefined) {\r\n            // Do the same check again, but don't ignore tiles that are part of walls. This will be the last one.\r\n            const lastTile = curve.keyPoints.length > 2\r\n                ? curve.keyPoints[curve.keyPoints.length - 2]\r\n                : undefined;\r\n\r\n            tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n                dungeon,\r\n                prevTile,\r\n                t => t.isWall && t !== lastTile\r\n            );\r\n            prevTile = undefined;\r\n        }\r\n        else {\r\n            prevTile = tile;\r\n        }\r\n\r\n        if (tile === firstTile) {\r\n            curve.isLoop = true;\r\n            break;\r\n        }\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        curve.keyPoints.push(tile);\r\n\r\n        if (tile.isFloor) {\r\n            break; // intersected a(nother) curve, so end this one\r\n        }\r\n\r\n        tile.isFloor = true;\r\n        \r\n        if (subStepComplete) {\r\n            curve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n\r\n    } while (prevTile !== undefined)\r\n\r\n    if (subStepComplete) {\r\n        curve.updateRenderPoints();\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    return curve;\r\n}\r\n\r\nexport function pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    const ortho = pickBestAdjacentWallTile(dungeon, from, true, false, filter);\r\n    return ortho !== undefined\r\n        ? ortho\r\n        : pickBestAdjacentWallTile(dungeon, from, false, true, filter);\r\n}\r\n\r\nfunction pickBestAdjacentWallTile(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    orthogonal: boolean,\r\n    diagonal: boolean,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    let bestTile: Tile | undefined;\r\n    let bestNumAdjacentNonWallTiles = 0;\r\n\r\n    let toTest = getAdjacent(dungeon, from, orthogonal, diagonal);\r\n    for (let tile of toTest) {\r\n        if (!filter(tile)) {\r\n            continue;\r\n        }\r\n\r\n        let numAdjacentNonWallTiles = 0;\r\n        let allAdjacent = getAdjacent(dungeon, tile, true, true);\r\n\r\n        for (let adjacent of allAdjacent) {\r\n            if (!adjacent.isWall) {\r\n                numAdjacentNonWallTiles++;\r\n            }\r\n        }\r\n\r\n        if (numAdjacentNonWallTiles > bestNumAdjacentNonWallTiles) {\r\n            bestNumAdjacentNonWallTiles = numAdjacentNonWallTiles;\r\n            bestTile = tile;\r\n        }\r\n    }\r\n    \r\n    return bestTile;\r\n}","import { Coord } from '../model/Coord';\r\n\r\nexport function getClosest<TNode extends Coord<TNode>>(\r\n    point: Coord<TNode>,\r\n    nodes: TNode[],\r\n    getDistance: (node: TNode, point: Coord<TNode>) => number = (node, point) => point.distanceSqTo(node),\r\n) {\r\n    let bestDist = Number.MAX_VALUE;\r\n    let bestNode: TNode | null = null;\r\n\r\n    for (const node of nodes) {\r\n        const dist = getDistance(node, point);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestNode = node;\r\n        }\r\n    }\r\n\r\n    return bestNode;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { getClosest } from '../../lib/graph/getClosest';\r\nimport { Region } from '../model/Region';\r\nimport { Coord } from '../../lib/model/Coord';\r\n\r\nexport async function associateTilesWithNodes(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n\r\n    const distance = (room: Region, point: Coord<Region>) => point.distanceSqTo(room) / room.regionInfluence;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        tile.region = getClosest(tile, dungeon.nodes, distance);\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n    }\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { SRandom } from '../../lib/SRandom';\r\n\r\nexport class Hatching extends Coord2D {\r\n    public readonly rotation: number;\r\n    public readonly lengthScale: number;\r\n    public readonly topSkew: number;\r\n    public readonly bottomSkew: number;\r\n\r\n    constructor(x: number, y: number, seed?: number) {\r\n        if (seed === undefined) {\r\n            super(x + 0.5, y + 0.5);\r\n            this.rotation = 0;\r\n            this.lengthScale = 1;\r\n            this.topSkew = 0;\r\n            this.bottomSkew = 0;\r\n            return;\r\n        }\r\n\r\n        const random = new SRandom(seed + x * x * 4987142 + x * 5947611 + y * y * 4392871 + y * 389711);\r\n\r\n        super(x + random.nextInRange(0.1, 0.9), y + random.nextInRange(0.1, 0.9));\r\n\r\n        this.rotation = random.nextInRange(0, Math.PI * 2);\r\n        this.lengthScale = random.nextInRange(0.9, 1.35);\r\n        this.topSkew = random.nextInRange(0, 0.25);\r\n        this.bottomSkew = random.nextInRange(0, 0.25);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Hatching } from '../model/Hatching';\r\n\r\nexport async function fillBackdrop(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const wallTiles = dungeon.tiles.filter(t => t.isWall);\r\n\r\n    const backdropTiles = new Set<Tile>();\r\n    addAdjacentNonFloorTiles(wallTiles, backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n\r\n    dungeon.backdropPoints = [...backdropTiles]\r\n        .filter(tile => (tile.x + tile.y) % 2 !== 0)\r\n        .map(tile => new Hatching(tile.x, tile.y, seed));\r\n}\r\n\r\nfunction addAdjacentNonFloorTiles(wallTiles: Tile[], backdropTiles: Set<Tile>) {\r\n    for (const tile of wallTiles) {\r\n        for (const adjacent of tile.adjacentTiles) {\r\n            if (!adjacent.isFloor) {\r\n                backdropTiles.add(adjacent);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Region } from './Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\n\r\nexport class Tile extends Coord2D {\r\n    public region: Region | null = null;\r\n    public readonly adjacentTiles: Tile[] = [];\r\n\r\n    constructor(x: number, y: number, public isFloor: boolean = false, public isWall: boolean = false) {\r\n        super(x, y);\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { GenerationSteps } from './GenerationSteps';\r\nimport { SRandom } from '../lib/SRandom';\r\nimport { createRegions } from './generation/createRegions';\r\nimport { populateLinks } from './generation/populateLinks';\r\nimport { filterLinks } from './generation/filterLinks';\r\nimport { createRooms } from './generation/createRooms';\r\nimport { linkLinesToGrid } from './generation/linkLinesToGrid';\r\nimport { detectWalls } from './generation/detectWalls';\r\nimport { generateWallCurves } from './generation/generateWallCurves';\r\nimport { IGenerationSettings } from './IGenerationSettings';\r\nimport { associateTilesWithNodes } from './generation/associateTilesWithNodes';\r\nimport { fillBackdrop } from './generation/fillBackdrop';\r\nimport { createTiles } from './generation/createTiles';\r\n\r\nexport enum DelaySize {\r\n    None = 0,\r\n    Minimal = 10,\r\n    Tiny = 50,\r\n    Small = 100,\r\n    Medium = 500,\r\n    Large = 1500,\r\n}\r\n\r\ntype GenerationStep = (\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepReached?: (interval: DelaySize) => Promise<void>\r\n) => Promise<void>;\r\n\r\nexport async function generateDungeon(\r\n    settings: IGenerationSettings,\r\n) {\r\n    const dungeon = new Dungeon();\r\n    await regenerateDungeon(dungeon, settings);\r\n    return dungeon;\r\n}\r\n\r\nexport async function regenerateDungeon(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n) {\r\n    dungeon.width = settings.cellsWide;\r\n    dungeon.height = settings.cellsHigh;\r\n\r\n    const seedGenerator = new SRandom(settings.seed);\r\n    \r\n    const steps: Array<[GenerationSteps, GenerationStep, DelaySize]> = [\r\n        [GenerationSteps.CreateTiles, createTiles, DelaySize.None],\r\n        [GenerationSteps.CreateNodes, createRegions, DelaySize.Large],\r\n        [GenerationSteps.AssociateTiles, associateTilesWithNodes, DelaySize.Large],\r\n        [GenerationSteps.LinkNodes, populateLinks, DelaySize.Large],\r\n        [GenerationSteps.FilterLinks, filterLinks, DelaySize.Large],\r\n        [GenerationSteps.ExpandLines, linkLinesToGrid, DelaySize.Large],\r\n        [GenerationSteps.CreateRooms, createRooms, DelaySize.Large],\r\n        [GenerationSteps.DetectWalls, detectWalls, DelaySize.Large],\r\n        [GenerationSteps.CurveWalls, generateWallCurves, DelaySize.Large],\r\n        [GenerationSteps.FillBackdrop, fillBackdrop, DelaySize.Large],\r\n    ];\r\n\r\n    for (const [step, operation, endDelay] of steps) {\r\n        const stepSeed = seedGenerator.next();\r\n\r\n        if (settings.generateFrom > step) {\r\n            continue;\r\n        }\r\n\r\n        if (settings.generateTo < step) {\r\n            break;\r\n        }\r\n\r\n        const subStepReached = settings.animateFrom <= step\r\n            ? async (interval: DelaySize) => {\r\n                if (settings.animateFrom > step) {\r\n                    return; // give up on animation\r\n                }\r\n\r\n                settings.redraw(dungeon, step, false);\r\n                await delay(interval);\r\n            }\r\n            : undefined;\r\n        \r\n        await operation(dungeon, settings, stepSeed, subStepReached);\r\n        \r\n        if (settings.animateFrom <= step && endDelay > DelaySize.None) {\r\n            settings.redraw(dungeon, step, true);\r\n            await delay(endDelay);\r\n        }\r\n    }\r\n}\r\n\r\nfunction delay(milliseconds: number): Promise<void> {\r\n    return new Promise<void>(resolve => {\r\n        setTimeout(() => resolve(), milliseconds);\r\n    });\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function createTiles(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.tiles = [];\r\n    dungeon.tilesByCoordinates = [];\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        let col = new Array<Tile>(dungeon.height);\r\n        dungeon.tilesByCoordinates[x] = col;\r\n\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = new Tile(x, y);\r\n            col[y] = tile;\r\n            dungeon.tiles.push(tile);\r\n        }\r\n    }\r\n\r\n    const maxX = dungeon.width - 1;\r\n    const maxY = dungeon.height - 1;\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = dungeon.tilesByCoordinates[x][y];\r\n\r\n            if (x > 0) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y+1]);\r\n                }\r\n            }\r\n\r\n            if (y > 0) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y-1]);\r\n            }\r\n\r\n            if (y < maxY) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y+1]);\r\n            }\r\n            \r\n            if (x < maxX) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y+1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useState, useEffect } from 'react';\r\nimport { Menu } from './menu/Menu';\r\nimport { FixedCanvas } from './Canvas';\r\nimport { Dungeon } from '../dungeon/model/Dungeon';\r\nimport './App.css';\r\nimport { renderDungeon } from '../dungeon/renderDungeon';\r\nimport { generateDungeon, regenerateDungeon } from '../dungeon/generateDungeon';\r\nimport { GenerationSteps } from '../dungeon/GenerationSteps';\r\nimport { determineRenderSettings, IRenderSettings } from '../dungeon/IRenderSettings';\r\nimport { IGenerationSettings } from '../dungeon/IGenerationSettings';\r\n\r\nexport const App: FunctionComponent = () => {\r\n    const canvas = React.useRef<FixedCanvas>(null);\r\n\r\n    const [dungeon, setDungeon] = useState<Dungeon>(new Dungeon());\r\n    const [generating, setGenerating] = useState(false);\r\n\r\n    const cellSize = 10;\r\n\r\n    const [renderSettings, setRenderSettings] = useState<IRenderSettings>(determineRenderSettings(GenerationSteps.Render, true, cellSize));\r\n    \r\n    const [generationSettings, setGenerationSettings] = useState<IGenerationSettings>({\r\n        seed: 0,\r\n        generateFrom: GenerationSteps.FIRST_STEP,\r\n        generateTo: GenerationSteps.Render,\r\n        animateFrom: GenerationSteps.Render,\r\n        cellsWide: 100,\r\n        cellsHigh: 70,\r\n        nodeCount: 25,\r\n        connectivity: 50,\r\n        redraw: (dungeon: Dungeon, stage: GenerationSteps, stageComplete: boolean) => { \r\n            if (canvas.current !== null) {\r\n                renderDungeon(dungeon, canvas.current.ctx!, determineRenderSettings(stage, stageComplete, cellSize));\r\n            }\r\n        },\r\n    });\r\n\r\n    const generate = async (generateTo: GenerationSteps) => {\r\n        const settings = {\r\n            ...generationSettings,\r\n            seed: Math.random(),\r\n            animateFrom: GenerationSteps.Render,\r\n            generateFrom: GenerationSteps.FIRST_STEP,\r\n            generateTo,\r\n        };\r\n\r\n        setGenerationSettings(settings);\r\n        setGenerating(true);\r\n\r\n        const dungeon = await generateDungeon(settings);\r\n\r\n        setDungeon(dungeon);\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const regenerate = async (animate: boolean, regenerateFrom: GenerationSteps, generateTo: GenerationSteps) => {\r\n        // clear the grid if regenerating\r\n        if (regenerateFrom !== GenerationSteps.FIRST_STEP) {\r\n            await regenerateDungeon(dungeon, {\r\n                ...generationSettings,\r\n                animateFrom: GenerationSteps.Render,\r\n                generateFrom: GenerationSteps.CreateTiles,\r\n                generateTo: GenerationSteps.CreateTiles,\r\n            });\r\n        }\r\n\r\n        setGenerating(true);\r\n\r\n        await regenerateDungeon(dungeon, {\r\n            ...generationSettings,\r\n            animateFrom: animate\r\n                ? regenerateFrom\r\n                : GenerationSteps.Render,\r\n            generateFrom: regenerateFrom,\r\n            generateTo,\r\n        });\r\n\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const skip = () => generationSettings.animateFrom++;\r\n    const finish = () => generationSettings.animateFrom = GenerationSteps.Render;\r\n\r\n    useEffect(() => { generate(GenerationSteps.Render) }, []); // eslint-disable-line\r\n\r\n    const setRenderSettingsAndRender = (renderSettings: IRenderSettings) => {\r\n        setRenderSettings(renderSettings);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    return (    \r\n        <div className=\"App\">\r\n            <Menu\r\n                dungeon={dungeon}\r\n                canvas={canvas.current === null ? undefined : canvas.current.canvas}\r\n                cellSize={cellSize}\r\n                isGenerating={generating}\r\n                generationSettings={generationSettings}\r\n                setGenerationSettings={setGenerationSettings}\r\n                setRenderSettings={setRenderSettingsAndRender}\r\n                generate={generate}\r\n                regenerate={regenerate}\r\n                skip={skip}\r\n                finish={finish}\r\n            />\r\n            <FixedCanvas\r\n                className=\"dungeonDisplay\"\r\n                width={cellSize * generationSettings.cellsWide}\r\n                height={cellSize * generationSettings.cellsHigh}\r\n                ref={canvas}\r\n            />\r\n        </div>\r\n    );\r\n}","// tslint:disable:no-console\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the 'N+1' visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL!,\n      window.location.toString()\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker) {\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and\n                // the fresh content will have been added to the cache.\n                // It's the perfect time to display a 'New content is\n                // available; please refresh.' message in your web app.\n                console.log('New content is available; please refresh.');\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // 'Content is cached for offline use.' message.\n                console.log('Content is cached for offline use.');\n              }\n            }\n          };\n        }\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type')!.indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport { App } from './components/App';\r\nimport registerServiceWorker from './registerServiceWorker';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root') as HTMLElement\r\n);\r\nregisterServiceWorker();\r\n"],"sourceRoot":""}