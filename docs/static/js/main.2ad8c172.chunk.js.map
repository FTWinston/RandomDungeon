{"version":3,"sources":["dungeon/GenerationSteps.ts","dungeon/IRenderSettings.ts","components/menu/Generate.tsx","components/common/RangeInput.tsx","components/menu/MapSize.tsx","dungeon/model/Region.ts","lib/model/Coord.ts","components/menu/Regions.tsx","lib/randomColor.ts","components/menu/Menu.tsx","components/Canvas.tsx","dungeon/model/Dungeon.ts","dungeon/renderDungeon.ts","lib/SRandom.ts","dungeon/generation/createRegions.ts","lib/model/Polygon.ts","lib/model/Triangle.ts","lib/graph/delauney.ts","lib/graph/gabriel.ts","lib/graph/getUniqueLines.ts","lib/graph/minimumSpanning.ts","lib/graph/relativeNeighbourhood.ts","dungeon/model/Pathway.ts","lib/model/Line.ts","dungeon/generation/populateLinks.ts","dungeon/generation/filterLinks.ts","dungeon/generation/populateCaveRegion.ts","dungeon/generation/populateRoomRegion.ts","dungeon/generation/createRooms.ts","dungeon/generation/linkLinesToGrid.ts","dungeon/generation/detectWalls.ts","lib/model/Curve.ts","dungeon/generation/generateWallCurves.ts","lib/graph/getClosest.ts","dungeon/generation/associateTilesWithNodes.ts","dungeon/model/Hatching.ts","dungeon/generation/fillBackdrop.ts","dungeon/model/Tile.ts","dungeon/generateDungeon.ts","dungeon/generation/createTiles.ts","components/App.tsx","registerServiceWorker.ts","index.tsx"],"names":["GenerationSteps","determineRenderSettings","generationStage","Render","stageComplete","cellSize","nodeAlpha","regionAlpha","drawGraph","drawNodeLinks","drawGrid","drawWalls","highlightWallCurves","drawOutside","drawOutsidePoints","CreateTiles","CreateNodes","AssociateTiles","LinkNodes","FilterLinks","ExpandLines","CreateRooms","DetectWalls","CurveWalls","FillBackdrop","floorColor","floorGridColor","backgroundColor","hatchingColor","wallColor","wallWidth","floorGridWidth","hatchingWidth","drawWallsAsFloor","Generate","props","generate","regenerate","generateNew","useMemo","animate","generateOrSkip","isGenerating","className","onClick","animateOrFinish","useEffect","setRenderSettings","showSize","showRegions","showConnections","showRenders","RangeInput","onChange","onChangeComplete","changeHandler","undefined","e","target","valueAsNumber","changeCompleteHandler","label","type","inputClassName","min","max","value","onMouseUp","onTouchEnd","disabled","RegionType","MapSize","goBack","generationSettings","cellsWide","val","setGenerationSettings","redraw","cellsHigh","Coord2D","x","y","this","magnitude","other","length","magnitudeSq","dx","dy","scale","b","c","a","d","center","Math","sqrt","RegionMode","Region","parent","seed","regionType","color","regionInfluence","radius","links","colorChars","MenuPage","Regions","dungeonDisplay","dungeon","text","useState","AddRemove","mode","setMode","leftClick","rightClick","cellX","offsetX","cellY","offsetY","random","floor","NUM_VALUES","nodes","push","r","g","randomColor","preventDefault","cell","getTileAt","region","node","filter","n","Resize","ChangeType","FIRST_VALUE","addEventListener","removeEventListener","Menu","Main","currentPage","setCurrentPage","switchToMain","switchToSize","Size","switchToRegions","switchToConnections","Connections","switchToRenders","Renders","canvas","skip","finish","FixedCanvas","ctx","root","state","width","height","ref","updateCtx","prevProps","prevState","getContext","React","Dungeon","lines","backdropPoints","delauneyLines","gabrielLines","relativeNeighbourhoodLines","minimumSpanningLines","tiles","tilesByCoordinates","walls","col","renderDungeon","settings","clearRect","lineWidth","drawTile","drawTileGrid","globalAlpha","strokeStyle","drawPath","fillStyle","save","clipOutside","fillRect","xScale","point","yScale","lengthScale","translate","rotate","rotation","beginPath","moveTo","topSkew","lineTo","bottomSkew","fill","stroke","restore","fillOutside","arc","PI","lineCap","drawCurve","i","drawNode","pathway","from","to","room","tile","isFloor","isWall","strokeRect","curve","draw","halfCellSize","keyPoints","points","renderPoints","cx","cy","rect","clip","SRandom","s0","s1","s2","mash","t","next","minInclusive","maxExclusive","nextInRange","nextIntInRange","data","toString","h","charCodeAt","createRegions","subStepComplete","makeNode","influence","nextColor","nodeCount","addSpacedNode","DelaySize","Small","totWidth","totHeight","getScaledDistSq","n1","n2","dxScaled","dyScaled","node1","node2","closestDist1","Number","MAX_VALUE","closestDist2","Triangle","vertices","circumCenter","circumRadiusSq","circumCircle","computeDelauneyTriangulation","superTriangle","triangulation","badTriangles","triangle","insideCircumcircle","polygon","edgeFrom","edgeTo","sharedWithOther","indexOf","splice","vertex","distanceSqTo","computeGabrielGraph","graph","graphLinks","link","anyBlocking","halfwayTo","radiusSq","getUniqueLines","polygons","createLine","allLines","v0","v1","some","l","computeMinimumSpanningTree","unvisitedNodes","slice","firstNode","pop","possibleLinks","map","lengthSq","sort","visitedNodes","testLink","alreadyHasFrom","alreadyHasTo","addingNode","j","computeRelativeNeighbourhoodGraph","Pathway","populateLinks","enclosingTriangle","Artificial","delauneyTriangles","Medium","filterLinks","connectivity","selectingFrom","selectFraction","numToSelect","round","selectedLink","populateCaveRegion","regionTiles","nonEdgeTiles","adjacentTiles","mutableTiles","runCellularAutomataStep","removeUnconnectedFloorTiles","cells","results","Map","wasAlive","numAdjacentLiving","shouldLive","set","result","rootTile","connectedTiles","Set","tilesToTest","has","add","populateRoomRegion","nodeX","nodeY","determineBounds","minX","minY","maxX","maxY","growUpLeft","growDownRight","canLeft","canUp","isRowInRegion","isColInRegion","canRight","canDown","y1","y2","x1","x2","createRooms","Natural","linkLinesToGrid","x0","y0","col0","cell0","col1","cell1","steep","abs","tmp","gradient","iY","closestSideStep","almostInteger","detectWalls","iCol","toTest","getAdjacent","test","Tiny","orthogonal","diagonal","Curve","curvature","isLoop","t1x","t2x","t1y","t2y","c1","c2","c3","c4","fraction","step","iPt","lastCellIndex","tension","pts","firstCell","lastCell","secondCell","unshift","stepsPerSegment","pow","generateWallCurves","generateWallCurve","updateRenderPoints","firstTile","isRootLevel","generateSingleWallCurve","mainCurve","newStartPoint","backtrackToNewStartPoint","checkForCurveLoops","branchIndex","newCurve","newBranch","oldBranch","concat","curveTile","pickBestAdjacentWallTile","firstPoint","lastPoint","splitPos","lastIndexOf","splitCurve","splitPoint","prevTile","actualFirstTile","find","pickBestAdjacentWallTileOrthogonalThenDiagonal","lastTile","Minimal","ortho","bestTile","bestNumAdjacentNonWallTiles","numAdjacentNonWallTiles","allAdjacent","getClosest","getDistance","bestDist","bestNode","dist","associateTilesWithNodes","distance","Hatching","fillBackdrop","wallTiles","backdropTiles","addAdjacentNonFloorTiles","adjacent","Tile","createTiles","Array","generateDungeon","regenerateDungeon","seedGenerator","steps","None","Large","operation","endDelay","stepSeed","generateFrom","generateTo","subStepReached","animateFrom","interval","delay","milliseconds","Promise","resolve","setTimeout","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","catch","error","ReactDOM","setDungeon","generating","setGenerating","renderSettings","FIRST_STEP","stage","current","regenerateFrom","document","getElementById","URL","process","origin","fetch","response","status","headers","get","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.2ad8c172.chunk.js","sourcesContent":["export enum GenerationSteps {\r\n    CreateTiles,\r\n    CreateNodes,\r\n    AssociateTiles,\r\n    LinkNodes,\r\n    FilterLinks,\r\n    ExpandLines,\r\n    CreateRooms,\r\n    DetectWalls,\r\n    CurveWalls,\r\n    FillBackdrop,\r\n    Render,\r\n\r\n\r\n    FIRST_STEP = CreateTiles,\r\n}\r\n","import { GenerationSteps } from './GenerationSteps';\r\n\r\nexport interface IRenderSettings {\r\n    nodeAlpha: number;\r\n    regionAlpha: number;\r\n    drawGraph: boolean;\r\n    drawNodeLinks: boolean;\r\n    drawGrid: boolean;\r\n    drawWalls: boolean;\r\n    highlightWallCurves: boolean;\r\n    drawOutsidePoints: boolean;\r\n    drawOutside: boolean;\r\n    backgroundColor: string;\r\n    floorColor: string;\r\n    floorGridColor: string;\r\n    floorGridWidth: number;\r\n    wallColor: string;\r\n    hatchingColor: string;\r\n    cellSize: number,\r\n    wallWidth: number,\r\n    hatchingWidth: number,\r\n    drawWallsAsFloor: boolean,\r\n}\r\n\r\nexport function determineRenderSettings(   \r\n    generationStage = GenerationSteps.Render,\r\n    stageComplete: boolean = true,\r\n    cellSize: number,\r\n): IRenderSettings {\r\n    let nodeAlpha = 0;\r\n    let regionAlpha = 0;\r\n    let drawGraph = false;\r\n    let drawNodeLinks = false;\r\n    let drawGrid = false;\r\n    let drawWalls = false;\r\n    let highlightWallCurves = false;\r\n    let drawOutside = false;\r\n    let drawOutsidePoints = false;\r\n    let drawWallsAsFloor = true;\r\n\r\n    switch (generationStage) {\r\n        case GenerationSteps.CreateTiles:\r\n            drawGrid = true;\r\n            break;\r\n            \r\n        case GenerationSteps.CreateNodes:\r\n            nodeAlpha = 1;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.AssociateTiles:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.66;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.LinkNodes:\r\n            nodeAlpha = 1;\r\n            regionAlpha = 0.5;\r\n            drawGraph = true;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.FilterLinks:\r\n            nodeAlpha = 0.75;\r\n            regionAlpha = 0.55;\r\n            drawNodeLinks = true;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.ExpandLines:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CreateRooms:\r\n            regionAlpha = 0.5;\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.DetectWalls:\r\n            drawGrid = true;\r\n            break;\r\n\r\n        case GenerationSteps.CurveWalls:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n\r\n            highlightWallCurves = !stageComplete;\r\n            break;\r\n\r\n        case GenerationSteps.FillBackdrop:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutsidePoints = true;\r\n            break;\r\n\r\n        case GenerationSteps.Render:\r\n            drawGrid = true;\r\n            drawWalls = true;\r\n            drawOutside = true;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        nodeAlpha,\r\n        regionAlpha,\r\n        drawGraph,\r\n        drawNodeLinks,\r\n        drawGrid,\r\n        drawWalls,\r\n        highlightWallCurves,\r\n        drawOutsidePoints,\r\n        drawOutside,\r\n        floorColor: '#fff',\r\n        floorGridColor: 'rgba(192,192,192,0.5)',\r\n        backgroundColor: '#fff',\r\n        hatchingColor: '#000',\r\n        wallColor: '#000',\r\n        cellSize,\r\n        wallWidth: cellSize,\r\n        floorGridWidth: 1,\r\n        hatchingWidth: cellSize * 0.175,\r\n        drawWallsAsFloor,\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo, useEffect } from 'react';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\nexport interface Props {\r\n    isGenerating: boolean;\r\n    generate: (generateTo: GenerationSteps) => Promise<void>;\r\n    regenerate: (animate: boolean, generateFrom: GenerationSteps, generateTo: GenerationSteps) => Promise<void>;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    skip: () => void;\r\n    finish: () => void;\r\n\r\n    showSize: () => void;\r\n    showRegions: () => void;\r\n    showConnections: () => void;\r\n    showRenders: () => void;\r\n}\r\n\r\nexport const Generate: FunctionComponent<Props> = props => {\r\n    const { generate, regenerate } = props;\r\n\r\n    const generateNew = useMemo(() => (() => generate(GenerationSteps.Render)), [generate]);\r\n    const animate = useMemo(() => (() => regenerate(true, GenerationSteps.AssociateTiles, GenerationSteps.Render)), [regenerate]);\r\n\r\n    const generateOrSkip = props.isGenerating\r\n        ? <button className=\"menu__button\">Skip step</button>\r\n        : <button className=\"menu__button\" onClick={generateNew}>Generate new</button>\r\n\r\n    const animateOrFinish = props.isGenerating\r\n        ? <button className=\"menu__button\">Finish</button>\r\n        : <button className=\"menu__button\" onClick={animate}>Animate generation</button>\r\n\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.Render, true, props.cellSize),\r\n        });\r\n    }, []); // eslint-disable-line\r\n    \r\n    return <div className=\"menu menu--autoGenerate\">\r\n        <button className=\"menu__link\" onClick={props.showSize}>Map size</button>\r\n        <button className=\"menu__link\" onClick={props.showRegions}>Edit regions</button>\r\n        <button className=\"menu__link\" onClick={props.showConnections}>Regions connections</button>\r\n        <button className=\"menu__link\" onClick={props.showRenders}>Renders</button>\r\n\r\n        <div className=\"menu__spacer\" />\r\n\r\n        {generateOrSkip}\r\n        {animateOrFinish}\r\n    </div>\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useMemo } from 'react';\r\n\r\ninterface Props {\r\n    className?: string;\r\n    inputClassName?: string;\r\n    label: string;\r\n    min: number;\r\n    max: number;\r\n    value: number;\r\n    onChange?: (val: number) => void;\r\n    onChangeComplete?: () => void;\r\n    disabled?: boolean;\r\n}\r\n\r\nexport const RangeInput: FunctionComponent<Props> = props => {\r\n    const {onChange, onChangeComplete} = props;\r\n\r\n    const changeHandler = useMemo(() => {\r\n        if (onChange === undefined) {\r\n            return undefined;\r\n        }\r\n        return (e: React.ChangeEvent<HTMLInputElement>) => onChange(e.target.valueAsNumber)\r\n    }, [onChange]);\r\n\r\n    const changeCompleteHandler = useMemo(() => {\r\n        if (onChangeComplete === undefined) {\r\n            return undefined;\r\n        }\r\n        return () => onChangeComplete();\r\n    }, [onChangeComplete]);\r\n\r\n    return (\r\n        <label className={props.className}>{props.label}\r\n            <input\r\n                type=\"range\"\r\n                className={props.inputClassName}\r\n                min={props.min}\r\n                max={props.max}\r\n                value={props.value}\r\n                onChange={changeHandler}\r\n                onMouseUp={changeCompleteHandler}\r\n                onTouchEnd={changeCompleteHandler}\r\n                disabled={props.disabled}\r\n            />\r\n        </label>\r\n    );\r\n}\r\n","import * as React from 'react';\r\nimport { FunctionComponent, useEffect } from 'react';\r\nimport { RangeInput } from '../common/RangeInput';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    generationSettings: IGenerationSettings;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nexport const MapSize: FunctionComponent<Props> = props => {\r\n    const setWidth = (val: number) => {\r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsWide: val,\r\n        });\r\n    }\r\n\r\n    const setHeight = (val: number) => {\r\n        props.setGenerationSettings({\r\n            ...props.generationSettings,\r\n            cellsHigh: val,\r\n        });\r\n    }\r\n\r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    return <div className=\"menu menu--mapSize\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n    \r\n        <div className=\"menu__group\">\r\n            <RangeInput\r\n                label=\"Width\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsWide}\r\n                onChange={setWidth}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n\r\n            <RangeInput\r\n                label=\"Height\"\r\n                min={20}\r\n                max={200}\r\n                value={props.generationSettings.cellsHigh}\r\n                onChange={setHeight}\r\n                onChangeComplete={props.redraw}\r\n            />\r\n        </div>\r\n    </div>\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { Dungeon } from './Dungeon';\r\nimport { Pathway } from './Pathway';\r\n\r\nexport enum RegionType {\r\n    Natural = 0,\r\n    Artificial = 1,\r\n\r\n    NUM_VALUES,\r\n    FIRST_VALUE = 0,\r\n}\r\n\r\nexport class Region extends Coord2D {\r\n    radius: number = 0.75;\r\n    links: Pathway[] = [];\r\n\r\n    constructor(\r\n        readonly parent: Dungeon,\r\n        x: number,\r\n        y: number,\r\n        public seed: number,\r\n        public regionType: RegionType,\r\n        public readonly color: string,\r\n        public regionInfluence = 1\r\n    ) {\r\n        super(x, y);\r\n    }\r\n}","export abstract class Coord<TCoord extends Coord<TCoord>> {\r\n    abstract length(): number;\r\n\r\n    abstract equals(other: Coord<TCoord>): boolean;\r\n    \r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract subtract(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract toUnitLength(): Coord<TCoord>;\r\n\r\n    abstract distanceTo(other: Coord<TCoord>): number;\r\n    \r\n    abstract distanceSqTo(other: Coord<TCoord>): number;\r\n\r\n    abstract directionTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract halfwayTo(other: Coord<TCoord>): Coord<TCoord>;\r\n\r\n    abstract scale(scale: number): Coord<TCoord>;\r\n    \r\n    abstract crossProduct(other: Coord<TCoord>): number;\r\n\r\n    abstract circumCircle(b: Coord<TCoord>, c: Coord<TCoord>): [Coord<TCoord>, number];\r\n}\r\n\r\nexport class Coord2D extends Coord<Coord2D> {\r\n    constructor(public x: number, public y: number) {\r\n        super();\r\n    }\r\n\r\n    length() {\r\n        return this.magnitude(this.x, this.y);\r\n    }\r\n\r\n    equals(other: Coord2D) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    add(other: Coord2D) {\r\n        return new Coord2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subtract(other: Coord2D) {\r\n        return new Coord2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    toUnitLength() {\r\n        let length = this.length();\r\n        return new Coord2D(this.x / length, this.y / length);\r\n    }\r\n    \r\n    distanceTo(other: Coord2D) {\r\n        return this.magnitude(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    distanceSqTo(other: Coord2D) {\r\n        return this.magnitudeSq(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    directionTo(other: Coord2D) {\r\n        let dx = other.x - this.x;\r\n        let dy = other.y - this.y;\r\n        \r\n        let length = this.magnitude(dx, dy);\r\n        return new Coord2D(dx / length, dy / length);\r\n    }\r\n\r\n    halfwayTo(other: Coord2D) {\r\n        return new Coord2D((this.x + other.x) / 2, (this.y + other.y) / 2);\r\n    }\r\n\r\n    scale(scale: number) {\r\n        return new Coord2D(this.x * scale, this.y * scale);\r\n    }\r\n\r\n    crossProduct(other: Coord2D) {\r\n        return this.x * other.y - this.y * other.x;\r\n    }\r\n\r\n    circumCircle(b: Coord2D, c: Coord2D) {\r\n        let a = this;\r\n        let d = (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n        \r\n        let x = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) \r\n             -  ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.y - c.y))\r\n        / d;\r\n\r\n        let y = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x)\r\n            -  ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x))\r\n        / d;\r\n\r\n        let center = new Coord2D(x, y);\r\n\r\n        let rSquared = (c.x - center.x) * (c.x - center.x) + (c.y - center.y) * (c.y - center.y);\r\n\r\n        let retVal: [Coord2D, number] = [\r\n            center,\r\n            rSquared\r\n        ];\r\n\r\n        return retVal;\r\n    }\r\n\r\n    private magnitude(dx: number, dy: number) {\r\n        return Math.sqrt(this.magnitudeSq(dx, dy));\r\n    }\r\n\r\n    private magnitudeSq(dx: number, dy: number) {\r\n        return dx * dx + dy * dy;\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useEffect, useState } from 'react';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { Region, RegionType } from '../../dungeon/model/Region';\r\nimport { IRenderSettings, determineRenderSettings } from '../../dungeon/IRenderSettings';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { randomColor } from '../../lib/randomColor';\r\n\r\ninterface Props {\r\n    goBack: () => void;\r\n    dungeon: Dungeon;\r\n    dungeonDisplay?: HTMLElement;\r\n    cellSize: number;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    redraw: () => void;\r\n}\r\n\r\nenum RegionMode {\r\n    AddRemove,\r\n    Resize,\r\n    ChangeType,\r\n}\r\n\r\nexport const Regions: FunctionComponent<Props> = props => {\r\n    const { dungeonDisplay, dungeon, redraw, cellSize } = props;\r\n    \r\n    useEffect(() => {\r\n        props.setRenderSettings({\r\n            ...determineRenderSettings(GenerationSteps.DetectWalls, true, props.cellSize),\r\n            regionAlpha: 0.5,\r\n            nodeAlpha: 1.0,\r\n            drawWallsAsFloor: false,\r\n        });\r\n    }, []); // eslint-disable-line\r\n\r\n    const [mode, setMode] = useState(RegionMode.AddRemove);\r\n\r\n    // add/remove effect\r\n    useEffect(() => {\r\n        if (dungeonDisplay === undefined) {\r\n            return;\r\n        }\r\n\r\n        let leftClick: (e: MouseEvent) => void;\r\n        let rightClick: (e: MouseEvent) => void;\r\n\r\n        switch (mode) {\r\n            case RegionMode.AddRemove:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    // add new node\r\n                    const seed = Math.random();\r\n                    const regionType = Math.floor(Math.random() * RegionType.NUM_VALUES);\r\n                    dungeon.nodes.push(new Region(dungeon, cellX, cellY, seed, regionType, randomColor()));\r\n                    redraw();\r\n                };\r\n\r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    // remove associated node\r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    const node = cell.region;\r\n                    dungeon.nodes = dungeon.nodes.filter(n => n !== node);\r\n        \r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.Resize:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence *= 1.2;\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    cell.region.regionInfluence /= 1.2;\r\n                    redraw();\r\n                };\r\n                break;\r\n            case RegionMode.ChangeType:\r\n                leftClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n        \r\n                    if (++cell.region.regionType >= RegionType.NUM_VALUES) {\r\n                        cell.region.regionType = RegionType.FIRST_VALUE;\r\n                    }\r\n                    redraw();\r\n                };\r\n        \r\n                rightClick = (e: MouseEvent) => {\r\n                    const cellX = e.offsetX / cellSize;\r\n                    const cellY = e.offsetY / cellSize;\r\n        \r\n                    e.preventDefault();\r\n        \r\n                    const cell = dungeon.getTileAt(cellX, cellY);\r\n                    if (cell === undefined || cell.region === null) {\r\n                        return;\r\n                    }\r\n\r\n                    cell.region.seed = Math.random();\r\n                    redraw();\r\n                };\r\n                break;\r\n            default:\r\n                return;       \r\n        }\r\n\r\n        dungeonDisplay.addEventListener('click', leftClick);\r\n        dungeonDisplay.addEventListener('contextmenu', rightClick);\r\n\r\n        return () => {\r\n            dungeonDisplay.removeEventListener('click', leftClick);\r\n            dungeonDisplay.removeEventListener('contextmenu', rightClick);\r\n        };\r\n    }, [dungeonDisplay, dungeon, redraw, cellSize, mode]);\r\n\r\n    let text: string | undefined;\r\n\r\n    switch (mode) {\r\n        case RegionMode.AddRemove:\r\n            text = \"Left click the map to place region nodes. Right click to remove a region.\";\r\n            break;\r\n        case RegionMode.Resize:\r\n            text = \"Left click the a region to grow it, right click a region to shrink it.\";\r\n            break;\r\n        case RegionMode.ChangeType:\r\n            text = \"Left click a region to change its type. Right click to regenerate it with the same type.\";\r\n            break;\r\n    }\r\n\r\n    return <div className=\"menu menu--regionPlacement\">\r\n        <button className=\"menu__button menu__button--back\" onClick={props.goBack}>Go back</button>\r\n\r\n        <ul className=\"menu__choice\">\r\n            <li className={mode === RegionMode.AddRemove ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.AddRemove)}>Add/remove regions</li>\r\n            <li className={mode === RegionMode.Resize ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.Resize)}>Resize regions</li>\r\n            <li className={mode === RegionMode.ChangeType ? 'menu__selector menu__selector--active' : 'menu__selector'} onClick={() => setMode(RegionMode.ChangeType)}>Change region types</li>\r\n        </ul>\r\n\r\n        <div className=\"menu__section\">\r\n            {text}\r\n        </div>\r\n    </div>\r\n}","const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n\r\nexport function randomColor() {\r\n    const r = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const g = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    const b = colorChars[Math.floor(Math.random() * colorChars.length)];\r\n    return `#${r}${g}${b}`;\r\n}","import * as React from 'react';\r\nimport './Menu.css';\r\nimport { FunctionComponent, useState, useMemo } from 'react';\r\nimport { Generate } from './Generate';\r\nimport { Dungeon } from '../../dungeon/model/Dungeon';\r\nimport { MapSize } from './MapSize';\r\nimport { GenerationSteps } from '../../dungeon/GenerationSteps';\r\nimport { IGenerationSettings } from '../../dungeon/IGenerationSettings';\r\nimport { Regions } from './Regions';\r\nimport { IRenderSettings } from '../../dungeon/IRenderSettings';\r\n\r\ninterface Props {\r\n    isGenerating: boolean;\r\n    dungeon: Dungeon;\r\n    canvas?: HTMLCanvasElement;\r\n    cellSize: number;\r\n    generationSettings: Readonly<IGenerationSettings>;\r\n    setGenerationSettings: (settings: IGenerationSettings) => void;\r\n    setRenderSettings: (settings: IRenderSettings) => void;\r\n    generate: (generateTo: GenerationSteps) => Promise<void>;\r\n    regenerate: (animate: boolean, generateFrom: GenerationSteps, generateTo: GenerationSteps) => Promise<void>;\r\n    skip: () => void;\r\n    finish: () => void;\r\n}\r\n\r\nenum MenuPage {\r\n    Main,\r\n    Size,\r\n    Regions,\r\n    Connections,\r\n    Renders,\r\n}\r\n\r\nexport const Menu: FunctionComponent<Props> = props => {\r\n    const [currentPage, setCurrentPage] = useState(MenuPage.Main);\r\n\r\n    const switchToMain = useMemo(() => () => setCurrentPage(MenuPage.Main), []);\r\n    const switchToSize = useMemo(() => () => setCurrentPage(MenuPage.Size), []);\r\n    const switchToRegions = useMemo(() => () => setCurrentPage(MenuPage.Regions), []);\r\n    const switchToConnections = useMemo(() => () => setCurrentPage(MenuPage.Connections), []);\r\n    const switchToRenders = useMemo(() => () => setCurrentPage(MenuPage.Renders), []);\r\n\r\n    switch (currentPage) {\r\n        case MenuPage.Size:\r\n            return (\r\n                <MapSize\r\n                    goBack={switchToMain}\r\n                    generationSettings={props.generationSettings}\r\n                    setGenerationSettings={props.setGenerationSettings}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, GenerationSteps.AssociateTiles, GenerationSteps.CreateRooms)}\r\n                />\r\n            );\r\n        case MenuPage.Regions:\r\n            return (\r\n                <Regions\r\n                    goBack={switchToMain}\r\n                    dungeon={props.dungeon}\r\n                    dungeonDisplay={props.canvas}\r\n                    cellSize={props.cellSize}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    redraw={() => props.regenerate(false, GenerationSteps.AssociateTiles, GenerationSteps.Render)}\r\n                />\r\n            );\r\n\r\n        // TODO: other pages\r\n\r\n        default:\r\n            return (\r\n                <Generate\r\n                    isGenerating={props.isGenerating}\r\n                    setRenderSettings={props.setRenderSettings}\r\n                    cellSize={props.cellSize}\r\n                    generate={props.generate}\r\n                    regenerate={props.regenerate}\r\n                    skip={props.skip}\r\n                    finish={props.finish}\r\n\r\n                    showSize={switchToSize}\r\n                    showRegions={switchToRegions}\r\n                    showConnections={switchToConnections}\r\n                    showRenders={switchToRenders}\r\n                />\r\n            );\r\n    }\r\n};","import * as React from 'react';\r\n\r\ninterface FixedProps {\r\n    width: number;\r\n    height: number;\r\n    className?: string;\r\n}\r\n\r\nexport class FixedCanvas extends React.Component<FixedProps, {}> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    public canvas?: HTMLCanvasElement;\r\n\r\n    constructor(props: FixedProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: props.width === undefined ? 0 : props.width,\r\n            height: props.height === undefined ? 0 : props.height,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.props.width}\r\n                    height={this.props.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    componentDidMount() {\r\n        this.updateCtx();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        const ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n}\r\n\r\ninterface ResponsiveProps {\r\n    className?: string;\r\n    sizeChanged?: (width: number, height: number) => void;\r\n}\r\n\r\ninterface ResponsiveState {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport class ResponsiveCanvas extends React.Component<ResponsiveProps, ResponsiveState> {\r\n    public ctx?: CanvasRenderingContext2D;\r\n    private root?: HTMLDivElement;\r\n    private canvas?: HTMLCanvasElement;\r\n    private resizeListener?: () => void;\r\n\r\n    constructor(props: ResponsiveProps) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className={this.props.className} ref={r => this.root = r === null ? this.root : r}>\r\n                <canvas\r\n                    width={this.state.width}\r\n                    height={this.state.height}\r\n                    ref={c => this.canvas = c === null ? this.canvas : c}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateCtx();\r\n\r\n        this.resizeListener = () => this.updateSize();\r\n        window.addEventListener('resize', this.resizeListener);\r\n    \r\n        this.updateSize();\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        if (this.resizeListener !== undefined) {\r\n            window.removeEventListener('resize', this.resizeListener);\r\n        }\r\n    }\r\n\r\n    componentDidUpdate(prevProps: FixedProps, prevState: {}) {\r\n        this.updateCtx();\r\n    }\r\n\r\n    updateSize() {\r\n        if (this.root === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let scrollSize = this.getScrollbarSize();\r\n        let width = this.root.offsetWidth - scrollSize.width;\r\n        let height = this.root.offsetHeight - scrollSize.height;\r\n\r\n        this.setState({\r\n            width: width,\r\n            height: height,\r\n        });\r\n\r\n        if (this.props.sizeChanged !== undefined) {\r\n            this.props.sizeChanged(width, height);\r\n        }\r\n    }\r\n\r\n    private updateCtx() {\r\n        if (this.canvas === undefined) {\r\n            return;\r\n        }\r\n        \r\n        let ctx = this.canvas.getContext('2d');\r\n\r\n        if (ctx !== null) {\r\n            this.ctx = ctx;\r\n        }\r\n    }\r\n\r\n    private getScrollbarSize() {\r\n        let outer = document.createElement('div');\r\n        outer.style.visibility = 'hidden';\r\n        outer.style.width = '100px';\r\n        outer.style.height = '100px';\r\n        outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\r\n\r\n        document.body.appendChild(outer);\r\n\r\n        let widthNoScroll = outer.offsetWidth;\r\n        let heightNoScroll = outer.offsetHeight;\r\n\r\n        // force scrollbars\r\n        outer.style.overflow = 'scroll';\r\n\r\n        // add innerdiv\r\n        let inner = document.createElement('div');\r\n        inner.style.width = '100%';\r\n        inner.style.height = '100%';\r\n        outer.appendChild(inner);\r\n\r\n        let widthWithScroll = inner.offsetWidth;\r\n        let heightWithScroll = inner.offsetHeight;\r\n\r\n        // remove divs\r\n        (outer.parentNode as HTMLElement).removeChild(outer);\r\n\r\n        return {\r\n            width: widthNoScroll - widthWithScroll,\r\n            height: heightNoScroll - heightWithScroll,\r\n        };\r\n    }\r\n}","import { Pathway } from './Pathway';\r\nimport { Region } from './Region';\r\nimport { Tile } from './Tile';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { Hatching } from './Hatching';\r\n\r\nexport class Dungeon implements IGraph<Region, Pathway> {\r\n    nodes: Region[] = [];\r\n    lines: Pathway[] = [];\r\n    backdropPoints: Hatching[] = [];\r\n    delauneyLines: Pathway[] = [];\r\n    gabrielLines: Pathway[] = [];\r\n    relativeNeighbourhoodLines: Pathway[] = [];\r\n    minimumSpanningLines: Pathway[] = [];\r\n\r\n    width: number = 0;\r\n    height: number = 0;\r\n\r\n    tiles: Tile[] = [];\r\n    tilesByCoordinates: Tile[][] = [];\r\n    walls: Curve[] = [];\r\n\r\n    public getTileAt(x: number, y: number) {\r\n        const col = this.tilesByCoordinates[Math.floor(x)];\r\n\r\n        if (col === undefined) {\r\n            return;\r\n        }\r\n\r\n        return col[Math.floor(y)];\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { Pathway } from './model/Pathway';\r\nimport { Region } from './model/Region';\r\nimport { Tile } from './model/Tile';\r\nimport { Curve } from '../lib/model/Curve';\r\nimport { IRenderSettings } from './IRenderSettings';\r\n\r\nexport function renderDungeon(   \r\n    dungeon: Dungeon,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n) {\r\n    ctx.clearRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n\r\n    if (settings.drawGrid) {\r\n        drawTileGrid(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawGraph) {\r\n        drawGraph(ctx, dungeon, settings);\r\n    }\r\n    \r\n    if (settings.drawOutside) {\r\n        fillOutside(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawOutsidePoints) {\r\n        drawOutsidePoints(ctx, dungeon, settings);\r\n    }\r\n\r\n    if (settings.drawWalls) {\r\n        ctx.strokeStyle = ctx.fillStyle = settings.highlightWallCurves ? '#f00' : '#000';\r\n        ctx.lineCap = 'round';\r\n        for (const curve of dungeon.walls) {\r\n            drawCurve(curve, ctx, settings);\r\n        }\r\n        ctx.lineCap = 'butt';\r\n    }\r\n    \r\n    if (settings.drawNodeLinks) {\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = '#000';\r\n        for (let line of dungeon.lines) {\r\n            drawPath(line, ctx, settings);\r\n        }\r\n    }\r\n\r\n    if (settings.nodeAlpha > 0) {\r\n        ctx.globalAlpha = settings.nodeAlpha;\r\n        for (let i = 0; i < dungeon.nodes.length; i++) {\r\n            drawNode(dungeon.nodes[i], ctx, settings);\r\n        }\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawTileGrid(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.lineWidth = settings.floorGridWidth;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        drawTile(tile, ctx, settings);\r\n    }\r\n}\r\n\r\nfunction drawPath(pathway: Pathway, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(pathway.from.x * settings.cellSize, pathway.from.y * settings.cellSize);\r\n    ctx.lineTo(pathway.to.x * settings.cellSize, pathway.to.y * settings.cellSize);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction drawNode(room: Region, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    ctx.fillStyle = '#c00';\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(room.x * settings.cellSize, room.y * settings.cellSize, settings.cellSize * room.radius, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n}\r\n\r\nfunction drawTile(tile: Tile, ctx: CanvasRenderingContext2D, settings: IRenderSettings) {\r\n    if (tile.isFloor && (!tile.isWall || settings.drawWallsAsFloor)) {\r\n        ctx.fillStyle = settings.floorColor;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.strokeStyle = settings.floorGridColor;\r\n        ctx.strokeRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n    else if (tile.isWall) {\r\n        ctx.fillStyle = '#333';\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n    }\r\n\r\n    if (settings.regionAlpha > 0 && tile.region !== null) {\r\n        ctx.globalAlpha = settings.regionAlpha;\r\n        ctx.fillStyle = tile.region.color;\r\n        ctx.fillRect(tile.x * settings.cellSize, tile.y * settings.cellSize, settings.cellSize, settings.cellSize);\r\n        ctx.globalAlpha = 1;\r\n    }\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.globalAlpha = 0.25;\r\n    ctx.strokeStyle = '#000';\r\n\r\n    ctx.lineWidth = settings.cellSize;\r\n    for (let line of dungeon.minimumSpanningLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.cellSize * 0.5;\r\n    for (let line of dungeon.relativeNeighbourhoodLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = settings.cellSize * 0.25;\r\n    for (let line of dungeon.gabrielLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.lineWidth = 1;\r\n    for (let line of dungeon.delauneyLines) {\r\n        drawPath(line, ctx, settings);\r\n    }\r\n\r\n    ctx.globalAlpha = 1;\r\n}\r\n\r\nfunction drawCurve(\r\n    curve: Curve,\r\n    ctx: CanvasRenderingContext2D,\r\n    settings: IRenderSettings,\r\n    draw: boolean = true\r\n) {\r\n    let halfCellSize = settings.cellSize / 2;\r\n\r\n    if (curve.keyPoints.length === 1) {\r\n        if (draw) {\r\n            let cell = curve.keyPoints[0];\r\n            let cx = cell.x * settings.cellSize + halfCellSize;\r\n            let cy = cell.y * settings.cellSize + halfCellSize;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy, settings.wallWidth / 2, 0, Math.PI * 2);\r\n        \r\n            ctx.fill();\r\n        }\r\n        return;\r\n    }\r\n    \r\n    let points = curve.renderPoints;\r\n    let x = points[0] * settings.cellSize + halfCellSize;\r\n    let y = points[1] * settings.cellSize + halfCellSize;\r\n    \r\n    if (draw) {\r\n        ctx.beginPath();\r\n    }\r\n    ctx.moveTo(x, y);\r\n    \r\n    ctx.lineWidth = settings.wallWidth;\r\n    for (let i = 0; i < points.length; i += 2) {\r\n        x = points[i] * settings.cellSize + halfCellSize;\r\n        y = points[i + 1] * settings.cellSize + halfCellSize;\r\n        ctx.lineTo(x, y);\r\n    }\r\n\r\n    if (draw) {\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nfunction clipOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    for (let curve of dungeon.walls) {\r\n        drawCurve(curve, ctx, settings, false);\r\n    }\r\n    ctx.clip('evenodd');\r\n}\r\n\r\nfunction fillOutside(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.fillStyle = settings.backgroundColor;\r\n\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.fillRect(0, 0, dungeon.width * settings.cellSize, dungeon.height * settings.cellSize);\r\n    \r\n    ctx.strokeStyle = settings.hatchingColor;\r\n    ctx.lineWidth = settings.hatchingWidth;\r\n\r\n    const xScale = settings.cellSize * 0.6;\r\n    for (const point of dungeon.backdropPoints) {\r\n        const yScale = settings.cellSize * point.lengthScale;\r\n        \r\n        ctx.save();\r\n\r\n        ctx.translate(point.x * settings.cellSize, point.y * settings.cellSize);\r\n        ctx.rotate(point.rotation);\r\n\r\n        // first clear the background of this segment\r\n        ctx.beginPath();\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n        ctx.fill();\r\n\r\n        // then draw the lines\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(-xScale, -yScale - point.topSkew * settings.cellSize);\r\n        ctx.lineTo(-xScale, yScale + point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.moveTo(0, -yScale);\r\n        ctx.lineTo(0, yScale);\r\n\r\n        ctx.moveTo(xScale, -yScale + point.topSkew * settings.cellSize);\r\n        ctx.lineTo(xScale, yScale - point.bottomSkew * settings.cellSize);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction drawOutsidePoints(ctx: CanvasRenderingContext2D, dungeon: Dungeon, settings: IRenderSettings) {\r\n    ctx.save();\r\n    clipOutside(ctx, dungeon, settings);\r\n\r\n    ctx.globalAlpha = 0.75;\r\n    ctx.fillStyle = '#009';\r\n\r\n    for (const point of dungeon.backdropPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(point.x * settings.cellSize, point.y * settings.cellSize, settings.cellSize * 0.25, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    ctx.restore();\r\n}","// based on http://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/lib/alea.js\r\n\r\nexport class SRandom {\r\n    private c: number;\r\n    private s0: number;\r\n    private s1: number;\r\n    private s2: number;\r\n\r\n    constructor(public readonly seed: number | string) {\r\n        var mash = this.mash();\r\n\r\n        this.c = 1;\r\n        this.s0 = mash(' ');\r\n        this.s1 = mash(' ');\r\n        this.s2 = mash(' ');\r\n\r\n        this.s0 -= mash(seed);\r\n        if (this.s0 < 0) {\r\n            this.s0 += 1;\r\n        }\r\n\r\n        this.s1 -= mash(seed);\r\n        if (this.s1 < 0) {\r\n            this.s1 += 1;\r\n        }\r\n\r\n        this.s2 -= mash(seed);\r\n        if (this.s2 < 0) {\r\n            this.s2 += 1;\r\n        }\r\n    }\r\n\r\n    next() {\r\n        let t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        return this.s2 = t - (this.c = t | 0);\r\n    }\r\n    \r\n    nextInt32() {\r\n        return (this.next() * 0x100000000) | 0;\r\n    }\r\n\r\n    nextInRange(min: number, max: number) {\r\n        return min + this.next() * (max - min);\r\n    }\r\n\r\n    nextIntInRange(minInclusive: number, maxExclusive: number) {\r\n        return Math.floor(this.nextInRange(minInclusive, maxExclusive));\r\n    }\r\n\r\n    nextColor() {\r\n        const colorChars = ['7', '8', '9', 'a', 'b', 'c', 'd'];\r\n        const r = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const g = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        const b = colorChars[this.nextIntInRange(0, colorChars.length)];\r\n        return `#${r}${g}${b}`;\r\n    }\r\n\r\n    private mash() {\r\n        let n = 0xefc8249d;\r\n\r\n        let mash = function(data: number | string) {\r\n            data = data.toString();\r\n            for (var i = 0; i < data.length; i++) {\r\n                n += data.charCodeAt(i);\r\n                var h = 0.02519603282416938 * n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                h *= n;\r\n                n = h >>> 0;\r\n                h -= n;\r\n                n += h * 0x100000000; // 2^32\r\n            }\r\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\r\n        };\r\n\r\n        return mash;\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\nimport { Line } from '../../lib/model/Line';\r\nimport { IGraph } from '../../lib/model/Graph';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function createRegions(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // Remove all nodes, then create nodeCount nodes. Using same seed ensures same ones are recreated.\r\n    const random = new SRandom(seed);\r\n\r\n    let makeNode = () => {\r\n        const x = random.nextInRange(3, dungeon.width - 4);\r\n        const y = random.nextInRange(3, dungeon.height - 4);\r\n        const influence = random.nextInRange(0.6, 1.8);\r\n        const regionType = random.nextIntInRange(0, RegionType.NUM_VALUES);\r\n        const seed = random.next();\r\n        const color = random.nextColor();\r\n        return new Region(dungeon, x, y, seed, regionType, color, influence);\r\n    };\r\n\r\n    dungeon.nodes = [];\r\n    for (let i = 0; i < settings.nodeCount; i++) {\r\n        addSpacedNode(dungeon, makeNode, dungeon.width, dungeon.height);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n}\r\n\r\nfunction addSpacedNode<TNode extends Coord2D, TLine extends Line<TNode>>(\r\n    dungeon: IGraph<TNode, TLine>,\r\n    makeNode: () => TNode,\r\n    totWidth: number,\r\n    totHeight: number\r\n) {\r\n    const getScaledDistSq = (n1: TNode, n2: TNode, width: number, height: number) => {\r\n        let dxScaled = (n1.x - n2.x) / width;\r\n        let dyScaled = (n1.y - n2.y) / height;\r\n        return dxScaled * dxScaled + dyScaled * dyScaled;\r\n    };\r\n\r\n    // create two nodes, and go with the one that's furthest away from the nearest node\r\n    let node1 = makeNode(), node2 = makeNode();\r\n    let closestDist1 = Number.MAX_VALUE, closestDist2 = Number.MAX_VALUE;\r\n    for (let node of dungeon.nodes) {\r\n        // scale x/y distances, so width/height changes don't change which node is chosen during regeneration\r\n        closestDist1 = Math.min(closestDist1, getScaledDistSq(node1, node, totWidth, totHeight));\r\n        closestDist2 = Math.min(closestDist2, getScaledDistSq(node2, node, totWidth, totHeight));\r\n    }\r\n\r\n    dungeon.nodes.push(closestDist1 < closestDist2 ? node2 : node1);\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Polygon<TNode extends Coord<TNode>> {\r\n    constructor(readonly vertices: TNode[]) {\r\n        \r\n    }\r\n}","import { Coord } from './Coord';\r\nimport { Polygon } from './Polygon';\r\n\r\nexport class Triangle<TNode extends Coord<TNode>> extends Polygon<TNode> {\r\n    circumCenter: Coord<TNode>;\r\n    circumRadiusSq: number;\r\n\r\n    constructor(vertices: [TNode, TNode, TNode]) {\r\n        super(vertices);\r\n\r\n        let circumCircle = vertices[0].circumCircle(vertices[1], vertices[2]);\r\n\r\n        this.circumCenter = circumCircle[0];\r\n        this.circumRadiusSq = circumCircle[1];\r\n    }\r\n}","import { Coord } from '../model/Coord';\r\nimport { Triangle } from '../model/Triangle';\r\n\r\nexport function computeDelauneyTriangulation<TNode extends Coord<TNode>>(\r\n    nodes: TNode[],\r\n    superTriangle: [TNode, TNode, TNode]\r\n) {\r\n    if (nodes.length < 3) {\r\n        return [];\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm\r\n    let triangulation: Triangle<TNode>[] = [];\r\n    triangulation.push(new Triangle(superTriangle));\r\n\r\n    for (let node of nodes) {\r\n        // find all triangles that are no longer valid due to this node's insertion\r\n        let badTriangles: Triangle<TNode>[] = [];\r\n        for (let triangle of triangulation) {\r\n            if (insideCircumcircle(node, triangle)) {\r\n                badTriangles.push(triangle);\r\n            }\r\n        }\r\n\r\n        // Find the boundary of polygonal hole formed by these \"bad\" triangles...\r\n        // Get the edges of the \"bad\" triangles which don't touch other bad triangles...\r\n        // Each pair of nodes here represents a line.\r\n        let polygon: TNode[] = [];\r\n        for (let triangle of badTriangles) {\r\n            for (let i = 0; i < 3; i++) {\r\n                let edgeFrom = triangle.vertices[i];\r\n                let edgeTo = triangle.vertices[i === 2 ? 0 : i + 1];\r\n\r\n                let sharedWithOther = false;\r\n                for (let other of badTriangles) {\r\n                    if (other === triangle) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeFrom) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (other.vertices.indexOf(edgeTo) === -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    sharedWithOther = true;\r\n                    break;\r\n                }\r\n\r\n                if (!sharedWithOther) {\r\n                    polygon.push(edgeFrom, edgeTo);\r\n                }\r\n            }\r\n        }\r\n\r\n        // discard all bad triangles\r\n        for (let triangle of badTriangles) {\r\n            triangulation.splice(triangulation.indexOf(triangle), 1);\r\n        }\r\n\r\n        // re-triangulate the polygonal hole ... create a new triangle for each edge\r\n        for (let i = 0; i < polygon.length - 1; i += 2) {\r\n            let triangle = new Triangle<TNode>([polygon[i], polygon[i + 1], node]);\r\n            triangulation.push(triangle);\r\n        }\r\n    }\r\n\r\n    // remove all triangles that contain a vertex from the original super-triangle\r\n    for (let i = 0; i < triangulation.length; i++) {\r\n        let triangle = triangulation[i];\r\n        for (let vertex of triangle.vertices) {\r\n            if (superTriangle.indexOf(vertex) !== -1) {\r\n                triangulation.splice(i, 1);\r\n                i--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return triangulation;\r\n}\r\n\r\nfunction insideCircumcircle<TNode extends Coord<TNode>>(\r\n    point: TNode,\r\n    triangle: Triangle<TNode>\r\n) {\r\n    let distSq = point.distanceSqTo(triangle.circumCenter);\r\n    return distSq <= triangle.circumRadiusSq;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeGabrielGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n\r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let center = link.from.halfwayTo(link.to);\r\n        let radiusSq = link.from.distanceSqTo(center);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(center) < radiusSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}","import { Coord } from '../model/Coord';\r\nimport { Line } from '../model/Line';\r\nimport { Polygon } from '../model/Polygon';\r\n\r\nexport function getUniqueLines<TNode extends Coord<TNode>, TLine extends Line<TNode>>\r\n(\r\n    polygons: Polygon<TNode>[], \r\n    createLine: (from: TNode, to: TNode) => TLine\r\n) {\r\n    const allLines: TLine[] = [];\r\n\r\n    // Convert polygons to UNIQUE lines, ignoring their direction.\r\n    for (const polygon of polygons) {\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            const v0 = polygon.vertices[i === 0 ? polygon.vertices.length - 1 : i - 1];\r\n            const v1 = polygon.vertices[i];\r\n\r\n            const isDuplicate = allLines.some(l => (l.from === v0 && l.to === v1) || (l.from === v1 && l.to === v0));\r\n            if (!isDuplicate) {\r\n                allLines.push(createLine(v0, v1));\r\n            }\r\n        }\r\n    }\r\n\r\n    return allLines;\r\n}","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeMinimumSpanningTree<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>,\r\n    links: TLine[] = graph.lines\r\n) {\r\n    let unvisitedNodes = graph.nodes.slice();\r\n    let firstNode = unvisitedNodes.pop();\r\n    if (firstNode === undefined) {\r\n        return [];\r\n    }\r\n    \r\n    let possibleLinks = links.map(l => ({ link: l, lengthSq: l.from.distanceSqTo(l.to) }));\r\n    possibleLinks.sort((a, b) => a.lengthSq - b.lengthSq);\r\n\r\n    let visitedNodes: TNode[] = [firstNode];\r\n    let graphLinks: TLine[] = [];\r\n\r\n    while (unvisitedNodes.length > 0 && possibleLinks.length > 0) {\r\n        // Find the first link that connects to a node in visitedNodes...\r\n        // The links are sorted by length, so the first one will be the shortest one.\r\n        for (let i = 0; i < possibleLinks.length; i++) {\r\n            let testLink = possibleLinks[i].link;\r\n            \r\n            let alreadyHasFrom = visitedNodes.indexOf(testLink.from) !== -1;\r\n            let alreadyHasTo = visitedNodes.indexOf(testLink.to) !== -1;\r\n\r\n            // if it doesn't connect to the graph at all, discard it\r\n            if (!alreadyHasFrom && !alreadyHasTo) {\r\n                continue;\r\n            }\r\n\r\n            possibleLinks.splice(i, 1);\r\n            graphLinks.push(testLink);\r\n\r\n            let addingNode = alreadyHasFrom ? testLink.to : testLink.from;\r\n            \r\n            // remove all other links from possibleLinks that connect addingNode to visitedNodes\r\n            for (let j = i; j < possibleLinks.length; j++) {\r\n                testLink = possibleLinks[j].link;\r\n                if ((testLink.from === addingNode && visitedNodes.indexOf(testLink.to) !== -1)\r\n                || (testLink.to === addingNode && visitedNodes.indexOf(testLink.from) !== -1)) {\r\n                    possibleLinks.splice(j, 1);\r\n                    j--;\r\n                }\r\n            }\r\n\r\n            visitedNodes.push(addingNode);\r\n            break;\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Coord } from '../model/Coord';\r\nimport { IGraph } from '../model/Graph';\r\nimport { Line } from '../model/Line';\r\n\r\nexport function computeRelativeNeighbourhoodGraph<TNode extends Coord<TNode>, TLine extends Line<TNode>>(\r\n    graph: IGraph<TNode, TLine>, \r\n    links: TLine[] = graph.lines\r\n) {\r\n    let graphLinks: TLine[] = [];\r\n    \r\n    for (let link of links) {\r\n        let anyBlocking = false;\r\n        let lengthSq = link.from.distanceSqTo(link.to);\r\n\r\n        for (let node of graph.nodes) {\r\n            if (node === link.from || node === link.to) {\r\n                continue;\r\n            }\r\n\r\n            if (node.distanceSqTo(link.from) < lengthSq && node.distanceSqTo(link.to) < lengthSq) {\r\n                anyBlocking = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!anyBlocking) {\r\n            graphLinks.push(link);\r\n        }\r\n    }\r\n\r\n    return graphLinks;\r\n}\r\n","import { Line } from '../../lib/model/Line';\r\nimport { Region } from './Region';\r\n\r\nexport class Pathway extends Line<Region> {\r\n    constructor(from: Region, to: Region) {\r\n        super(from, to);\r\n\r\n        from.links.push(this);\r\n        to.links.push(this);\r\n    }\r\n}","import { Coord } from './Coord';\r\n\r\nexport class Line<TCoord extends Coord<TCoord>> {\r\n    constructor(public from: TCoord, public to: TCoord) {\r\n\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { Region, RegionType } from '../model/Region';\r\nimport {\r\n    computeDelauneyTriangulation,\r\n    getUniqueLines,\r\n    computeGabrielGraph,\r\n    computeRelativeNeighbourhoodGraph,\r\n    computeMinimumSpanningTree\r\n} from '../../lib/graph';\r\nimport { Pathway } from '../model/Pathway';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function populateLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.lines = [];\r\n    dungeon.delauneyLines = [];\r\n    dungeon.gabrielLines = [];\r\n    dungeon.relativeNeighbourhoodLines = [];\r\n    dungeon.minimumSpanningLines = [];\r\n\r\n    const enclosingTriangle: [Region, Region, Region] = [\r\n        new Region(dungeon, 0, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 999999, 0, 0, RegionType.Artificial, ''),\r\n        new Region(dungeon, 0, 999999, 0, RegionType.Artificial, ''),\r\n    ];\r\n\r\n    const delauneyTriangles = computeDelauneyTriangulation(dungeon.nodes, enclosingTriangle);\r\n    \r\n    dungeon.delauneyLines = getUniqueLines(delauneyTriangles, (from, to) => new Pathway(from, to));\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.gabrielLines = computeGabrielGraph(dungeon, dungeon.delauneyLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.relativeNeighbourhoodLines = computeRelativeNeighbourhoodGraph(dungeon, dungeon.gabrielLines);\r\n\r\n    if (subStepComplete) {\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    dungeon.minimumSpanningLines = computeMinimumSpanningTree(dungeon, dungeon.relativeNeighbourhoodLines);\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Pathway } from '../model/Pathway';\r\n\r\nexport async function filterLinks(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let selectingFrom: Pathway[];\r\n    let selectFraction: number;\r\n        \r\n    if (settings.connectivity < 50) {\r\n        dungeon.lines = dungeon.minimumSpanningLines.slice();\r\n\r\n        selectingFrom = dungeon.relativeNeighbourhoodLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = settings.connectivity / 50;\r\n    } else {\r\n        dungeon.lines = dungeon.relativeNeighbourhoodLines.slice();\r\n\r\n        selectingFrom = dungeon.gabrielLines.filter(l => dungeon.lines.indexOf(l) === -1);\r\n\r\n        selectFraction = (settings.connectivity - 50) / 50;\r\n    }\r\n    \r\n    let random = new SRandom(seed);\r\n    let numToSelect = Math.round(selectingFrom.length * selectFraction);\r\n\r\n    for (let i = numToSelect; i > 0; i--) {\r\n        let selectedLink = selectingFrom.splice(random.nextIntInRange(0, selectingFrom.length), 1)[0];\r\n        dungeon.lines.push(selectedLink);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function populateCaveRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    \r\n    const regionTiles = dungeon.tiles.filter(t => t.region === region);\r\n    const nonEdgeTiles = regionTiles.filter(t => t.adjacentTiles.length === 8 && !t.adjacentTiles.some(a => a.region !== region));\r\n    \r\n    const mutableTiles = nonEdgeTiles.filter(t => !t.isFloor);\r\n\r\n    // make half the non-edge cells \"alive\"\r\n    for (const tile of nonEdgeTiles) {\r\n        if (random.next() < 0.5) {\r\n            tile.isFloor = true;\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < 8; i++) {\r\n        runCellularAutomataStep(mutableTiles);\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Small);\r\n        }\r\n    }\r\n\r\n    removeUnconnectedFloorTiles(dungeon, region, nonEdgeTiles);\r\n}\r\n\r\nfunction runCellularAutomataStep(cells: Tile[]) {\r\n    const results = new Map<Tile, boolean>();\r\n\r\n    for (const cell of cells) {\r\n        // alive becomes dead if < 4 alive around it\r\n        // dead becomes alive if > 4 alive around it\r\n\r\n        const wasAlive = cell.isFloor;\r\n        const numAdjacentLiving = cell.adjacentTiles.filter(t => t.isFloor).length;\r\n\r\n        const shouldLive = wasAlive\r\n            ? numAdjacentLiving >= 4\r\n            : numAdjacentLiving > 4\r\n\r\n        results.set(cell, shouldLive);\r\n    }\r\n\r\n    for (const [cell, result] of results) {\r\n        cell.isFloor = result;\r\n    }\r\n}\r\n\r\nfunction removeUnconnectedFloorTiles(dungeon: Dungeon, region: Region, regionTiles: Tile[]) {    \r\n    const rootTile = dungeon.tilesByCoordinates[Math.floor(region.x)][Math.floor(region.y)];\r\n    \r\n    const connectedTiles = new Set([rootTile]);\r\n    let tilesToTest = [...rootTile.adjacentTiles];\r\n\r\n    while (true) {\r\n        const tile = tilesToTest.pop();\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        if (!tile.isFloor || tile.region !== region || connectedTiles.has(tile)) {\r\n            continue;\r\n        }\r\n\r\n        connectedTiles.add(tile);\r\n\r\n        tilesToTest = [\r\n            ...tilesToTest,\r\n            ...tile.adjacentTiles,\r\n        ];\r\n    }\r\n\r\n    for (const tile of regionTiles) {\r\n        if (tile.isFloor && !connectedTiles.has(tile)) {\r\n            tile.isFloor = false;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { SRandom } from '../../lib/SRandom';\r\nimport { Region } from '../model/Region';\r\n\r\nexport async function populateRoomRegion(\r\n    dungeon: Dungeon,\r\n    region: Region,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const random = new SRandom(region.seed);\r\n    const nodeX = Math.floor(region.x);\r\n    const nodeY = Math.floor(region.y);\r\n\r\n    const { minX, minY, maxX, maxY } = determineBounds(dungeon, region, nodeX, nodeY, random);\r\n\r\n    for (let x = minX; x <= maxX; x++) {\r\n        for (let y = minY; y <= maxY; y++) {\r\n            let tile = dungeon.tilesByCoordinates[x][y];\r\n            if (tile.region !== region) {\r\n                continue;\r\n            }\r\n\r\n            tile.isFloor = true;\r\n            tile.region = region;\r\n        }\r\n    }\r\n}\r\n\r\nfunction determineBounds(dungeon: Dungeon, region: Region, nodeX: number, nodeY: number, random: SRandom) {\r\n    // determine the biggest possible size this room could be\r\n    let minX = nodeX, maxX = nodeX, minY = nodeY, maxY = nodeY;\r\n\r\n    if (random.next() < 0.5) {\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n    else {\r\n        [maxX, maxY] = growDownRight(dungeon, region, random, minX, minY, maxX, maxY);\r\n        [minX, minY] = growUpLeft(dungeon, region, random, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    // now possibly shrink from the maximum possible size\r\n    if (random.next() < 0.75) {\r\n        minX = random.nextIntInRange(minX, nodeX);\r\n        maxX = random.nextIntInRange(nodeX + 1, maxX + 1);\r\n        minY = random.nextIntInRange(minY, nodeY);\r\n        maxY = random.nextIntInRange(nodeY + 1, maxY + 1);    \r\n    }\r\n\r\n    return {\r\n        minX,\r\n        minY,\r\n        maxX,\r\n        maxY,\r\n    };\r\n}\r\n\r\nfunction growUpLeft(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canLeft = true, canUp = true;\r\n\r\n    while (canLeft || canUp) {\r\n        if (canUp && random.next() < 0.5) {\r\n            canUp = isRowInRegion(dungeon, region, minY - 1, minX, maxX)\r\n                && --minY > 2;\r\n        }\r\n        else if (canLeft) {\r\n            canLeft = isColInRegion(dungeon, region, minX - 1, minY, maxY)\r\n                && --minX > 2;\r\n        }\r\n    }\r\n\r\n    return [minX, minY];\r\n}\r\n\r\n\r\nfunction growDownRight(dungeon: Dungeon, region: Region, random: SRandom, minX: number, minY: number, maxX: number, maxY: number) {\r\n    let canRight = true, canDown = true;\r\n\r\n    while (canRight || canDown) {\r\n        if (canDown && random.next() < 0.5) {\r\n            canDown = isRowInRegion(dungeon, region, maxY + 1, minX, maxX)\r\n                && ++maxY < dungeon.height - 3;\r\n        }\r\n        else if (canRight) {\r\n            canRight = isColInRegion(dungeon, region, maxX + 1, minY, maxY)\r\n                && ++maxX < dungeon.width - 3;\r\n        }\r\n    }\r\n\r\n    return [maxX, maxY];\r\n}\r\n\r\nfunction isColInRegion(dungeon: Dungeon, region: Region, x: number, y1: number, y2: number) {\r\n    const col = dungeon.tilesByCoordinates[x];\r\n\r\n    for (let y = y1; y <= y2; y++) {\r\n        if (col[y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction isRowInRegion(dungeon: Dungeon, region: Region, y: number, x1: number, x2: number) {\r\n    for (let x = x1; x <= x2; x++) {\r\n        if (dungeon.tilesByCoordinates[x][y].region !== region) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { RegionType } from '../model/Region';\r\nimport { populateCaveRegion } from './populateCaveRegion';\r\nimport { populateRoomRegion } from './populateRoomRegion';\r\n\r\nexport async function createRooms(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    for (const region of dungeon.nodes) {\r\n        switch (region.regionType) {\r\n            case RegionType.Natural:\r\n                await populateCaveRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            case RegionType.Artificial:\r\n                await populateRoomRegion(dungeon, region, subStepComplete);\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        \r\n        if (subStepComplete) {\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function linkLinesToGrid(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    // associate each tile of the grid with all of the links that overlap or touch it\r\n    // this is Xiaolin Wi's algorithm, without the antialiasing.\r\n    for (let link of dungeon.lines) {\r\n        let x0 = Math.floor(link.from.x);\r\n        let x1 = Math.floor(link.to.x);\r\n        let y0 = Math.floor(link.from.y);\r\n        let y1 = Math.floor(link.to.y);\r\n\r\n        const col0 = dungeon.tilesByCoordinates[x0];\r\n        if (col0 !== undefined) {\r\n            const cell0 = col0[y0];\r\n            if (cell0 !== undefined) {\r\n                cell0.isFloor = true;\r\n            }\r\n        }\r\n        \r\n        const col1 = dungeon.tilesByCoordinates[x1];\r\n        if (col1 !== undefined) {\r\n            const cell1 = col1[y1];\r\n            if (cell1 !== undefined) {\r\n                cell1.isFloor = true;\r\n            }\r\n        }\r\n\r\n        let steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n        if (steep) { // swap x & y, ensure not steep\r\n            let tmp = y0;\r\n            y0 = x0;\r\n            x0 = tmp;\r\n            \r\n            tmp = y1;\r\n            y1 = x1;\r\n            x1 = tmp;\r\n        }\r\n        if (x0 > x1) { // swap 0 & 1, ensure moving rightwards\r\n            let tmp = x1;\r\n            x1 = x0;\r\n            x0 = tmp;\r\n            \r\n            tmp = y1;\r\n            y1 = y0;\r\n            y0 = tmp;\r\n        }\r\n        \r\n        let gradient = (y1 - y0) / (x1 - x0);\r\n        let y = y0 + gradient * 0.5; // move to the \"middle\" of the cell\r\n        \r\n        for (let x = x0; x < x1; x++) {\r\n            let iY = Math.round(y - 0.5); // round to the nearest i+0.5, then truncate to int\r\n            let closestSideStep = iY + 0.5 > y ? -1 : 1;\r\n            let almostInteger = Math.abs(y - iY) < 0.10;\r\n            \r\n            if (steep) {\r\n                dungeon.tilesByCoordinates[iY + closestSideStep][x].isFloor = true;\r\n                dungeon.tilesByCoordinates[iY][x].isFloor = true;\r\n                if (!almostInteger) {\r\n                    dungeon.tilesByCoordinates[iY - closestSideStep][x].isFloor = true;\r\n                }\r\n            } else {\r\n                dungeon.tilesByCoordinates[x][iY + closestSideStep].isFloor = true;\r\n                dungeon.tilesByCoordinates[x][iY].isFloor = true;\r\n                if (!almostInteger) {\r\n                    dungeon.tilesByCoordinates[x][iY - closestSideStep].isFloor = true;\r\n                }\r\n            }\r\n            \r\n            y += gradient;\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { RegionType } from '../model/Region';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function detectWalls(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isFloor) {\r\n            continue;\r\n        }\r\n\r\n        let toTest = getAdjacent(dungeon, tile, true, false);\r\n        for (let test of toTest) {\r\n            if (test.isFloor) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // artificial rooms should have \"corner\" wall nodes filled in\r\n        for (let test of tile.adjacentTiles) {\r\n            if (test.isFloor && test.region !== null && test.region.regionType === RegionType.Artificial) {\r\n                tile.isWall = true;\r\n                tile.region = test.region;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Tiny);\r\n        }\r\n    }\r\n}\r\n\r\nexport function getAdjacent(dungeon: Dungeon, from: Tile, orthogonal: boolean = true, diagonal: boolean = false) {\r\n    let results = [];\r\n\r\n    if (orthogonal) {\r\n        if (from.x > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x - 1][from.y]);\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x + 1][from.y]);\r\n        }\r\n        if (from.y > 0) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y - 1]);\r\n        }\r\n        if (from.y < dungeon.height - 1) {\r\n            results.push(dungeon.tilesByCoordinates[from.x][from.y + 1]);\r\n        }\r\n    }\r\n    \r\n    if (diagonal) {\r\n        if (from.x > 0) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x - 1][from.y + 1]);\r\n            }\r\n        }\r\n        if (from.x < dungeon.width - 1) {\r\n            if (from.y > 0) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y - 1]);\r\n            }\r\n            if (from.y < dungeon.height - 1) {\r\n                results.push(dungeon.tilesByCoordinates[from.x + 1][from.y + 1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n","import { Coord2D } from './Coord';\r\n\r\nexport class Curve {\r\n    static readonly stepsPerSegment = 16;\r\n\r\n    keyPoints: Coord2D[];\r\n    isLoop: boolean;\r\n    renderPoints: number[];\r\n\r\n    constructor(public curvature: number = 0.75) {\r\n        this.keyPoints = [];\r\n        this.isLoop = false;\r\n        this.renderPoints = [];\r\n    }\r\n\r\n    updateRenderPoints() {\r\n        this.renderPoints = [];\r\n\r\n        if (this.keyPoints.length < 2) {\r\n            return;\r\n        }\r\n\r\n        let tension = this.curvature;\r\n        let pts: number[] = [],\r\n            x: number, y: number,\r\n            t1x: number, t2x: number, t1y: number, t2y: number,\r\n            c1: number, c2: number, c3: number, c4: number,\r\n            fraction: number, step: number, iPt: number;\r\n\r\n        let firstCell = this.keyPoints[0];\r\n        let lastCell = this.keyPoints[this.keyPoints.length - 1];\r\n\r\n        // decide if it's a closed loop, which needs the ends of the array set up differently\r\n        let lastCellIndex: number;\r\n        if (firstCell === lastCell) {\r\n            lastCellIndex = this.keyPoints.length - 2; // don't copy the last cell, its the same as the first\r\n            lastCell = this.keyPoints[lastCellIndex];\r\n        } else {\r\n            lastCellIndex = this.keyPoints.length - 1;\r\n        }\r\n        \r\n        for (let cell of this.keyPoints) {\r\n            pts.push(cell.x, cell.y);\r\n        }\r\n        \r\n        if (this.isLoop) {\r\n            // copy last cell onto start, and first cells onto end\r\n            let secondCell = this.keyPoints[1];\r\n            pts.push(firstCell.x, firstCell.y);\r\n            pts.push(secondCell.x, secondCell.y);\r\n            pts.unshift(lastCell.x, lastCell.y);\r\n        } else {\r\n            // copy first cell onto start, and last cell onto end\r\n            pts.unshift(firstCell.x, firstCell.y);\r\n            pts.push(lastCell.x, lastCell.y);\r\n        }\r\n\r\n        // loop through key points. Use each set of 4 points p0 p1 p2 p3 to draw segment p1-p2.\r\n        for (iPt = 2; iPt < (pts.length - 4); iPt += 2) {\r\n            for (step = 0; step <= Curve.stepsPerSegment; step++) {\r\n                // tension vectors\r\n                t1x = (pts[iPt + 2] - pts[iPt - 2]) * tension;\r\n                t2x = (pts[iPt + 4] - pts[iPt]) * tension;\r\n\r\n                t1y = (pts[iPt + 3] - pts[iPt - 1]) * tension;\r\n                t2y = (pts[iPt + 5] - pts[iPt + 1]) * tension;\r\n\r\n                fraction = step / Curve.stepsPerSegment;\r\n\r\n                // cardinals\r\n                c1 =   2 * Math.pow(fraction, 3)  - 3 * Math.pow(fraction, 2) + 1; \r\n                c2 = -(2 * Math.pow(fraction, 3)) + 3 * Math.pow(fraction, 2); \r\n                c3 =       Math.pow(fraction, 3)  - 2 * Math.pow(fraction, 2) + fraction; \r\n                c4 =       Math.pow(fraction, 3)  -     Math.pow(fraction, 2);\r\n\r\n                // x and y coordinates\r\n                x = c1 * pts[iPt]    + c2 * pts[iPt + 2] + c3 * t1x + c4 * t2x;\r\n                y = c1 * pts[iPt + 1]  + c2 * pts[iPt + 3] + c3 * t1y + c4 * t2y;\r\n                this.renderPoints.push(x);\r\n                this.renderPoints.push(y);\r\n            }\r\n        }\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { Tile } from '../model/Tile';\r\nimport { Curve } from '../../lib/model/Curve';\r\nimport { getAdjacent } from './detectWalls';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\n\r\nexport async function generateWallCurves(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.walls = [];\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        if (tile.isWall && !tile.isFloor) {\r\n            await generateWallCurve(dungeon, tile, true, subStepComplete);\r\n\r\n            if (subStepComplete) {\r\n                await subStepComplete(DelaySize.Medium);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const curve of dungeon.walls) {\r\n        curve.updateRenderPoints();\r\n    }\r\n}\r\n\r\nasync function generateWallCurve(dungeon: Dungeon, firstTile: Tile, isRootLevel: boolean, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const mainCurve = await generateSingleWallCurve(dungeon, firstTile, subStepComplete);\r\n\r\n    while (true) {\r\n        // See if we could have taken a different path at any point.\r\n        const newStartPoint = backtrackToNewStartPoint(dungeon, mainCurve);\r\n        if (newStartPoint === undefined) {\r\n            if (isRootLevel) {\r\n                checkForCurveLoops(dungeon, mainCurve);\r\n            }\r\n\r\n            if (subStepComplete !== undefined) {\r\n                mainCurve.updateRenderPoints();\r\n            }\r\n            return mainCurve;\r\n        }\r\n\r\n        // See if the different path is longer.\r\n        const branchIndex = mainCurve.keyPoints.indexOf(newStartPoint);\r\n        \r\n        const newCurve = await generateWallCurve(dungeon, newStartPoint, false, subStepComplete);\r\n\r\n        if (newCurve.keyPoints.length <= mainCurve.keyPoints.length - branchIndex || newStartPoint === firstTile) {\r\n            continue;\r\n        }\r\n\r\n        // Swap the paths around so that this path is as long as possible.\r\n\r\n        let newBranch = newCurve.keyPoints.slice(1);\r\n        let oldBranch = mainCurve.keyPoints.splice(branchIndex + 1);\r\n        oldBranch.unshift(newStartPoint);\r\n\r\n        newCurve.keyPoints = oldBranch;\r\n        mainCurve.keyPoints = mainCurve.keyPoints.concat(newBranch);\r\n        \r\n        if (isRootLevel) {\r\n            checkForCurveLoops(dungeon, newCurve);\r\n        }\r\n\r\n        if (subStepComplete !== undefined) {\r\n            newCurve.updateRenderPoints();\r\n            mainCurve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Medium);\r\n        }\r\n    }\r\n}\r\n\r\nfunction backtrackToNewStartPoint(dungeon: Dungeon, curve: Curve) {\r\n    // iterate backwards round this curve, trying to find somewhere to branch off a new curve from\r\n    for (let i = curve.keyPoints.length - 1; i >= 0; i--) {\r\n        let curveTile = curve.keyPoints[i] as Tile;\r\n\r\n        let viableTile = pickBestAdjacentWallTile(dungeon, curveTile, true, true, t => !t.isFloor && t.isWall);\r\n        if (viableTile !== undefined) {\r\n            return curveTile;\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction checkForCurveLoops(dungeon: Dungeon, mainCurve: Curve, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    // detect simple loops, as well as \"p\" and \"b\" loops that need split into two parts\r\n    const firstPoint = mainCurve.keyPoints[0];\r\n    const lastPoint = mainCurve.keyPoints[mainCurve.keyPoints.length - 1];\r\n    \r\n    if (firstPoint === lastPoint) {\r\n        mainCurve.isLoop = true;\r\n    } else {\r\n        let splitPos = mainCurve.keyPoints.lastIndexOf(firstPoint);\r\n        if (splitPos > 0) {\r\n            // p shape, loop at the start\r\n            const splitCurve = new Curve();\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(splitPos + 1);\r\n            splitCurve.keyPoints.unshift(mainCurve.keyPoints[splitPos]);\r\n\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n            \r\n            mainCurve.isLoop = true;\r\n            // console.log('found a P, splitting linear end bit into its own curve');\r\n        }\r\n        \r\n        splitPos = mainCurve.keyPoints.indexOf(lastPoint);\r\n        if (splitPos < mainCurve.keyPoints.length - 1) {\r\n            // b shape, loop at the end\r\n            /*\r\n            console.log(`loop found in curve ${dungeon.walls.indexOf(mainCurve)} at index ${splitPos} ... 0-${splitPos} will separate off linearly, keeping from ${splitPos}-${mainCurve.keyPoints.length - 1} as a loop`);\r\n            console.log(`index ${0} is ${mainCurve.keyPoints[0].x}, ${mainCurve.keyPoints[0].y}`);\r\n            console.log(`index ${splitPos} is ${mainCurve.keyPoints[splitPos].x}, ${mainCurve.keyPoints[splitPos].y}`);\r\n            console.log(`index ${mainCurve.keyPoints.length - 1} is ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].x}, ${mainCurve.keyPoints[mainCurve.keyPoints.length - 1].y}`);\r\n            */\r\n            const splitCurve = new Curve();\r\n            const splitPoint = mainCurve.keyPoints[splitPos];\r\n            splitCurve.keyPoints = mainCurve.keyPoints.splice(0, splitPos - 1);\r\n            splitCurve.keyPoints.push(splitPoint);\r\n            if (subStepComplete) {\r\n                splitCurve.updateRenderPoints();\r\n            }\r\n            dungeon.walls.push(splitCurve);\r\n\r\n            mainCurve.isLoop = true;\r\n            // console.log('found a B, splitting linear start bit into its own curve');\r\n\r\n            /*\r\n            console.log(`after splitting, main curve is ${mainCurve.keyPoints.length} long`);\r\n            console.log(`split curve is ${splitCurve.keyPoints.length} long`);\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\nexport async function generateSingleWallCurve(dungeon: Dungeon, firstTile: Tile, subStepComplete?: (interval: DelaySize) => Promise<void>) {\r\n    const curve = new Curve();\r\n    dungeon.walls.push(curve);\r\n\r\n    let prevTile: Tile | undefined = firstTile;\r\n\r\n    // If there's an adjacent tile that's already part of a wall curve, start from that instead.\r\n    const actualFirstTile = getAdjacent(dungeon, firstTile, true, true)\r\n        .find(t => t.isWall && t.isFloor);\r\n    if (actualFirstTile !== undefined) {\r\n        curve.keyPoints.push(actualFirstTile);\r\n        firstTile = actualFirstTile;\r\n    }\r\n\r\n    curve.keyPoints.push(prevTile);\r\n    prevTile.isFloor = true;\r\n\r\n    do {\r\n        // Pick next tile, keep looping. When there isn't a next one, stop. Initially, only look orthogonally.\r\n        let tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n            dungeon,\r\n            prevTile,\r\n            t => !t.isFloor && t.isWall\r\n        );\r\n\r\n        if (tile === undefined) {\r\n            // Do the same check again, but don't ignore tiles that are part of walls. This will be the last one.\r\n            const lastTile = curve.keyPoints.length > 2\r\n                ? curve.keyPoints[curve.keyPoints.length - 2]\r\n                : undefined;\r\n\r\n            tile = pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n                dungeon,\r\n                prevTile,\r\n                t => t.isWall && t !== lastTile\r\n            );\r\n            prevTile = undefined;\r\n        }\r\n        else {\r\n            prevTile = tile;\r\n        }\r\n\r\n        if (tile === firstTile) {\r\n            curve.isLoop = true;\r\n            break;\r\n        }\r\n\r\n        if (tile === undefined) {\r\n            break;\r\n        }\r\n\r\n        curve.keyPoints.push(tile);\r\n\r\n        if (tile.isFloor) {\r\n            break; // intersected a(nother) curve, so end this one\r\n        }\r\n\r\n        tile.isFloor = true;\r\n        \r\n        if (subStepComplete) {\r\n            curve.updateRenderPoints();\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n\r\n    } while (prevTile !== undefined)\r\n\r\n    if (subStepComplete) {\r\n        curve.updateRenderPoints();\r\n        await subStepComplete(DelaySize.Medium);\r\n    }\r\n\r\n    return curve;\r\n}\r\n\r\nexport function pickBestAdjacentWallTileOrthogonalThenDiagonal(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    const ortho = pickBestAdjacentWallTile(dungeon, from, true, false, filter);\r\n    return ortho !== undefined\r\n        ? ortho\r\n        : pickBestAdjacentWallTile(dungeon, from, false, true, filter);\r\n}\r\n\r\nfunction pickBestAdjacentWallTile(\r\n    dungeon: Dungeon,\r\n    from: Tile,\r\n    orthogonal: boolean,\r\n    diagonal: boolean,\r\n    filter: (tile: Tile) => boolean\r\n) {\r\n    let bestTile: Tile | undefined;\r\n    let bestNumAdjacentNonWallTiles = 0;\r\n\r\n    let toTest = getAdjacent(dungeon, from, orthogonal, diagonal);\r\n    for (let tile of toTest) {\r\n        if (!filter(tile)) {\r\n            continue;\r\n        }\r\n\r\n        let numAdjacentNonWallTiles = 0;\r\n        let allAdjacent = getAdjacent(dungeon, tile, true, true);\r\n\r\n        for (let adjacent of allAdjacent) {\r\n            if (!adjacent.isWall) {\r\n                numAdjacentNonWallTiles++;\r\n            }\r\n        }\r\n\r\n        if (numAdjacentNonWallTiles > bestNumAdjacentNonWallTiles) {\r\n            bestNumAdjacentNonWallTiles = numAdjacentNonWallTiles;\r\n            bestTile = tile;\r\n        }\r\n    }\r\n    \r\n    return bestTile;\r\n}","import { Coord } from '../model/Coord';\r\n\r\nexport function getClosest<TNode extends Coord<TNode>>(\r\n    point: Coord<TNode>,\r\n    nodes: TNode[],\r\n    getDistance: (node: TNode, point: Coord<TNode>) => number = (node, point) => point.distanceSqTo(node),\r\n) {\r\n    let bestDist = Number.MAX_VALUE;\r\n    let bestNode: TNode | null = null;\r\n\r\n    for (const node of nodes) {\r\n        const dist = getDistance(node, point);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestNode = node;\r\n        }\r\n    }\r\n\r\n    return bestNode;\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { getClosest } from '../../lib/graph/getClosest';\r\nimport { Region } from '../model/Region';\r\nimport { Coord } from '../../lib/model/Coord';\r\n\r\nexport async function associateTilesWithNodes(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    let iCol = 0;\r\n\r\n    const distance = (room: Region, point: Coord<Region>) => point.distanceSqTo(room) / room.regionInfluence;\r\n\r\n    for (const tile of dungeon.tiles) {\r\n        tile.region = getClosest(tile, dungeon.nodes, distance);\r\n\r\n        if (subStepComplete && ++iCol >= dungeon.height) {\r\n            iCol = 0;\r\n            await subStepComplete(DelaySize.Minimal);\r\n        }\r\n    }\r\n}","import { Coord2D } from '../../lib/model/Coord';\r\nimport { SRandom } from '../../lib/SRandom';\r\n\r\nexport class Hatching extends Coord2D {\r\n    public readonly rotation: number;\r\n    public readonly lengthScale: number;\r\n    public readonly topSkew: number;\r\n    public readonly bottomSkew: number;\r\n\r\n    constructor(x: number, y: number, seed?: number) {\r\n        if (seed === undefined) {\r\n            super(x + 0.5, y + 0.5);\r\n            this.rotation = 0;\r\n            this.lengthScale = 1;\r\n            this.topSkew = 0;\r\n            this.bottomSkew = 0;\r\n            return;\r\n        }\r\n\r\n        const random = new SRandom(seed + x * x * 4987142 + x * 5947611 + y * y * 4392871 + y * 389711);\r\n\r\n        super(x + random.nextInRange(0.1, 0.9), y + random.nextInRange(0.1, 0.9));\r\n\r\n        this.rotation = random.nextInRange(0, Math.PI * 2);\r\n        this.lengthScale = random.nextInRange(0.9, 1.35);\r\n        this.topSkew = random.nextInRange(0, 0.25);\r\n        this.bottomSkew = random.nextInRange(0, 0.25);\r\n    }\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\nimport { Hatching } from '../model/Hatching';\r\n\r\nexport async function fillBackdrop(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    const wallTiles = dungeon.tiles.filter(t => t.isWall);\r\n\r\n    const backdropTiles = new Set<Tile>();\r\n    addAdjacentNonFloorTiles(wallTiles, backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n    addAdjacentNonFloorTiles([...backdropTiles], backdropTiles);\r\n\r\n    dungeon.backdropPoints = [...backdropTiles]\r\n        .filter(tile => (tile.x + tile.y) % 2 !== 0)\r\n        .map(tile => new Hatching(tile.x, tile.y, seed));\r\n}\r\n\r\nfunction addAdjacentNonFloorTiles(wallTiles: Tile[], backdropTiles: Set<Tile>) {\r\n    for (const tile of wallTiles) {\r\n        for (const adjacent of tile.adjacentTiles) {\r\n            if (!adjacent.isFloor) {\r\n                backdropTiles.add(adjacent);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Region } from './Region';\r\nimport { Coord2D } from '../../lib/model/Coord';\r\n\r\nexport class Tile extends Coord2D {\r\n    public region: Region | null = null;\r\n    public readonly adjacentTiles: Tile[] = [];\r\n\r\n    constructor(x: number, y: number, public isFloor: boolean = false, public isWall: boolean = false) {\r\n        super(x, y);\r\n    }\r\n}","import { Dungeon } from './model/Dungeon';\r\nimport { GenerationSteps } from './GenerationSteps';\r\nimport { SRandom } from '../lib/SRandom';\r\nimport { createRegions } from './generation/createRegions';\r\nimport { populateLinks } from './generation/populateLinks';\r\nimport { filterLinks } from './generation/filterLinks';\r\nimport { createRooms } from './generation/createRooms';\r\nimport { linkLinesToGrid } from './generation/linkLinesToGrid';\r\nimport { detectWalls } from './generation/detectWalls';\r\nimport { generateWallCurves } from './generation/generateWallCurves';\r\nimport { IGenerationSettings } from './IGenerationSettings';\r\nimport { associateTilesWithNodes } from './generation/associateTilesWithNodes';\r\nimport { fillBackdrop } from './generation/fillBackdrop';\r\nimport { createTiles } from './generation/createTiles';\r\n\r\nexport enum DelaySize {\r\n    None = 0,\r\n    Minimal = 10,\r\n    Tiny = 50,\r\n    Small = 100,\r\n    Medium = 500,\r\n    Large = 1500,\r\n}\r\n\r\ntype GenerationStep = (\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepReached?: (interval: DelaySize) => Promise<void>\r\n) => Promise<void>;\r\n\r\nexport async function generateDungeon(\r\n    settings: IGenerationSettings,\r\n) {\r\n    const dungeon = new Dungeon();\r\n    await regenerateDungeon(dungeon, settings);\r\n    return dungeon;\r\n}\r\n\r\nexport async function regenerateDungeon(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n) {\r\n    dungeon.width = settings.cellsWide;\r\n    dungeon.height = settings.cellsHigh;\r\n\r\n    const seedGenerator = new SRandom(settings.seed);\r\n    \r\n    const steps: Array<[GenerationSteps, GenerationStep, DelaySize]> = [\r\n        [GenerationSteps.CreateTiles, createTiles, DelaySize.None],\r\n        [GenerationSteps.CreateNodes, createRegions, DelaySize.Large],\r\n        [GenerationSteps.AssociateTiles, associateTilesWithNodes, DelaySize.Large],\r\n        [GenerationSteps.LinkNodes, populateLinks, DelaySize.Large],\r\n        [GenerationSteps.FilterLinks, filterLinks, DelaySize.Large],\r\n        [GenerationSteps.ExpandLines, linkLinesToGrid, DelaySize.Large],\r\n        [GenerationSteps.CreateRooms, createRooms, DelaySize.Large],\r\n        [GenerationSteps.DetectWalls, detectWalls, DelaySize.Large],\r\n        [GenerationSteps.CurveWalls, generateWallCurves, DelaySize.Large],\r\n        [GenerationSteps.FillBackdrop, fillBackdrop, DelaySize.Large],\r\n    ];\r\n\r\n    for (const [step, operation, endDelay] of steps) {\r\n        const stepSeed = seedGenerator.next();\r\n\r\n        if (settings.generateFrom > step) {\r\n            continue;\r\n        }\r\n\r\n        if (settings.generateTo < step) {\r\n            break;\r\n        }\r\n\r\n        const subStepReached = settings.animateFrom <= step\r\n            ? async (interval: DelaySize) => {\r\n                if (settings.animateFrom > step) {\r\n                    return; // give up on animation\r\n                }\r\n\r\n                settings.redraw(dungeon, step, false);\r\n                await delay(interval);\r\n            }\r\n            : undefined;\r\n        \r\n        await operation(dungeon, settings, stepSeed, subStepReached);\r\n        \r\n        if (settings.animateFrom <= step && endDelay > DelaySize.None) {\r\n            settings.redraw(dungeon, step, true);\r\n            await delay(endDelay);\r\n        }\r\n    }\r\n}\r\n\r\nfunction delay(milliseconds: number): Promise<void> {\r\n    return new Promise<void>(resolve => {\r\n        setTimeout(() => resolve(), milliseconds);\r\n    });\r\n}","import { Dungeon } from '../model/Dungeon';\r\nimport { DelaySize } from '../generateDungeon';\r\nimport { IGenerationSettings } from '../IGenerationSettings';\r\nimport { Tile } from '../model/Tile';\r\n\r\nexport async function createTiles(\r\n    dungeon: Dungeon,\r\n    settings: IGenerationSettings,\r\n    seed: number,\r\n    subStepComplete?: (interval: DelaySize) => Promise<void>,\r\n) {\r\n    dungeon.tiles = [];\r\n    dungeon.tilesByCoordinates = [];\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        let col = new Array<Tile>(dungeon.height);\r\n        dungeon.tilesByCoordinates[x] = col;\r\n\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = new Tile(x, y);\r\n            col[y] = tile;\r\n            dungeon.tiles.push(tile);\r\n        }\r\n    }\r\n\r\n    const maxX = dungeon.width - 1;\r\n    const maxY = dungeon.height - 1;\r\n\r\n    for (let x = 0; x < dungeon.width; x++) {\r\n        for (let y = 0; y < dungeon.height; y++) {\r\n            const tile = dungeon.tilesByCoordinates[x][y];\r\n\r\n            if (x > 0) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x-1][y+1]);\r\n                }\r\n            }\r\n\r\n            if (y > 0) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y-1]);\r\n            }\r\n\r\n            if (y < maxY) {\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x][y+1]);\r\n            }\r\n            \r\n            if (x < maxX) {\r\n                if (y > 0) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y-1]);\r\n                }\r\n\r\n                tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y]);\r\n\r\n                if (y < maxY) {\r\n                    tile.adjacentTiles.push(dungeon.tilesByCoordinates[x+1][y+1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport { FunctionComponent, useState, useEffect } from 'react';\r\nimport { Menu } from './menu/Menu';\r\nimport { FixedCanvas } from './Canvas';\r\nimport { Dungeon } from '../dungeon/model/Dungeon';\r\nimport './App.css';\r\nimport { renderDungeon } from '../dungeon/renderDungeon';\r\nimport { generateDungeon, regenerateDungeon } from '../dungeon/generateDungeon';\r\nimport { GenerationSteps } from '../dungeon/GenerationSteps';\r\nimport { determineRenderSettings, IRenderSettings } from '../dungeon/IRenderSettings';\r\nimport { IGenerationSettings } from '../dungeon/IGenerationSettings';\r\n\r\nexport const App: FunctionComponent = () => {\r\n    const canvas = React.useRef<FixedCanvas>(null);\r\n\r\n    const [dungeon, setDungeon] = useState<Dungeon>(new Dungeon());\r\n    const [generating, setGenerating] = useState(false);\r\n\r\n    const cellSize = 10;\r\n\r\n    const [renderSettings, setRenderSettings] = useState<IRenderSettings>(determineRenderSettings(GenerationSteps.Render, true, cellSize));\r\n    \r\n    const [generationSettings, setGenerationSettings] = useState<IGenerationSettings>({\r\n        seed: 0,\r\n        generateFrom: GenerationSteps.FIRST_STEP,\r\n        generateTo: GenerationSteps.Render,\r\n        animateFrom: GenerationSteps.Render,\r\n        cellsWide: 100,\r\n        cellsHigh: 70,\r\n        nodeCount: 25,\r\n        connectivity: 50,\r\n        redraw: (dungeon: Dungeon, stage: GenerationSteps, stageComplete: boolean) => { \r\n            if (canvas.current !== null) {\r\n                renderDungeon(dungeon, canvas.current.ctx!, determineRenderSettings(stage, stageComplete, cellSize));\r\n            }\r\n        },\r\n    });\r\n\r\n    const generate = async (generateTo: GenerationSteps) => {\r\n        const settings = {\r\n            ...generationSettings,\r\n            seed: Math.random(),\r\n            animateFrom: GenerationSteps.Render,\r\n            generateFrom: GenerationSteps.FIRST_STEP,\r\n            generateTo,\r\n        };\r\n\r\n        setGenerationSettings(settings);\r\n        setGenerating(true);\r\n\r\n        const dungeon = await generateDungeon(settings);\r\n\r\n        setDungeon(dungeon);\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const regenerate = async (animate: boolean, regenerateFrom: GenerationSteps, generateTo: GenerationSteps) => {\r\n        // clear the grid if regenerating\r\n        if (regenerateFrom !== GenerationSteps.FIRST_STEP) {\r\n            await regenerateDungeon(dungeon, {\r\n                ...generationSettings,\r\n                animateFrom: GenerationSteps.Render,\r\n                generateFrom: GenerationSteps.CreateTiles,\r\n                generateTo: GenerationSteps.CreateTiles,\r\n            });\r\n        }\r\n\r\n        setGenerating(true);\r\n\r\n        await regenerateDungeon(dungeon, {\r\n            ...generationSettings,\r\n            animateFrom: animate\r\n                ? regenerateFrom\r\n                : GenerationSteps.Render,\r\n            generateFrom: regenerateFrom,\r\n            generateTo,\r\n        });\r\n\r\n        setGenerating(false);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    const skip = () => generationSettings.animateFrom++;\r\n    const finish = () => generationSettings.animateFrom = GenerationSteps.Render;\r\n\r\n    useEffect(() => { generate(GenerationSteps.Render) }, []); // eslint-disable-line\r\n\r\n    const setRenderSettingsAndRender = (renderSettings: IRenderSettings) => {\r\n        setRenderSettings(renderSettings);\r\n\r\n        if (canvas.current !== null) {\r\n            renderDungeon(dungeon, canvas.current.ctx!, renderSettings);\r\n        }\r\n    }\r\n\r\n    return (    \r\n        <div className=\"App\">\r\n            <Menu\r\n                dungeon={dungeon}\r\n                canvas={canvas.current === null ? undefined : canvas.current.canvas}\r\n                cellSize={cellSize}\r\n                isGenerating={generating}\r\n                generationSettings={generationSettings}\r\n                setGenerationSettings={setGenerationSettings}\r\n                setRenderSettings={setRenderSettingsAndRender}\r\n                generate={generate}\r\n                regenerate={regenerate}\r\n                skip={skip}\r\n                finish={finish}\r\n            />\r\n            <FixedCanvas\r\n                className=\"dungeonDisplay\"\r\n                width={cellSize * generationSettings.cellsWide}\r\n                height={cellSize * generationSettings.cellsHigh}\r\n                ref={canvas}\r\n            />\r\n        </div>\r\n    );\r\n}","// tslint:disable:no-console\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the 'N+1' visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL!,\n      window.location.toString()\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker) {\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and\n                // the fresh content will have been added to the cache.\n                // It's the perfect time to display a 'New content is\n                // available; please refresh.' message in your web app.\n                console.log('New content is available; please refresh.');\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // 'Content is cached for offline use.' message.\n                console.log('Content is cached for offline use.');\n              }\n            }\n          };\n        }\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type')!.indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport { App } from './components/App';\r\nimport registerServiceWorker from './registerServiceWorker';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root') as HTMLElement\r\n);\r\nregisterServiceWorker();\r\n"],"sourceRoot":""}